#+property: results silent

* Load Path
  #+begin_src emacs-lisp 
    (setq dotfiles-dir (file-name-directory
                        (or load-file-name (buffer-file-name))))
    
    (add-to-list 'load-path dotfiles-dir)
    (add-to-list 'load-path (concat dotfiles-dir "/ext/"))
    (add-to-list 'load-path (concat dotfiles-dir "/int/"))
    (add-to-list 'load-path (concat dotfiles-dir "/ext/clojure-mode/"))
    (add-to-list 'load-path (concat dotfiles-dir "/ext/gitsum/"))
    (add-to-list 'load-path (concat dotfiles-dir "/ext/org-mode/lisp/"))
  #+end_src

  #+begin_src emacs-lisp 
    (load "searchDown.el")
    (load "jump.el")
    (load "clojure-mode.el")
    (require 'diff-mode)  
    (require 'org)
  #+end_src

* General
** Options
   #+begin_src emacs-lisp 
     (setq large-file-warning-threshold 256000000 )
     ;;debug
     (setq debug-on-error t) 
     ;;enable blinking cursor
     (blink-cursor-mode 1)
     (put 'erase-buffer 'disabled nil)
     
     (when window-system
       ;;disable scroll bar
       (toggle-scroll-bar nil)
       (tool-bar-mode -1))
     
     (menu-bar-mode -1)
     ;;do not continue line when split frame
     (setq truncate-partial-width-windows nil)
     ;; turn on font-lock mode
     (global-font-lock-mode t)
     (when window-system
       ;; use extended compound-text coding for X clipboard
       (set-selection-coding-system 'compound-text-with-extensions))
     
     (setq bookmark-default-file "~/.emacs.d/emacs.bmk")
     (setq column-number-mode t)
     (setq dired-dwim-target t)
     (setq fill-column 72)
     (setq inhibit-startup-screen t)
     (setq next-line-add-newlines nil)
     (setq query-replace-highlight t)
     (setq search-highlight t)
     (setq transient-mark-mode t)

     ;; I hate tabs!
     (setq-default indent-tabs-mode nil)
     (setq delete-by-moving-to-trash t)
     
     ;disable backup
     (setq backup-inhibited t)
   #+end_src

   Detect OS,

   #+begin_src emacs-lisp 
     (defvar na-os-is-darwin nil)
     (defvar na-os-is-windows nil)
     (defvar na-os-is-linux nil)
     
     (cond
      ((string-match "GNU" (emacs-version))
       (cond 
        ((string-match "linux" system-configuration)  (setq na-os-is-linux t))
        ((string-match "nt" system-configuration)     (setq na-os-is-windows t))
        ((string-match "cygwin" system-configuration) (setq na-os-is-windows t))
        ((string-match "apple" system-configuration)  (setq na-os-is-darwin t)))))
   #+end_src

   Do not open a new frame for each file on OSX,

   #+begin_src emacs-lisp 
     (when na-os-is-darwin
       (setq ns-pop-up-frames nil))
   #+end_src

   Replace yes or no with y or n,

   #+begin_src emacs-lisp 
     (defun yes-or-no-p (arg)
       "An alias for y-or-n-p, because I hate having to type 'yes' or 'no'."
       (y-or-n-p arg))
   #+end_src

   Color on selection,

   #+begin_src emacs-lisp 
     (defface completion-setup-directory-face  '((t (:foreground "Blue")))
       "Face to use for directories."
       :group 'color-file-completion)
     
     (defcustom color-file-completion-always t "If true, always turn on regexps in
     completion buffers."
       :group 'color-file-completion
       :type 'boolean)
     
     (defun completion-setup-directory-face()
       "When we are completing a filename, highlight directories."
       (interactive)
       ;;if this is completing a filename... highlight faces...
       (when (or color-file-completion-always
                 (eq minibuffer-completion-table 'read-file-name-internal))
         (let((font-lock-verbose nil))
           (font-lock-mode 1)
           (font-lock-add-keywords nil '(("[^ \n]+/" 0 'completion-setup-directory-face keep)))
           (font-lock-fontify-buffer))))
     
     (add-hook 'completion-list-mode-hook 'completion-setup-directory-face)
   #+end_src

   Support Turkish alphabet,

   #+begin_src emacs-lisp 
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
   #+end_src

   Copy/Paste under Linux

   #+begin_src emacs-lisp 
     (when na-os-is-linux
       (setq x-select-enable-clipboard t))
   #+end_src

   #+begin_src emacs-lisp
     (defun na-fullscreen (&optional f)
       (interactive) 
       (if na-os-is-darwin
           ;; included in emacs 23.2 
           ;; FIXME: the ns version doesn't take the frame option 
           (ns-toggle-fullscreen) 
         (set-frame-parameter 
          f 'fullscreen 
          (if (frame-parameter f 'fullscreen) 
              nil 'fullboth))))
   #+end_src

** Input

   #+begin_src emacs-lisp 
     (defun scroll-window-forward-line ()
       "Move window forward one line leaving cursor at relative position in window."
       (interactive)
       (scroll-up 1))
     
     (defun scroll-window-backward-line ()
       "Move window backward one line leaving cursor at relative position in window."
       (interactive)
       (scroll-down 1)) 
     
     (define-key global-map [wheel-up] 'scroll-window-backward-line)
     (define-key global-map [wheel-down] 'scroll-window-forward-line)
   #+end_src

   Mouse setup when running in a terminal,

   #+begin_src emacs-lisp
     (unless window-system
       (xterm-mouse-mode t)
       (require 'mouse)
       (defun track-mouse (e)) 
       (setq mouse-sel-mode t)
     
       (define-key global-map [mouse-4] 'scroll-window-backward-line)
       (define-key global-map [mouse-5] 'scroll-window-forward-line))
   #+end_src

   Set up the keyboard so the delete key on both the regular keyboard
   and the keypad delete the character under the cursor and to the right
   under X, instead of the default, backspace behavior.

   #+begin_src emacs-lisp 
     (global-set-key [delete] 'delete-char)
     (global-set-key [kp-delete] 'delete-char)
   #+end_src

   Mac specific,

   #+begin_src emacs-lisp 
     (global-set-key [(meta h)] 'ns-do-hide-emacs)
     (setq mac-option-modifier 'super)
     (setq mac-command-modifier 'meta)
   #+end_src

   #+begin_src emacs-lisp 
     (global-set-key [f3] 'org-agenda)
     (global-set-key [f8] 'toggle-truncate-lines)
     (global-set-key [f12] 'org-babel-tangle)
     
     (global-set-key [(control d)] 'na-bounce-sexp)
     
     (define-key global-map [(control \])] 'ibuffer)
     (add-hook 'term-mode-hook
               '(lambda ()
                  (define-key term-raw-map [(control \])] 'ibuffer)))
     
     (define-key global-map [(meta p)] 'na-cm-rotate)
     (define-key global-map [(meta control  p)] 'na-cm-save-point)
     
     (add-hook 'term-mode-hook
               '(lambda ()
                  (define-key term-raw-map [(control \\)] 'other-window)))
     (global-set-key [(control \\)] 'other-window)
     
     (global-set-key "\C-xgs" 'na-run-git-switch)
     (global-set-key "\C-xrl" 'na-run-lisp)
     (global-set-key "\C-xtr" 'na-run-term)
     (global-set-key [(control q)] 'na-switch-between-terminals)
     (add-hook 'term-mode-hook
               '(lambda ()
                  (define-key term-raw-map [(control q)] 'na-switch-between-terminals)))
     
     
     (define-key global-map [home] 'beginning-of-line)
     (define-key global-map [end] 'end-of-line)
   #+end_src

** Session

   #+begin_src emacs-lisp 
     (load "desktop")
     (desktop-load-default)
     (setq desktop-enable t)
     (require 'saveplace)
     (setq-default save-place t)
     (setq bookmark-save-flag 1)
   #+end_src

   #+begin_src emacs-lisp 
     (add-hook 'server-visit-hook 'call-raise-frame)
     (add-hook 'find-file-hook 'call-raise-frame)
     
     (defun call-raise-frame ()
       (raise-frame))
   #+end_src

** Theme

  #+begin_src emacs-lisp 
    (setq frame-title-format (list "GNU Emacs " emacs-version))
    (setq display-time-day-and-date nil )
    (setq display-time-format "") 
    (setq display-time-load-average-threshold 0 )
    (setq display-time-string-forms '( load "," (if mail "" "")) )
    (setq display-time-interval 5)
    (display-time-mode 1)
    (setq battery-mode-line-format "%b%p%" )
    (display-battery-mode t)
    
    (setq-default mode-line-format
                  '(""
                    mode-line-modified
                    (-3 . "%p") ;; position
                    "[%b]"
                    "%[("
                    mode-name
                    mode-line-process
                    minor-mode-alist
                    "%n" ")%]-"
                    (line-number-mode "L%l-")
                    (column-number-mode "C%c [")
                    global-mode-string
                    "] "
                    "%f"                ;; print file with full path
                    " %-"))
  #+end_src

  #+begin_src emacs-lisp 
    (if window-system
        (progn 
          (set-face-foreground 'default "#bcbcbc")
          (set-face-background 'default "#121212")
          (set-face-foreground 'font-lock-string-face "#afafff")
          (set-face-foreground 'font-lock-keyword-face "#ff5f00")
          (set-face-foreground 'font-lock-function-name-face "#d7af00")
          (set-face-foreground 'font-lock-builtin-face "#afd700")
          (set-face-foreground 'font-lock-comment-face "#008787")
          (set-face-foreground 'org-block-begin-line "#303030")
          (set-face-foreground 'org-block-end-line "#303030")
          (set-face-foreground 'diff-added "#00ff00")
          (set-face-foreground 'diff-removed "#ff0000")
          (set-face-foreground 'diff-header "#005fff")
          (set-face-background 'diff-header "#121212")
          (set-face-background 'diff-file-header "#121212"))
      (progn 
        (set-face-foreground 'default "color-250")
        (set-face-background 'default "color-233")
        (set-face-foreground 'font-lock-string-face "color-147")
        (set-face-foreground 'font-lock-keyword-face "color-202")
        (set-face-foreground 'font-lock-function-name-face "color-178")
        (set-face-foreground 'font-lock-builtin-face "color-148")
        (set-face-foreground 'font-lock-comment-face "color-30")
        (set-face-foreground 'org-block-begin-line "color-236")
        (set-face-foreground 'org-block-end-line "color-236")
        (set-face-foreground 'diff-added "brightgreen")
        (set-face-foreground 'diff-removed "brightred")
        (set-face-foreground 'diff-header "color-27")
        (set-face-background 'diff-header "color-233")
        (set-face-background 'diff-file-header "color-233")))
  #+end_src

* Modes
** Markdown
   #+begin_src emacs-lisp 
     (autoload 'markdown-mode "markdown-mode.el"
       "Major mode for editing Markdown files" t)
   #+end_src

** Dired
   #+begin_src emacs-lisp 
     (require 'dired)
     (require 'dired-details)
     (dired-details-install)
     
     (defun na-dired-up-directory-after-kill ()
       "Call 'dired-up-directory' after calling '(kill-buffer (current-buffer))'."
       (interactive)
       (let ((buf (current-buffer)))
         (dired-up-directory)
         (kill-buffer buf)))
     (define-key dired-mode-map "\C-w" 'na-dired-up-directory-after-kill)
   #+end_src

** Org

   #+begin_src emacs-lisp
     (add-hook 'org-mode-hook 'abbrev-mode)
     (setq org-directory "~/Dropbox/org/")
     (setq org-return-follows-link t)
     (setq org-hide-leading-stars t)
   #+end_src

*** agenda

    #+begin_src emacs-lisp
      (setq org-mobile-inbox-for-pull "~/Dropbox/org/from-mobile.org")
      (setq org-mobile-directory "~/Dropbox/mobile-org")
      (setq org-mobile-files (quote ("gtd.org")))
      (setq org-agenda-files (list "~/Dropbox/org/gtd.org"))
      
      (setq org-mobile-force-id-on-agenda-items nil)
      (setq org-agenda-custom-commands
            '(("h" "Agenda and Todo"
                    ((agenda "" ((org-agenda-ndays 3)))
                     (todo "TODO")
                     (todo "WAITING")
                     (todo "RESEARCH")))
              ("W" agenda "" ((org-agenda-ndays 21)
                              (org-agenda-show-all-dates nil)))))
      
      (setq org-agenda-window-setup 'other-window)
      (setq org-agenda-restore-windows-after-quit t)
      (setq org-agenda-show-all-dates t)
      
    #+end_src

    if idle for 5 minutes, display the current agenda.

    #+begin_src emacs-lisp
      (defun jump-to-org-agenda ()
        (interactive)
        (let ((agenda-window (get-buffer-window org-agenda-buffer-name t)))
          (if agenda-window
            (with-selected-window agenda-window (org-agenda-redo))
            (funcall (lambda () (org-agenda nil "h"))))))
      
      (run-with-idle-timer 300 t 'jump-to-org-agenda)
    #+end_src

*** latex

    #+begin_src emacs-lisp
      (require 'org-latex)
        (setq org-export-latex-listings t)
      
          
        (add-to-list 'org-export-latex-classes
                     '("literate-code"
                       "\\documentclass{article}\n
                       \\usepackage[x11names]{xcolor} % for a (setq of predefined color names, like LemonChiffon1
                       \\renewcommand{\\rmdefault}{phv} % Arial \n
                       \\renewcommand{\\sfdefault}{phv} % Arial
                       \\setlength{\\parindent}{0pt}
                       \\setlength{\\parskip}{1ex plus 0.5ex minus 0.2ex}
      
                       \\usepackage{tikz}
                       \\usetikzlibrary{backgrounds,shapes,arrows,positioning,calc,snakes,fit}
                       \\usepgflibrary{decorations.markings}
                       \\usepackage{mathtools}
      
                       \\usepackage[hmargin=3cm,vmargin=3.5cm]{geometry} \n
                       \\usepackage{hyperref}
                       \\hypersetup{
                           colorlinks,%
                           citecolor=black,%
                           filecolor=black,%
                           linkcolor=blue,%
                           urlcolor=black
                       }
                       \\RequirePackage[calcwidth]{titlesec}
                       \\RequirePackage{color}
                       
                       \\definecolor{seccol}{rgb}{0.1,0.5,1.0}
                         
                       \\titleformat{\\section}[hang]{\\sffamily\\bfseries}
                       {\\color{seccol}\\Huge\\thesection}{0pt}{\\linebreak\\huge\\raggedleft}[{\\titlerule[0.5pt]}]
        
                       \\titleformat{\\subsection}[hang]{\\sffamily\\bfseries\\underline}
                       {}{0pt}{\\linebreak\\Large}[]
        
                       \\titleformat{\\subsubsection}[hang]{\\sffamily\\bfseries\\underline}
                       {}{0pt}{\\linebreak\\large}[]
        
        
                       \\usepackage{listings}
                       
                       \\definecolor{lineno}{rgb}{0.5,0.5,0.5}
                       \\definecolor{code}{rgb}{0,0.1,0.6}
                       \\definecolor{keyword}{rgb}{0.5,0.1,0.1}
                       
                       \\lstset{
                           basicstyle=\\sffamily\\small\\color{code},
                           showspaces=false,
                           showstringspaces=false,
                           numbers=left,
                           firstnumber=1,
                           stepnumber=5,
                           numberfirstline=true,
                           numberstyle=\\color{lineno}\\sffamily\\scriptsize,
                           keywordstyle=\\color{keyword}\\bfseries,
                           stringstyle=\\itshape
                       }
                       
                       \\makeatletter
                       \\gdef\\lst@SkipOrPrintLabel{%
                           \\ifnum\\lst@skipnumbers=\\z@
                               \\global\\advance\\lst@skipnumbers-\\lst@stepnumber\\relax
                               \\lst@PlaceNumber
                               \\lst@numberfirstlinefalse
                           \\else
                               \\lst@ifnumberfirstline
                                   {\\def\\thelstnumber{Line \\@arabic\\c@lstnumber}\\lst@PlaceNumber}%
                                   \\lst@numberfirstlinefalse
                               \\else
                                   {\\def\\thelstnumber{-}\\lst@PlaceNumber}%
                               \\fi
                           \\fi
                           \\global\\advance\\lst@skipnumbers\\@ne}%
                       \\makeatother
                       
                       \\lstdefinelanguage{Lisp}%
                       {morekeywords={*,*1,*2,*3,*agent*,*allow-unresolved-vars*,*assert*,*clojure-version*,*command-line-args*,%
                       *compile-files*,*compile-path*,*e,*err*,*file*,*flush-on-newline*,*in*,*macro-meta*,%
                       *math-context*,*ns*,*out*,*print-dup*,*print-length*,*print-level*,*print-meta*,*print-readably*,%
                       *read-eval*,*source-path*,*use-context-classloader*,*warn-on-reflection*,+,-,->,->>,..,/,:else,%
                       <,<=,=,==,>,>=,@,accessor,aclone,add-classpath,add-watch,agent,agent-errors,aget,alength,alias,%
                       all-ns,alter,alter-meta!,alter-var-root,amap,ancestors,and,apply,areduce,array-map,aset,%
                       aset-boolean,aset-byte,aset-char,aset-double,aset-float,aset-int,aset-long,aset-short,assert,%
                       assoc,assoc!,assoc-in,associative?,atom,await,await-for,await1,bases,bean,bigdec,bigint,binding,%
                       bit-and,bit-and-not,bit-clear,bit-flip,bit-not,bit-or,bit-set,bit-shift-left,bit-shift-right,%
                       bit-test,bit-xor,boolean,boolean-array,booleans,bound-fn,bound-fn*,butlast,byte,byte-array,%
                       bytes,cast,char,char-array,char-escape-string,char-name-string,char?,chars,chunk,chunk-append,%
                       chunk-buffer,chunk-cons,chunk-first,chunk-next,chunk-rest,chunked-seq?,class,class?,%
                       clear-agent-errors,clojure-version,coll?,comment,commute,comp,comparator,compare,compare-and-set!,%
                       compile,complement,concat,cond,condp,conj,conj!,cons,constantly,construct-proxy,contains?,count,%
                       counted?,create-ns,create-struct,cycle,dec,decimal?,declare,def,definline,defmacro,defmethod,%
                       defmulti,defn,defn-,defonce,defprotocol,defstruct,deftype,delay,delay?,deliver,deref,derive,%
                       descendants,destructure,disj,disj!,dissoc,dissoc!,distinct,distinct?,do,do-template,doall,doc,%
                       dorun,doseq,dosync,dotimes,doto,double,double-array,doubles,drop,drop-last,drop-while,empty,empty?,%
                       ensure,enumeration-seq,eval,even?,every?,false,false?,ffirst,file-seq,filter,finally,find,find-doc,%
                       find-ns,find-var,first,float,float-array,float?,floats,flush,fn,fn?,fnext,for,force,format,future,%
                       future-call,future-cancel,future-cancelled?,future-done?,future?,gen-class,gen-interface,gensym,%
                       get,get-in,get-method,get-proxy-class,get-thread-bindings,get-validator,hash,hash-map,hash-set,%
                       identical?,identity,if,if-let,if-not,ifn?,import,in-ns,inc,init-proxy,instance?,int,int-array,%
                       integer?,interleave,intern,interpose,into,into-array,ints,io!,isa?,iterate,iterator-seq,juxt,%
                       key,keys,keyword,keyword?,last,lazy-cat,lazy-seq,let,letfn,line-seq,list,list*,list?,load,load-file,%
                       load-reader,load-string,loaded-libs,locking,long,long-array,longs,loop,macroexpand,macroexpand-1,%
                       make-array,make-hierarchy,map,map?,mapcat,max,max-key,memfn,memoize,merge,merge-with,meta,%
                       method-sig,methods,min,min-key,mod,monitor-enter,monitor-exit,name,namespace,neg?,new,newline,%
                       next,nfirst,nil,nil?,nnext,not,not-any?,not-empty,not-every?,not=,ns,ns-aliases,ns-imports,%
                       ns-interns,ns-map,ns-name,ns-publics,ns-refers,ns-resolve,ns-unalias,ns-unmap,nth,nthnext,num,%
                       number?,odd?,or,parents,partial,partition,pcalls,peek,persistent!,pmap,pop,pop!,pop-thread-bindings,%
                       pos?,pr,pr-str,prefer-method,prefers,primitives-classnames,print,print-ctor,print-doc,print-dup,%
                       print-method,print-namespace-doc,print-simple,print-special-doc,print-str,printf,println,println-str,%
                       prn,prn-str,promise,proxy,proxy-call-with-super,proxy-mappings,proxy-name,proxy-super,%
                       push-thread-bindings,pvalues,quot,rand,rand-int,range,ratio?,rational?,rationalize,re-find,%
                       re-groups,re-matcher,re-matches,re-pattern,re-seq,read,read-line,read-string,recur,reduce,ref,%
                       ref-history-count,ref-max-history,ref-min-history,ref-set,refer,refer-clojure,reify,%
                       release-pending-sends,rem,remove,remove-method,remove-ns,remove-watch,repeat,repeatedly,%
                       replace,replicate,require,reset!,reset-meta!,resolve,rest,resultset-seq,reverse,reversible?,%
                       rseq,rsubseq,second,select-keys,send,send-off,seq,seq?,seque,sequence,sequential?,set,set!,%
                       set-validator!,set?,short,short-array,shorts,shutdown-agents,slurp,some,sort,sort-by,sorted-map,%
                       sorted-map-by,sorted-set,sorted-set-by,sorted?,special-form-anchor,special-symbol?,split-at,%
                       split-with,str,stream?,string?,struct,struct-map,subs,subseq,subvec,supers,swap!,symbol,symbol?,%
                       sync,syntax-symbol-anchor,take,take-last,take-nth,take-while,test,the-ns,throw,time,to-array,%
                       to-array-2d,trampoline,transient,tree-seq,true,true?,try,type,unchecked-add,unchecked-dec,%
                       unchecked-divide,unchecked-inc,unchecked-multiply,unchecked-negate,unchecked-remainder,%
                       unchecked-subtract,underive,unquote,unquote-splicing,update-in,update-proxy,use,val,vals,%
                       var,var-get,var-set,var?,vary-meta,vec,vector,vector?,when,when-first,when-let,when-not,%
                       while,with-bindings,with-bindings*,with-in-str,with-loading-context,with-local-vars,%
                       with-meta,with-open,with-out-str,with-precision,xml-seq,zero?,zipmap
                       },%
                          sensitive,% ???
                          alsodigit=-,%
                          morecomment=[l];,%
                          morestring=[b]\"%
                         }[keywords,comments,strings]%"
        
                       ("\\section{%s}" . "\\section*{%s}")
                       ("\\subsection{%s}" . "\\subsection*{%s}")
                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                       ("\\paragraph{%s}" . "\\paragraph*{%s}")
                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
      
    #+end_src

*** babel

    #+begin_src emacs-lisp
      (require 'ob)
      (require 'ob-sh)
      (setq org-src-window-setup 'current-window)
      (setq org-src-fontify-natively t)
      (setq org-confirm-babel-evaluate nil)
    #+end_src

** IBuffer

   #+begin_src emacs-lisp 
     (setq ibuffer-saved-filter-groups
           (quote (("default"
                 ("Source" (or
                            (mode . java-mode)
                            (mode . clojure-mode)
                            (mode . org-mode)
                            (mode . xml-mode)
                            (mode . scheme-mode)
                            (mode . ruby-mode)
                            (mode . shell-script-mode)
                            (mode . sh-mode)
                            (mode . c-mode)
                            (mode . lisp-mode)
                            (mode . cperl-mode)
                            (mode . asm-mode)
                            (mode . emacs-lisp-mode)
                            (mode . c++-mode)))
                 ("Terminal" (or (mode . term-mode)
                                 (mode . inferior-lisp-mode)))
                 ("Dired" (mode . dired-mode))
                 ("Gnus" (or
                          (mode . message-mode)
                          (mode . mail-mode)
                          (mode . gnus-group-mode)
                          (mode . gnus-summary-mode)
                          (mode . gnus-article-mode)
                          (name . "^\\*offlineimap\\*$")
                          (name . "^\\.newsrc-dribble")))
                 ("Emacs" (or
                           (name . "^\\*info\\*$")
                           (name . "^\\*tramp.+\\*$")
                           (name . "^\\*trace.+SMTP.+\\*$")
                           (name . "^\\*mpg123\\*$")
                           (name . "^\\.todo-do")
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*git-status\\*$")
                           (name . "^\\*git-diff\\*$")
                           (name . "^\\*git-commit\\*$")
                           (name . "^\\*Git Command Output\\*$")
                           (name . "^\\*Org Export/Publishing Help\\*$")
                           (name . "^\\*Org Agenda\\*$")
                           (name . "^\\*Calendar\\*$")
                           (name . "^\\*Messages\\*$")
                           (name . "^\\*Completions\\*$") 
                           (name . "^\\*Backtrace\\*$")
                           (name . "^TAGS$")
                           (name . "^\\*Help\\*$")
                           (name . "^\\*Shell Command Output\\*$")))))))
     
     (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))
     (setq ibuffer-expert t)
     
     (setq ibuffer-formats '((mark modified read-only " "
                                   (name 18 18 :left :elide)
                                   " "
                                   (mode 16 16 :left :elide)
                                   " " filename-and-process)
                             (mark " "
                                   (name 16 -1)
                                   " " filename)))
     
   #+end_src

** EasyPG

   #+begin_src emacs-lisp 
     (require 'epa)
     (epa-file-enable)
     
     (cond 
      (na-os-is-darwin  (setq epg-gpg-program "/opt/local/bin/gpg"))
      (na-os-is-windows (setq epg-gpg-program (concat "/bin/gpg"))))
   #+end_src

** Text Mode
   #+begin_src emacs-lisp 
     (delete-selection-mode)
     (setq fill-column 80)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   #+end_src

** Flyspell
   #+begin_src emacs-lisp 
     (setq ispell-program-name "/opt/local/bin/ispell")
     (autoload 'flyspell-mode "flyspell" "On-the-fly spelling checker." t)
     (add-hook 'message-mode-hook 'turn-on-flyspell)
     (add-hook 'text-mode-hook 'turn-on-flyspell)
     (add-hook 'c-mode-common-hook 'flyspell-prog-mode)
     (add-hook 'java-mode-hook 'flyspell-prog-mode)
     (add-hook 'ruby-mode-hook 'flyspell-prog-mode)
     (add-hook 'lisp-mode-hook 'flyspell-mode)
     (add-hook 'emacs-lisp-mode-hook 'flyspell-mode)
     (defun turn-on-flyspell ()
       "Force flyspell-mode on using a positive arg.  For use in hooks."
       (interactive)
       (flyspell-mode 1))
   #+end_src

** smart-tab

   #+begin_src emacs-lisp
     ;;; smart-tab.el --- Intelligent tab completion and indentation.
     
     ;; This file is NOT part of GNU Emacs.
     
     ;; Copyright (C) 2009-2011 John SJ Anderson,
     ;;                         Sebastien Rocca Serra,
     ;;                         Daniel Hackney
     ;; Author: John SJ Anderson <genehack@genehack.org>,
     ;;         Sebastien Rocca Serra <sroccaserra@gmail.com>,
     ;;         Daniel Hackney <dan@haxney.org>
     ;; Maintainer: John SJ Anderson <genehack@genehack.org>
     ;; Keywords: extensions
     ;; Created: 2009-05-24
     ;; URL: http://github.com/genehack/smart-tab/tree/master
     ;; Version: 0.3
     ;;
     ;; This program is free software; you can redistribute it and/or modify it under
     ;; the terms of the GNU General Public License as published by the Free Software
     ;; Foundation; either version 3, or (at your option) any later version.
     ;;
     ;; This program is distributed in the hope that it will be useful, but WITHOUT
     ;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     ;; FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
     ;; details.
     ;;
     ;; You should have received a copy of the GNU General Public License
     ;; along with this program. If not, see <http://www.gnu.org/licenses/>.
     
     ;;; Commentary:
     
     ;; INSTALL
     ;;
     ;; To install, put this file along your Emacs-Lisp `load-path' and add
     ;; the following into your ~/.emacs startup file or set
     ;; `global-smart-tab-mode' to non-nil with customize:
     ;;
     ;;     (require 'smart-tab)
     ;;     (global-smart-tab-mode 1)
     ;;
     ;; DESCRIPTION
     ;;
     ;; Try to 'do the smart thing' when tab is pressed. `smart-tab'
     ;; attempts to expand the text before the point or indent the current
     ;; line or selection.
     ;;
     ;; See <http://www.emacswiki.org/cgi-bin/wiki/TabCompletion#toc2>. There are a
     ;; number of available customizations on that page.
     ;;
     ;; Features that might be required by this library:
     ;;
     ;;   `easy-mmmode'
     
     ;;; Change Log:
     
     ;;; Code:
     
     (require 'easy-mmode)
     
     (defgroup smart-tab nil
       "Options for `smart-tab-mode'.")
     
     (defcustom smart-tab-using-hippie-expand nil
       "Use `hippie-expand' to expand text.
     Use either `hippie-expand' or `dabbrev-expand' for expanding text
     when we don't have to indent."
       :type '(choice
               (const :tag "hippie-expand" t)
               (const :tag "dabbrev-expand" nil))
       :group 'smart-tab)
     
     (defcustom smart-tab-completion-functions-alist
       '((emacs-lisp-mode . lisp-complete-symbol)
         (text-mode       . dabbrev-completion))
       "A-list of major modes in which to use a mode specific completion function.
     If current major mode is not found in this alist, fall back to
     `hippie-expand' or `dabbrev-expand', depending on the value of
     `smart-tab-using-hippie-expand'"
       :type '(alist :key-type (symbol :tag "Major mode")
                     :value-type (function :tag "Completion function to use in this mode"))
       :group 'smart-tab)
     
     (defcustom smart-tab-disabled-major-modes '(org-mode term-mode)
       "List of major modes that should not use `smart-tab'."
       :type 'sexp
       :group 'smart-tab)
     
     (defun smart-tab-call-completion-function ()
       "Get a completion function according to current major mode."
       (let ((completion-function
              (cdr (assq major-mode smart-tab-completion-functions-alist))))
         (if (null completion-function)
             (if (and (not (minibufferp))
                      (memq 'auto-complete-mode minor-mode-list)
                      auto-complete-mode)
                 (ac-start :force-init t)
               (if smart-tab-using-hippie-expand
                   (hippie-expand nil)
                 (dabbrev-expand nil)))
           (funcall completion-function))))
     
     (defun smart-tab-must-expand (&optional prefix)
       "If PREFIX is \\[universal-argument] or the mark is active, do not expand.
     Otherwise, uses the user's preferred expansion function to expand
     the text at point."
       (unless (or (consp prefix)
                   (use-region-p))
         (looking-at "\\_>")))
     
     (defun smart-tab-default ()
       "Indent region if mark is active, or current line otherwise."
       (interactive)
       (if (use-region-p)
           (indent-region (region-beginning)
                          (region-end))
         (indent-for-tab-command)))
     
     ;;;###autoload
     (defun smart-tab (&optional prefix)
       "Try to 'do the smart thing' when tab is pressed.
     `smart-tab' attempts to expand the text before the point or
     indent the current line or selection.
     
     In a regular buffer, `smart-tab' will attempt to expand with
     either `hippie-expand' or `dabbrev-expand', depending on the
     value of `smart-tab-using-hippie-expand'. Alternatively, if
     `auto-complete-mode' is enabled in the current buffer,
     `auto-complete' will be used to attempt expansion. If the mark is
     active, or PREFIX is \\[universal-argument], then `smart-tab'
     will indent the region or the current line (if the mark is not
     active)."
       (interactive "P")
       (if (smart-tab-must-expand prefix)
           (smart-tab-call-completion-function))
       (smart-tab-default))
     
     ;;;###autoload
     (defun smart-tab-mode-on ()
       "Turn on `smart-tab-mode'."
         (smart-tab-mode 1))
     
     (defun smart-tab-mode-off ()
       "Turn off `smart-tab-mode'."
       (smart-tab-mode -1))
     
     ;;;###autoload
     (define-minor-mode smart-tab-mode
       "Enable `smart-tab' to be used in place of tab.
     
     With no argument, this command toggles the mode.
     Non-null prefix argument turns on the mode.
     Null prefix argument turns off the mode."
       :lighter " Smrt"
       :group 'smart-tab
       :require 'smart-tab
       :keymap '(("\t" . smart-tab)
                 ([(tab)] . smart-tab))
       (if smart-tab-mode
           (progn
             ;; Don't start `smart-tab-mode' when in the minibuffer or a read-only
             ;; buffer.
             (when (or (minibufferp)
                       buffer-read-only
                       (member major-mode smart-tab-disabled-major-modes))
               (smart-tab-mode-off)))))
     
     ;;;###autoload
     (define-globalized-minor-mode global-smart-tab-mode
       smart-tab-mode
       smart-tab-mode-on
       :group 'smart-tab)
     
     (provide 'smart-tab)
     
     ;;; smart-tab.el ends here
     
     (global-smart-tab-mode 1)
   #+end_src

** Lisp
*** Common

    #+begin_src emacs-lisp
      (defun na-bounce-sexp ()
        "Will bounce between matching parens just like % in vi"
        (interactive)
        (let ((prev-char (char-to-string (preceding-char)))
              (next-char (char-to-string (following-char))))
          (cond ((string-match "[[{(<]" next-char) (forward-sexp 1))
                ((string-match "[\]})>]" prev-char) (backward-sexp 1))
                (t (error "%s" "Not on a paren, brace, or bracket")))))
      
      (defun lispy-parens ()
        "Setup parens display for lisp modes"
        (setq show-paren-delay 0)
        (setq show-paren-style 'parenthesis)
        (make-variable-buffer-local 'show-paren-mode)
        (show-paren-mode 1)
        (set-face-background 'show-paren-match-face (face-background 'default))
        (if (boundp 'font-lock-comment-face)
            (set-face-foreground 'show-paren-match-face 
                                 (face-foreground 'font-lock-comment-face))
          (set-face-foreground 'show-paren-match-face 
                               (face-foreground 'default)))
        (set-face-foreground 'show-paren-match-face "red")
        (set-face-attribute 'show-paren-match-face nil :weight 'extra-bold))
      
      (add-hook 'lisp-mode-hook 'lispy-parens)
      (add-hook 'emacs-lisp-mode-hook 'lispy-parens)
      (add-hook 'lisp-mode-hook 'abbrev-mode)
      (add-hook 'emacs-lisp-mode-hook 'abbrev-mode)
      (add-hook 'clojure-mode-hook 'abbrev-mode)
      (add-hook 'scheme-mode-hook 'abbrev-mode)
      (add-hook 'clojure-mode-hook 'lispy-parens)
      (add-hook 'scheme-mode-hook 'lispy-parens)
    #+end_src

*** Clojure

    #+begin_src emacs-lisp 
      (cond 
       (na-os-is-darwin
        (setq clojure-command (concat "/Users/nakkaya/Dropbox/bash/lein repl")))
       (na-os-is-linux
        (setq clojure-command (concat "/home/nakkaya/Dropbox/bash/lein repl")))
       (na-os-is-windows
        (setq clojure-command (concat "/cygdrive/c/Dropbox/bash/lein repl"))))
      
      (setq lisp-programs 
            (list (list "clojure" clojure-command)
                  (list "sbcl" "/opt/local/bin/sbcl")
                  (list "gambit" "/opt/local/bin/gambit-gsc")))
      
      (defun na-run-lisp (arg)
        (interactive "P")
        (if (null arg)
            (run-lisp (second (first lisp-programs)))
          (let (choice) 
            (setq choice (completing-read "Lisp: " (mapcar 'first lisp-programs)))
            (dolist (l lisp-programs)
              (if (string= (first l) choice)
                  (run-lisp (second l)))))))
      
      (defun remote-repl (arg)
        (interactive "P")
        (run-lisp (concat "nc " (read-string "IP: ") " " (read-string "Port: "))))
      
      (defun na-load-buffer ()
        (interactive)
        (point-to-register 5)
        (mark-whole-buffer)
        (lisp-eval-region (point) (mark) nil)
        (jump-to-register 5))
      
      ;;sub process support for clojure
      (add-hook 'clojure-mode-hook
                '(lambda ()
                   (define-key clojure-mode-map 
                     "\e\C-x" 'lisp-eval-defun)
                   (define-key clojure-mode-map 
                     "\C-x\C-e" 'lisp-eval-last-sexp)
                   (define-key clojure-mode-map 
                     "\C-c\C-e" 'lisp-eval-last-sexp)
                   (define-key clojure-mode-map 
                     "\C-c\C-r" 'lisp-eval-region)
                   (define-key clojure-mode-map 
                     "\C-c\C-l" 'na-load-buffer)
                   (define-key clojure-mode-map 
                     "\C-c\C-z" 'run-lisp)))
      
      (define-clojure-indent (from-blackboard 'defun))
    #+end_src

    #+begin_src emacs-lisp
      (add-to-list 'org-babel-tangle-lang-exts '("clojure" . "clj"))
      
      (defvar org-babel-default-header-args:clojure 
        '((:results . "silent")))
      
      (defun org-babel-execute:clojure (body params)
        "Execute a block of Clojure code with Babel."
        (lisp-eval-string body)
        "Done!")
      
      (provide 'ob-clojure)
    #+end_src

    #+begin_src emacs-lisp
      (let ((fn `(("(\\(fn\\)[\[[:space:]]"
                   (0 (progn (compose-region (match-beginning 1)
                                             (match-end 1) "λ")
                             nil)))))
            (inline-fn `(("\\(#\\)("
                          (0 (progn (compose-region (match-beginning 1)
                                                    (match-end 1) "ƒ")
                                    nil))))))
            
            (font-lock-add-keywords 'clojure-mode fn)
            (font-lock-add-keywords 'clojure-mode inline-fn)
            (font-lock-add-keywords 'org-mode fn)
            (font-lock-add-keywords 'org-mode inline-fn))
    #+end_src

*** Scheme

    #+begin_src emacs-lisp
      (add-hook 'scheme-mode-hook
                '(lambda ()
                   (define-key scheme-mode-map 
                     "\e\C-x" 'lisp-eval-defun)
                   (define-key scheme-mode-map 
                     "\C-x\C-e" 'lisp-eval-last-sexp)
                   (define-key scheme-mode-map 
                     "\C-c\C-e" 'lisp-eval-last-sexp)
                   (define-key scheme-mode-map 
                     "\C-c\C-r" 'lisp-eval-region)
                   (define-key scheme-mode-map 
                     "\C-c\C-l" 'na-load-buffer)
                   (define-key scheme-mode-map 
                     "\C-c\C-z" 'run-lisp)))
    #+end_src

** Git

   #+begin_src emacs-lisp 
     (require 'git)
     (require 'gitsum)
     (setq git-committer-name "Nurullah Akkaya")
     (setq git-committer-email "nurullah@nakkaya.com")
     
     (when (equal system-type 'darwin)
       (setenv "PATH" (concat "/opt/local/bin:/usr/local/bin:" (getenv "PATH")))
       (push "/opt/local/bin" exec-path))
     (setq exec-path (append exec-path '("/opt/local/bin")))
     
     (defun na-run-git-switch ()
       "Switch to git buffer or run git-status"
       (interactive)  
       (window-configuration-to-register 'z)
       (if (not (eq (get-buffer "*git-status*") nil))
           (switch-to-buffer "*git-status*")
         (git-status (read-directory-name "Select Directory: "))))
     
     (define-key git-status-mode-map (kbd "Q")
       '(lambda ()
          (interactive)
          (jump-to-register 'z)))
     
     (define-key git-status-mode-map (kbd "K")
       '(lambda ()
          (interactive)
          (kill-buffer)
          (jump-to-register 'z)))
   #+end_src

** multi-term

   #+begin_src emacs-lisp
     ;;; multi-term.el --- Managing multiple terminal buffers in Emacs.
     
     ;; Author: Andy Stewart <lazycat.manatee@gmail.com>
     ;; Maintainer: ahei <ahei0802@gmail.com>
     ;; Copyright (C) 2008, 2009, Andy Stewart, all rights reserved.
     ;; Copyright (C) 2010, ahei, all rights reserved.
     ;; Created: <2008-09-19 23:02:42>
     ;; Version: 0.8.8
     ;; Last-Updated: <2010-05-13 00:40:24 Thursday by ahei>
     ;; URL: http://www.emacswiki.org/emacs/download/multi-term.el
     ;; Keywords: term, terminal, multiple buffer
     ;; Compatibility: GNU Emacs 23.2.1
     
     ;; This program is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 3, or (at your option)
     ;; any later version.
     
     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.
     
     ;; You should have received a copy of the GNU General Public License
     ;; along with this program; see the file COPYING.  If not, write to
     ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
     ;; Floor, Boston, MA 02110-1301, USA.
     
     ;; Features that might be required by this library:
     ;;
     ;;  `term' `cl' `advice'
     ;;
     
     ;;; Commentary:
     ;;
     ;; This package is for creating and managing multiple terminal buffers in Emacs.
     ;;
     ;; By default, term.el provides a great terminal emulator in Emacs.
     ;; But I have some troubles with term-mode:
     ;;
     ;; 1. term.el just provides commands `term' or `ansi-term'
     ;;    for creating a terminal buffer.
     ;;    And there is no special command to create or switch
     ;;    between multiple terminal buffers quickly.
     ;;
     ;; 2. By default, the keystrokes of term.el conflict with global-mode keystrokes,
     ;;    which makes it difficult for the user to integrate term.el with Emacs.
     ;;
     ;; 3. By default, executing *NIX command “exit” from term-mode,
     ;;    it will leave an unused buffer.
     ;;
     ;; 4. term.el won’t quit running sub-process when you kill terminal buffer forcibly.
     ;;
     ;; 5. Haven’t a dedicated window for debug program.
     ;;
     ;; And multi-term.el is enhanced with those features.
     ;;
     
     ;;; Installation:
     ;;
     ;; Copy multi-term.el to your load-path and add to your ~/.emacs
     ;;
     ;;  (require 'multi-term)
     ;;
     ;; And setup program that `multi-term' will need:
     ;;
     ;; (setq multi-term-program "/bin/bash")
     ;;
     ;;      or setup like me "/bin/zsh" ;)
     ;;
     ;; Below are the commands you can use:
     ;;
     ;;      `multi-term'                    Create a new term buffer.
     ;;      `multi-term-next'               Switch to next term buffer.
     ;;      `multi-term-prev'               Switch to previous term buffer.
     ;;      `multi-term-dedicated-open'     Open dedicated term window.
     ;;      `multi-term-dedicated-close'    Close dedicated term window.
     ;;      `multi-term-dedicated-toggle'   Toggle dedicated term window.
     ;;      `multi-term-dedicated-select'   Select dedicated term window.
     ;;
     ;; Tips:
     ;;
     ;;      You can type `C-u' before command `multi-term' or `multi-term-dedicated-open'
     ;;      then will prompt you shell name for creating terminal buffer.
     ;;
     
     ;;; Customize:
     ;;
     ;; `multi-term-program' default is nil, so when creating new term buffer,
     ;; send environment variable of `SHELL' (`ESHELL', `/bin/sh') to `make-term'.
     ;;
     ;; And you can set it to your liking, like me: ;-)
     ;;
     ;; (setq multi-term-program "/bin/zsh")
     ;;
     ;; `multi-term-default-dir' default is `~/', only use when current buffer
     ;; is not in a real directory.
     ;;
     ;; `multi-term-buffer-name' is the name of term buffer.
     ;;
     ;; `multi-term-scroll-show-maximum-output' controls how interpreter
     ;; output causes window to scroll.
     ;;
     ;; `multi-term-scroll-to-bottom-on-output' controls whether interpreter
     ;; output causes window to scroll.
     ;;
     ;; `multi-term-switch-after-close' try to switch other `multi-term' buffer
     ;; after close current one.
     ;; If you don't like this feature just set it with nil.
     ;;
     ;; `term-unbind-key-list' is a key list to unbind some keystroke.
     ;;
     ;; `term-bind-key-alist' is a key alist that binds some keystroke.
     ;; If you don't like default, modify it.
     ;;
     ;; `multi-term-dedicated-window-height' the height of a dedicated term window.
     ;;
     ;; `multi-term-dedicated-max-window-height' the max height limit that dedicated
     ;; window is allowed.
     ;;
     ;; `multi-term-dedicated-skip-other-window-p' whether skip dedicated term
     ;; window when use command `other-window' to cycle windows order.
     ;;
     ;; All of the above can be customize by:
     ;;      M-x customize-group RET multi-term RET
     ;;
     
     ;;; Change log:
     ;;
     ;; 2009/07/04
     ;;      * Add new option `multi-term-dedicated-select-after-open-p'.
     ;;
     ;; 2009/06/29
     ;;      * Fix regexp bug.
     ;;
     ;; 2009/04/21
     ;;      * Fix a bug that bring at `2009/03/28':
     ;;        It will kill sub-process in other multi-term buffer
     ;;        when we kill current multi-term buffer.
     ;;
     ;; 2009/03/29
     ;;      * Add new command `term-send-reverse-search-history'.
     ;;
     ;; 2009/03/28
     ;;      * Add new option `multi-term-switch-after-close'.
     ;;
     ;; 2009/02/18
     ;;      * Fix bug between ECB and `multi-term-dedicated-close'.
     ;;
     ;; 2009/02/05
     ;;      * Prompt user shell name when type `C-u' before command
     ;;        `multi-term' or `multi-term-dedicated-open'.
     ;;      * Fix doc.
     ;;
     ;; 2009/01/29
     ;;      * Use `term-quit-subjob' instead `term-interrupt-subjob'.
     ;;      * Fix doc.
     ;;
     ;; 2009/01/13
     ;;      * Rewrite advice for `pop-to-buffer' to avoid `pop-to-buffer' not effect
     ;;        when have many dedicated window in current frame.
     ;;      * Rewrite advice for `delete-other-windows' to avoid use common variable
     ;;        `delete-protected-window-list' and use `window-dedicated-p' instead.
     ;;        Remove variable `delete-protected-window-list' and function
     ;;        `multi-term-dedicated-match-protected-window-p'.
     ;;
     ;; 2009/01/06
     ;;      * Improve document.
     ;;
     ;; 2008/12/29
     ;;      * Remove option `multi-term-current-window-height' and
     ;;        function `multi-term-current-directory'.
     ;;      * Add some functions to make get dedicated term buffer,
     ;;        those functions is beginning with `multi-term-dedicated-'.
     ;;      * Modified advice `delete-window', make command `delete-window'
     ;;        and delete dedicated window, but will remember window height
     ;;        before deleted.
     ;;      * Don't remember dedicated window height if larger than max value.
     ;;      * Fix some bug with `delete-other-windows' and window configuration.
     ;;        And this bug exists with another extension `sr-speedbar'.
     ;;      * Add new variable `delete-protected-window-list' for protected
     ;;        special window that won't be deleted.
     ;;        This variable is common for any extension that use dedicated
     ;;        window.
     ;;      * Fix doc.
     ;;
     ;; 2008/12/21
     ;;      * Default bind `C-m' with `term-send-input'.
     ;;
     ;; 2008/12/10
     ;;      * Improve customize interface.
     ;;      * Setup customize automatically, don't need to user setup it up.
     ;;      * Add option `multi-term-try-create'.
     ;;      * Make function `multi-term-switch' accept offset argument.
     ;;      * Fix doc.
     ;;
     ;; 2008/10/22
     ;;      * Add variable `multi-term-current-window-height'.
     ;;      * Add variable `multi-term-buffer-name'.
     ;;      * Add variable `term-unbind-key-list'.
     ;;      * Add variable `term-rebind-key-alist'.
     ;;      * Move key setup and some extension from `term-extension.el'.
     ;;      * Create new function `multi-term-keystroke-setup'.
     ;;      * Fix doc.
     ;;
     ;; 2008/09/19
     ;;      * First released.
     ;;
     
     ;;; Acknowledgments:
     ;;
     ;;      Mark Triggs     <mst@dishevelled.net>
     ;;              For create multi-shell.el
     ;;      Aaron S. Hawley <aaron.s.hawley@gmail.com>
     ;;              For improve document.
     ;;
     
     ;;; Bug
     ;;
     ;;
     
     ;;; TODO
     ;;
     ;;
     ;;
     
     ;;; Require:
     (require 'term)
     (require 'cl)
     (require 'advice)
     
     ;;; Code:
     
     ;;; Customize
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Customize ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defgroup multi-term nil
       "Multi term manager."
       :group 'term)
     
     (defcustom multi-term-program nil
       "The program of term.
     If this is nil, setup to environment variable of `SHELL'."
       :type 'string
       :group 'multi-term)
     
     (defcustom multi-term-program-switches nil
       "The command-line switches to pass to the term program."
       :type 'string
       :group 'multi-term)
     
     (defcustom multi-term-try-create t
       "Try to create a new term buffer when switch.
     
     When use `multi-term-next' or `multi-term-prev', switch term buffer,
     and try to create a new term buffer if no term buffers exist."
       :type 'boolean
       :group 'multi-shell)
     
     (defcustom multi-term-default-dir "~/"
       "The default directory for terms if current directory doesn't exist."
       :type 'string
       :group 'multi-term)
     
     (defcustom multi-term-buffer-name "terminal"
       "The buffer name of term buffer."
       :type 'string
       :group 'multi-term)
     
     (defcustom multi-term-scroll-show-maximum-output nil
       "*Controls how interpreter output causes window to scroll.
     If non-nil, then show the maximum output when the window is scrolled.
     
     See variable `multi-term-scroll-to-bottom-on-output'."
       :type 'boolean
       :group 'multi-term)
     
     (defcustom multi-term-scroll-to-bottom-on-output nil
       "*Controls whether interpreter output causes window to scroll.
     If nil, then do not scroll.  If t or `all', scroll all windows showing buffer.
     If `this', scroll only the selected window.
     If `others', scroll only those that are not the selected window.
     
     The default is nil.
     
     See variable `multi-term-scroll-show-maximum-output'."
       :type 'boolean
       :group 'multi-term)
     
     (defcustom multi-term-switch-after-close 'NEXT
       "Try to switch other `multi-term' buffer after close current one.
     If this option is 'NEXT, switch to next `multi-term' buffer;
     If this option is 'PREVIOUS, switch to previous `multi-term' buffer.
     If this option is nil, don't switch other `multi-term' buffer."
       :type 'symbol
       :group 'multi-term)
     
     (defcustom term-unbind-key-list
       '("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
       "The key list that will need to be unbind."
       :type 'list
       :group 'multi-term)
     
     (defcustom term-bind-key-alist
       '(
         ("C-c C-c" . term-interrupt-subjob)
         ("C-p" . previous-line)
         ("C-n" . next-line)
         ("C-s" . isearch-forward)
         ("C-r" . isearch-backward)
         ("C-m" . term-send-raw)
         ("M-f" . term-send-forward-word)
         ("M-b" . term-send-backward-word)
         ("M-o" . term-send-backspace)
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)
         ("M-M" . term-send-forward-kill-word)
         ("M-N" . term-send-backward-kill-word)
         ("M-r" . term-send-reverse-search-history)
         ("M-," . term-send-input)
         ("M-." . comint-dynamic-complete))
       "The key alist that will need to be bind.
     If you do not like default setup, modify it, with (KEY . COMMAND) format."
       :type 'alist
       :group 'multi-term)
     
     (defcustom multi-term-dedicated-window-height 14
       "The height of `multi-term' dedicated window."
       :type 'integer
       :group 'multi-term)
     
     (defcustom multi-term-dedicated-max-window-height 30
       "The max height limit of `multi-term' dedicated window.
     Default, when hide `multi-term' dedicated window, will remember
     window height before hide, except height is larger than this.`"
       :type 'integer
       :group 'multi-term)
     
     (defcustom multi-term-dedicated-skip-other-window-p nil
       "Default, can have `other-window' select window in cyclic ordering of windows.
     In cases you don't want to select `multi-term' dedicated window, use `other-window'
     and make `multi-term' dedicated window as a viewable sidebar.
     
     So please turn on this option if you want to skip `multi-term' dedicated window with `other-window'.
     
     Default is nil."
       :type 'boolean
       :set (lambda (symbol value)
              (set symbol value)
              (when (ad-advised-definition-p 'other-window)
                (multi-term-dedicated-handle-other-window-advice value)))
       :group 'multi-term)
     
     (defcustom multi-term-dedicated-select-after-open-p nil
       "Default, multi-term won't focus terminal window after you open dedicated window.
     Please make this option with t if you want focus terminal window.
     
     Default is nil."
       :type 'boolean
       :group 'multi-term)
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Constant ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defconst multi-term-dedicated-buffer-name "MULTI-TERM-DEDICATED"
       "The buffer name of dedicated `multi-term'.")
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Variable ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defvar multi-term-dedicated-window nil
       "The dedicated `multi-term' window.")
     
     (defvar multi-term-dedicated-buffer nil
       "The dedicated `multi-term' buffer.")
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Interactive Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;;###autoload
     (defun multi-term ()
       "Create new term buffer.
     Will prompt you shell name when you type `C-u' before this command."
       (interactive)
       (let (term-buffer)
         ;; Set buffer.
         (setq term-buffer (multi-term-get-buffer current-prefix-arg))
         (set-buffer term-buffer)
         ;; Internal handle for `multi-term' buffer.
         (multi-term-internal)
         ;; Switch buffer
         (switch-to-buffer term-buffer)))
     
     (defun multi-term-next (&optional offset)
       "Go to the next term buffer.
     If OFFSET is `non-nil', will goto next term buffer with OFFSET."
       (interactive "P")
       (multi-term-switch 'NEXT (or offset 1)))
     
     (defun multi-term-prev (&optional offset)
       "Go to the previous term buffer.
     If OFFSET is `non-nil', will goto previous term buffer with OFFSET."
       (interactive "P")
       (multi-term-switch 'PREVIOUS (or offset 1)))
     
     (defun multi-term-dedicated-open ()
       "Open dedicated `multi-term' window.
     Will prompt you shell name when you type `C-u' before this command."
       (interactive)
       (if (not (multi-term-dedicated-exist-p))
           (let ((current-window (selected-window)))
             (if (multi-term-buffer-exist-p multi-term-dedicated-buffer)
                 (unless (multi-term-window-exist-p multi-term-dedicated-window)
                   (multi-term-dedicated-get-window))
               ;; Set buffer.
               (setq multi-term-dedicated-buffer (multi-term-get-buffer current-prefix-arg t))
               (set-buffer (multi-term-dedicated-get-buffer-name))
               ;; Get dedicate window.
               (multi-term-dedicated-get-window)
               ;; Whether skip `other-window'.
               (multi-term-dedicated-handle-other-window-advice multi-term-dedicated-skip-other-window-p)
               ;; Internal handle for `multi-term' buffer.
               (multi-term-internal))
             (set-window-buffer multi-term-dedicated-window (get-buffer (multi-term-dedicated-get-buffer-name)))
             (set-window-dedicated-p multi-term-dedicated-window t)
             ;; Select window.
             (select-window
              (if multi-term-dedicated-select-after-open-p
                  ;; Focus dedicated terminal window if option `multi-term-dedicated-select-after-open-p' is enable.
                  multi-term-dedicated-window
                ;; Otherwise focus current window.
                current-window)))
         (message "`multi-term' dedicated window has exist.")))
     
     (defun multi-term-dedicated-close ()
       "Close dedicated `multi-term' window."
       (interactive)
       (if (multi-term-dedicated-exist-p)
           (let ((current-window (selected-window)))
             ;; Remember height.
             (multi-term-dedicated-select)
             (multi-term-dedicated-remember-window-height)
             ;; Close window.
             (if (and (require 'ecb nil t)
                      ecb-activated-window-configuration)
                 ;; Toggle ECB window when ECB window activated.
                 (progn
                   (ecb-deactivate)
                   (ecb-activate))
               ;; Otherwise delete dedicated window.
               (delete-window multi-term-dedicated-window)
               (if (multi-term-window-exist-p current-window)
                   (select-window current-window))))
         (message "`multi-term' window is not exist.")))
     
     (defun multi-term-dedicated-remember-window-height ()
       "Remember window height."
       (let ((win-height (multi-term-current-window-take-height)))
         (if (and (multi-term-dedicated-window-p) ;in `multi-term' window
                  (> win-height 1)
                  (<= win-height multi-term-dedicated-max-window-height))
             (setq multi-term-dedicated-window-height win-height))))
     
     (defun multi-term-dedicated-toggle ()
       "Toggle dedicated `multi-term' window."
       (interactive)
       (if (multi-term-dedicated-exist-p)
           (multi-term-dedicated-close)
         (multi-term-dedicated-open)))
     
     (defun multi-term-dedicated-select ()
       "Select the `multi-term' dedicated window."
       (interactive)
       (if (multi-term-dedicated-exist-p)
           (select-window multi-term-dedicated-window)
         (message "`multi-term' window is not exist.")))
     
     (defun term-send-backward-kill-word ()
       "Backward kill word in term mode."
       (interactive)
       (term-send-raw-string "\C-w"))
     
     (defun term-send-forward-kill-word ()
       "Kill word in term mode."
       (interactive)
       (term-send-raw-string "\ed"))
     
     (defun term-send-backward-word ()
       "Move backward word in term mode."
       (interactive)
       (term-send-raw-string "\eb"))
     
     (defun term-send-forward-word ()
       "Move forward word in term mode."
       (interactive)
       (term-send-raw-string "\ef"))
     
     (defun term-send-reverse-search-history ()
       "Search history reverse."
       (interactive)
       (term-send-raw-string "\C-r"))
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilise Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defun multi-term-internal ()
       "Internal handle for `multi-term' buffer."
       ;; Add customize keystroke with `term-mode-hook'
       (remove-hook 'term-mode-hook 'multi-term-keystroke-setup)
       (add-hook 'term-mode-hook 'multi-term-keystroke-setup)
       ;; Load term mode
       (term-mode)
       (term-char-mode)
       ;; Handle term buffer close
       (multi-term-handle-close)
       ;; Handle `output' variable.
       (setq term-scroll-show-maximum-output multi-term-scroll-show-maximum-output
             term-scroll-to-bottom-on-output multi-term-scroll-to-bottom-on-output)
       ;; Add hook to be sure `term' quit subjob before buffer killed.
       (add-hook 'kill-buffer-hook 'multi-term-kill-buffer-hook))
     
     (defun multi-term-get-buffer (&optional special-shell dedicated-window)
       "Get term buffer.
     If option SPECIAL-SHELL is `non-nil', will use shell from user input.
     If option DEDICATED-WINDOW is `non-nil' will create dedicated `multi-term' window ."
       (with-temp-buffer
         (let ((shell-name (or multi-term-program ;shell name
                               (getenv "SHELL")
                               (getenv "ESHELL")
                               "/bin/sh"))
               term-list-length              ;get length of term list
               index                         ;setup new term index
               term-name)                    ;term name
           (if dedicated-window
               (setq term-name multi-term-dedicated-buffer-name)
             ;; Compute index.
             (setq term-list-length (length (multi-term-list)))
             (setq index (if term-list-length (1+ term-list-length) 1))
             ;; switch to current local directory,
             ;; if in-existence, switch to `multi-term-default-dir'.
             (cd (or default-directory (expand-file-name multi-term-default-dir)))
             ;; adjust value N when max index of term buffer is less than length of term list
             (while (buffer-live-p (get-buffer (format "*%s<%s>*" multi-term-buffer-name index)))
               (setq index (1+ index)))
             (setq term-name (format "%s<%s>" multi-term-buffer-name index)))
           ;; Try get other shell name if `special-shell' is non-nil.
           (if special-shell
               (setq shell-name (read-from-minibuffer "Run program: " shell-name)))
           ;; Make term, details to see function `make-term' in `term.el'.
           (if multi-term-program-switches
               (make-term term-name shell-name nil multi-term-program-switches)
             (make-term term-name shell-name)))))
     
     
     (defun multi-term-handle-close ()
       "Close current term buffer when `exit' from term buffer."
       (when (ignore-errors (get-buffer-process (current-buffer)))
         (set-process-sentinel (get-buffer-process (current-buffer))
                               (lambda (proc change)
                                 (when (string-match "\\(finished\\|exited\\)" change)
                                   (kill-buffer (process-buffer proc)))))))
     
     (defun multi-term-kill-buffer-hook ()
       "Function that hook `kill-buffer-hook'."
       (when (eq major-mode 'term-mode)
         ;; Quit the current subjob
         ;; when have alive process with current term buffer.
         ;; Must do this job BEFORE `multi-term-switch-after-close' action.
         (when (term-check-proc (current-buffer))
           ;; Quit sub-process.
           (term-quit-subjob))
         ;; Remember dedicated window height.
         (multi-term-dedicated-remember-window-height)
         ;; Try to switch other multi-term buffer
         ;; when option `multi-term-switch-after-close' is non-nil.
         (when multi-term-switch-after-close
           (multi-term-switch-internal multi-term-switch-after-close 1))))
     
     (defun multi-term-list ()
       "List term buffers presently active."
       ;; Autload command `remove-if-not'.
       (autoload 'remove-if-not "cl-seq")
       (sort
        (remove-if-not (lambda (b)
                         (setq case-fold-search t)
                         (string-match
                          (format "^\\\*%s<[0-9]+>\\\*$" multi-term-buffer-name)
                          (buffer-name b)))
                       (buffer-list))
        (lambda (a b)
          (< (string-to-number
              (cadr (split-string (buffer-name a) "[<>]")))
             (string-to-number
              (cadr (split-string (buffer-name b)  "[<>]")))))))
     
     (defun multi-term-switch (direction offset)
       "Switch `multi-term' buffers.
     If DIRECTION is `NEXT', switch to the next term.
     If DIRECTION `PREVIOUS', switch to the previous term.
     Option OFFSET for skip OFFSET number term buffer."
       (unless (multi-term-switch-internal direction offset)
         (if multi-term-try-create
             (progn
               (multi-term)
               (message "Create a new `multi-term' buffer."))
           (message "Haven't any `multi-term' buffer exist."))))
     
     (defun multi-term-switch-internal (direction offset)
       "Internal `multi-term' buffers switch function.
     If DIRECTION is `NEXT', switch to the next term.
     If DIRECTION `PREVIOUS', switch to the previous term.
     Option OFFSET for skip OFFSET number term buffer."
       (let (terms this-buffer)
         (setq terms (multi-term-list))
         (if (consp terms)
             (progn
               (setf (cdr (last terms)) terms)
               (setq this-buffer (position (current-buffer) (multi-term-list)))
               (if this-buffer
                   (if (eql direction 'NEXT)
                       (switch-to-buffer (nth (+ this-buffer offset) terms))
                     (switch-to-buffer (nth (+ (- (length (multi-term-list)) offset)
                                               this-buffer) terms)))
                 (switch-to-buffer (car terms)))
               t)
           nil)))
     
     (defun multi-term-keystroke-setup ()
       "Keystroke setup of `term-char-mode'.
     
     By default, the key bindings of `term-char-mode' conflict with user's keystroke.
     So this function unbinds some keys with `term-raw-map',
     and binds some keystroke with `term-raw-map'."
       (let (bind-key bind-command)
         ;; Unbind base key that conflict with user's keys-tokes.
         (dolist (unbind-key term-unbind-key-list)
           (cond
            ((stringp unbind-key) (setq unbind-key (read-kbd-macro unbind-key)))
            ((vectorp unbind-key) nil)
            (t (signal 'wrong-type-argument (list 'array unbind-key))))
           (define-key term-raw-map unbind-key nil))
         ;; Add some i use keys.
         ;; If you don't like my keystroke,
         ;; just modified `term-bind-key-alist'
         (dolist (element term-bind-key-alist)
           (setq bind-key (car element))
           (setq bind-command (cdr element))
           (cond
            ((stringp bind-key) (setq bind-key (read-kbd-macro bind-key)))
            ((vectorp bind-key) nil)
            (t (signal 'wrong-type-argument (list 'array bind-key))))
           (define-key term-raw-map bind-key bind-command))))
     
     (defun multi-term-dedicated-handle-other-window-advice (activate)
       "Handle advice for function `other-window'.
     If ACTIVATE is `non-nil', will enable advice
     `multi-term-dedicated-other-window-advice'.
     Otherwise, disable it."
       (if activate
           (ad-enable-advice 'other-window 'after 'multi-term-dedicated-other-window-advice)
         (ad-disable-advice 'other-window 'after 'multi-term-dedicated-other-window-advice))
       (ad-activate 'other-window))
     
     (defun multi-term-current-window-take-height (&optional window)
       "Return the height the `window' takes up.
     Not the value of `window-height', it returns usable rows available for WINDOW.
     If `window' is nil, get current window."
       (let ((edges (window-edges window)))
         (- (nth 3 edges) (nth 1 edges))))
     
     (defun multi-term-dedicated-get-window ()
       "Get `multi-term' dedicated window."
       (setq multi-term-dedicated-window
             (split-window
              (selected-window)
              (- (multi-term-current-window-take-height) multi-term-dedicated-window-height))))
     
     (defun multi-term-dedicated-get-buffer-name ()
       "Get the buffer name of `multi-term' dedicated window."
       (format "*%s*" multi-term-dedicated-buffer-name))
     
     (defun multi-term-dedicated-exist-p ()
       "Return `non-nil' if `multi-term' dedicated window exist."
       (and (multi-term-buffer-exist-p multi-term-dedicated-buffer)
            (multi-term-window-exist-p multi-term-dedicated-window)))
     
     (defun multi-term-window-exist-p (window)
       "Return `non-nil' if WINDOW exist.
     Otherwise return nil."
       (and window (window-live-p window)))
     
     (defun multi-term-buffer-exist-p (buffer)
       "Return `non-nil' if `BUFFER' exist.
     Otherwise return nil."
       (and buffer (buffer-live-p buffer)))
     
     (defun multi-term-dedicated-window-p ()
       "Return `non-nil' if current window is `multi-term' dedicated window.
     Otherwise return nil."
       (equal (multi-term-dedicated-get-buffer-name) (buffer-name (window-buffer))))
     
     (defun multi-term-window-dedicated-only-one-p ()
       "Only have one non-dedicated window."
       (interactive)
       (let ((window-number 0)
             (dedicated-window-number 0))
         (walk-windows
          (lambda (w)
            (with-selected-window w
              (incf window-number)
              (if (window-dedicated-p w)
                  (incf dedicated-window-number)))))
         (if (and (> dedicated-window-number 0)
                  (= (- window-number dedicated-window-number) 1))
             t nil)))
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Advice ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defadvice delete-other-windows (around multi-term-delete-other-window-advice activate)
       "This is advice to make `multi-term' avoid dedicated window deleted.
     Dedicated window can't deleted by command `delete-other-windows'."
       (let ((multi-term-dedicated-active-p (multi-term-window-exist-p multi-term-dedicated-window)))
         (if multi-term-dedicated-active-p
             (let ((current-window (selected-window)))
               (dolist (win (window-list))
                 (when (and (window-live-p win)
                            (not (eq current-window win))
                            (not (window-dedicated-p win)))
                   (delete-window win))))
           ad-do-it)))
     
     (defadvice delete-window (before multi-term-delete-window-advice activate)
       "Use `delete-window' delete `multi-term' dedicated window.
     Have same effect as command `multi-term-dedicated-close'.
     This advice to remember `multi-term' dedicated window height before deleting."
       ;; Remember window height before deleted.
       (multi-term-dedicated-remember-window-height))
     
     (defadvice pop-to-buffer (before multi-term-pop-to-buffer-advice activate)
       "This advice fix the problem between `pop-to-buffer' and dedicated window.
     By default, function `display-buffer' can't display buffer in selected window
     if current window is `dedicated'.
     
     So function `display-buffer' conflicts with `sr-speedbar' window, because
     `sr-speedbar' window is a `dedicated' window.
     
     That is to say, when current frame just have one `non-dedicated' window,
     any functions that uses `display-buffer' can't split windows
     to display buffer, even when the option `pop-up-windows' is enabled.
     
     And the example function that can induce the problem is `pop-to-buffer'.
     
     This advice will fix this problem when current frame just have one `non-dedicated' window."
       (when (and pop-up-windows                           ;`pop-up-windows' is enable
                  (multi-term-window-dedicated-only-one-p) ;just have one `non-dedicated' window.
                  (multi-term-window-exist-p multi-term-dedicated-window)
                  (not (multi-term-dedicated-window-p))) ;not in `sr-speedbar' window
         (split-window-vertically)
         (windmove-down)))
     
     (defadvice other-window (after multi-term-dedicated-other-window-advice)
       "Default, can use `other-window' select window in cyclic ordering of windows.
     But sometimes we don't want to select `sr-speedbar' window,
     but use `other-window' and just make `multi-term' dedicated
     window as a viewable sidebar.
     
     This advice can make `other-window' skip `multi-term' dedicated window."
       (let ((count (or (ad-get-arg 0) 1)))
         (when (and (multi-term-window-exist-p multi-term-dedicated-window)
                    (eq multi-term-dedicated-window (selected-window)))
           (other-window count))))
     
     (provide 'multi-term)
     
     ;; Local Variables:
     ;; time-stamp-line-limit: 10
     ;; time-stamp-start: "Last-Updated: <"
     ;; time-stamp-end: ">"
     ;; End:
     
     ;;; multi-term.el ends here
     
     ;;; LocalWords:  multi el dir sr Hawley eb ef cd 
   #+end_src

   #+begin_src emacs-lisp
     (setq multi-term-program "/bin/bash")
     
     (global-set-key (kbd "C-c t") 'multi-term-next)
     (global-set-key (kbd "C-c T") 'multi-term) ;; create a new one
   #+end_src

* Skeletons
** Setup

   #+begin_src emacs-lisp 
     (setq skeleton-pair t)
     (global-set-key (kbd "(") 'skeleton-pair-insert-maybe)
     (global-set-key (kbd "[") 'skeleton-pair-insert-maybe)
     (global-set-key (kbd "{") 'skeleton-pair-insert-maybe)
     (global-set-key (kbd "\"") 'skeleton-pair-insert-maybe)
     (setq abbrev-mode t)
     
     (add-hook 'clojure-mode-hook 
               (lambda ()
                 (setq local-abbrev-table clojure-mode-abbrev-table)))
     
     (define-abbrev-table 'java-mode-abbrev-table '())
     (define-abbrev-table 'emacs-lisp-mode-abbrev-table '())
     (define-abbrev-table 'clojure-mode-abbrev-table '())
     (define-abbrev-table 'scheme-mode-abbrev-table '())
     (define-abbrev-table 'c++-mode-abbrev-table '())
     
   #+end_src

** Clojure

   #+begin_src emacs-lisp 
     (define-skeleton skel-clojure-println
       ""
       nil
       "(println "_")")
     (define-abbrev clojure-mode-abbrev-table "prt" "" 'skel-clojure-println)
     
     (define-skeleton skel-clojure-defn
       ""
       nil
       "(defn "_" [])")
     (define-abbrev clojure-mode-abbrev-table "defn" "" 'skel-clojure-defn)
     
     (define-skeleton skel-clojure-defn-
       ""
       nil
       "(defn- "_" [])")
     (define-abbrev clojure-mode-abbrev-table "def-" "" 'skel-clojure-defn- )
     
     (define-skeleton skel-clojure-if
       ""
       nil
       "(if ("_"))")
     (define-abbrev clojure-mode-abbrev-table "if" "" 'skel-clojure-if )
     
     (define-skeleton skel-clojure-let
       ""
       nil
       "(let ["_"] )")
     (define-abbrev clojure-mode-abbrev-table "let" "" 'skel-clojure-let)
     
     (define-skeleton skel-clojure-ref-set
       ""
       nil
       "(dosync (ref-set "_" ))")
     (define-abbrev clojure-mode-abbrev-table "refs" "" 'skel-clojure-ref-set)
     
     (define-skeleton skel-clojure-proxy
       ""
       nil
       "(proxy ["_"] [] "
       \n > ")")
     (define-abbrev clojure-mode-abbrev-table "proxy" "" 'skel-clojure-proxy)
     
     (define-skeleton skel-clojure-doseq
       ""
       nil
       "(doseq ["_"] "
       \n > ")")
     (define-abbrev clojure-mode-abbrev-table "doseq" "" 'skel-clojure-doseq)
     
     (define-skeleton skel-clojure-do
       ""
       nil
       "(do "_" "
       \n > ")")
     (define-abbrev clojure-mode-abbrev-table "do" "" 'skel-clojure-do)
     
     (define-skeleton skel-clojure-reduce
       ""
       nil
       "(reduce (fn[h v] ) "_" ) ")
     
     (define-abbrev clojure-mode-abbrev-table "reduce" "" 'skel-clojure-reduce)
     
     (define-skeleton skel-clojure-try
       ""
       nil
       "(try "_" (catch Exception e (println e)))")
     
     (define-abbrev clojure-mode-abbrev-table "try" "" 'skel-clojure-try)
     
     (define-skeleton skel-clojure-map
       ""
       nil
       "(map #() "_")")
     
     (define-abbrev clojure-mode-abbrev-table "map" "" 'skel-clojure-map)
     
   #+end_src

** Scheme

   #+begin_src emacs-lisp 
     (define-skeleton skel-scheme-display
       ""
       nil
       "(display "_")")
     (define-abbrev scheme-mode-abbrev-table "prt" "" 'skel-scheme-display)
     
     (define-skeleton skel-scheme-defn
       ""
       nil
       "(define ("_"))")
     (define-abbrev scheme-mode-abbrev-table "defn" "" 'skel-scheme-defn)
     
     (define-skeleton skel-scheme-if
       ""
       nil
       "(if ("_"))")
     (define-abbrev scheme-mode-abbrev-table "if" "" 'skel-scheme-if )
     
     (define-skeleton skel-scheme-let
       ""
       nil
       "(let ("_"))")
     (define-abbrev scheme-mode-abbrev-table "let" "" 'skel-scheme-let)
     
     (define-skeleton skel-scheme-for-each
       ""
       nil
       "(for-each (lambda ("_") ()))")
     (define-abbrev scheme-mode-abbrev-table "fore" "" 'skel-scheme-for-each)
     
     (define-skeleton skel-scheme-begin
       ""
       nil
       "(begin "_" "
       \n > ")")
     (define-abbrev scheme-mode-abbrev-table "begin" "" 'skel-scheme-do)
     
     (define-skeleton skel-scheme-reduce
       ""
       nil
       "(fold-right (lambda ("_") ()))")
     (define-abbrev scheme-mode-abbrev-table "reduce" "" 'skel-scheme-reduce)
     
     (define-skeleton skel-scheme-map
       ""
       nil
       "(map (lambda ("_") ()))")
     (define-abbrev scheme-mode-abbrev-table "map" "" 'skel-scheme-map)
     
   #+end_src

** Cpp

   #+begin_src emacs-lisp 
     (define-skeleton skel-cpp-prt
       ""
       nil
       \n >
       "cout<< " _ " <<endl;"
       \n >)
     (define-abbrev c++-mode-abbrev-table "cout"  "" 'skel-cpp-prt )
     
   #+end_src

** ELisp

   #+begin_src emacs-lisp 
     (define-skeleton skel-list-insert
       ""
       nil
       "(insert "_" )")
     (define-abbrev lisp-mode-abbrev-table "ins" "" 'skel-list-insert )
     
     (define-skeleton skel-list-setq
       ""
       nil
       "(setq "_" )")
     (define-abbrev lisp-mode-abbrev-table "set" "" 'skel-list-setq )
     
     (define-skeleton skel-list-deffun
       ""
       nil
       "(defun "_" () "
       \n >
       ")")
     (define-abbrev lisp-mode-abbrev-table "deff" "" 'skel-list-deffun )
     
     (define-skeleton skel-list-defvar
       ""
       nil
       "(defvar "_" )")
     (define-abbrev lisp-mode-abbrev-table "defv" "" 'skel-list-defvar )
     
     (define-skeleton skel-list-if
       ""
       nil
       "(if "
       _
       \n >
       " )")
     (define-abbrev lisp-mode-abbrev-table "if" "" 'skel-list-if )
     
     (define-skeleton skel-list-progn
       ""
       nil
       "(progn "
       _
       \n >
       " )")
     (define-abbrev lisp-mode-abbrev-table "progn" "" 'skel-list-progn )
     
   #+end_src

** Java

   #+begin_src emacs-lisp 
     (define-skeleton skel-java-println
       "Insert a Java println Statement"
       nil
       "System.out.println(" _ " );")
     (define-abbrev java-mode-abbrev-table "prt" "" 'skel-java-println )
     
     (define-skeleton skel-java-ife
       "Insert a Common If else Statement"
       nil
       \n >
       "if (" _ " ){"
       \n >
       "} else {"
       \n >
       "}")
     (define-abbrev java-mode-abbrev-table "ife" "" 'skel-java-ife )
     
     (define-skeleton skel-java-try
       "Insert a try catch block"
       nil
       \n >
       "try{"
       \n >
       _ \n
       "}catch( Exception e ) {" >
       " "
       \n > \n
       "}" >)
     (define-abbrev java-mode-abbrev-table "try" "" 'skel-java-try )
     
     (define-skeleton skel-java-if
       "Insert a Common If Statement"
       nil
       \n >
       "if (" _ " ){"
       \n >
       "}")
     
     (define-abbrev java-mode-abbrev-table "if" "" 'skel-java-if )
     (define-abbrev c++-mode-abbrev-table "if"  "" 'skel-java-if )
     
     (define-skeleton skel-java-for1
       "Insert a Common If Statement"
       nil
       \n >
       "for( int i=0 ; i<" _ " ;i++){"
       \n >
       "}")
     (define-abbrev java-mode-abbrev-table "for1" "" 'skel-java-for1 )
     
     
     (define-skeleton skel-java-timer
       "creates timing statements"
       nil
       \n >
       "final long start = System.currentTimeMillis();"
       \n >
       "System.out.println( Long.toString( System.currentTimeMillis() - start ) ) ;")
     (define-abbrev java-mode-abbrev-table "jtimer" "" 'skel-java-timer )
     
     (define-skeleton skel-java-comment
       "creates javadoc comment"
       nil
       \n >
       "/*"
       \n >
       "*"
       \n >
       "*"
       \n >
       "*"
       \n >
       "* @param"
       \n >
       "* @return"
       \n >
       "* @exception"
       \n >
       "*"
       \n >
       "*/"
       \n >)
     (define-abbrev java-mode-abbrev-table "jdcomment" "" 'skel-java-comment )
     
   #+end_src

** Org

   #+begin_src emacs-lisp
     (define-skeleton skel-org-src
       "Insert org src block."
       nil
       >
       "#+begin_src "
        _ 
       \n > 
        "#""+end_src"
        >)
     (define-abbrev text-mode-abbrev-table "osrc" "" 'skel-org-src)
     
     (define-skeleton skel-org-src
       "Insert org src block clojure."
       nil
       >
       "#+begin_src clojure"
       \n >
        _ 
       \n > 
        "#""+end_src"
        >)
     (define-abbrev text-mode-abbrev-table "ocsrc" "" 'skel-org-src)
   #+end_src
