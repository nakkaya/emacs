#+property: results silent

* Load Path
  #+begin_src emacs-lisp 
    (setq dotfiles-dir (file-name-directory
                        (or load-file-name (buffer-file-name))))
    
    (add-to-list 'load-path dotfiles-dir)
    (add-to-list 'load-path (concat dotfiles-dir "/ext/"))
    (add-to-list 'load-path (concat dotfiles-dir "/ext/clojure-mode/"))
    (add-to-list 'load-path (concat dotfiles-dir "/ext/gitsum/"))
    (add-to-list 'load-path (concat dotfiles-dir "/ext/org-mode/lisp/"))
  #+end_src

  #+begin_src emacs-lisp 
    (load "clojure-mode.el")
    (require 'diff-mode)  
    (require 'org)
  #+end_src

* General
** Options
   #+begin_src emacs-lisp 
     (setq large-file-warning-threshold 256000000 )
     ;;debug
     (setq debug-on-error t) 
     ;;enable blinking cursor
     (blink-cursor-mode 1)
     (put 'erase-buffer 'disabled nil)
     
     (when window-system
       ;;disable scroll bar
       (toggle-scroll-bar nil)
       (tool-bar-mode -1))
     
     (menu-bar-mode -1)
     ;;do not continue line when split frame
     (setq truncate-partial-width-windows nil)
     ;; turn on font-lock mode
     (global-font-lock-mode t)
     (when window-system
       ;; use extended compound-text coding for X clipboard
       (set-selection-coding-system 'compound-text-with-extensions))
     
     (setq bookmark-default-file "~/.emacs.d/emacs.bmk")
     (setq column-number-mode t)
     (setq dired-dwim-target t)
     (setq fill-column 72)
     (setq inhibit-startup-screen t)
     (setq next-line-add-newlines nil)
     (setq query-replace-highlight t)
     (setq search-highlight t)
     (setq transient-mark-mode t)

     ;; I hate tabs!
     (setq-default indent-tabs-mode nil)
     (setq delete-by-moving-to-trash t)
     
     ;disable backup
     (setq backup-inhibited t)
   #+end_src

   Detect OS,

   #+begin_src emacs-lisp 
     (defvar na-os-is-darwin nil)
     (defvar na-os-is-windows nil)
     (defvar na-os-is-linux nil)
     
     (cond
      ((string-match "GNU" (emacs-version))
       (cond 
        ((string-match "linux" system-configuration)  (setq na-os-is-linux t))
        ((string-match "nt" system-configuration)     (setq na-os-is-windows t))
        ((string-match "cygwin" system-configuration) (setq na-os-is-windows t))
        ((string-match "apple" system-configuration)  (setq na-os-is-darwin t)))))
   #+end_src

   Do not open a new frame for each file on OSX,

   #+begin_src emacs-lisp 
     (when na-os-is-darwin
       (setq ns-pop-up-frames nil))
   #+end_src

   Replace yes or no with y or n,

   #+begin_src emacs-lisp 
     (defun yes-or-no-p (arg)
       "An alias for y-or-n-p, because I hate having to type 'yes' or 'no'."
       (y-or-n-p arg))
   #+end_src

   Color on selection,

   #+begin_src emacs-lisp 
     (defface completion-setup-directory-face  '((t (:foreground "Blue")))
       "Face to use for directories."
       :group 'color-file-completion)
     
     (defcustom color-file-completion-always t "If true, always turn on regexps in
     completion buffers."
       :group 'color-file-completion
       :type 'boolean)
     
     (defun completion-setup-directory-face()
       "When we are completing a filename, highlight directories."
       (interactive)
       ;;if this is completing a filename... highlight faces...
       (when (or color-file-completion-always
                 (eq minibuffer-completion-table 'read-file-name-internal))
         (let((font-lock-verbose nil))
           (font-lock-mode 1)
           (font-lock-add-keywords nil '(("[^ \n]+/" 0 'completion-setup-directory-face keep)))
           (font-lock-fontify-buffer))))
     
     (add-hook 'completion-list-mode-hook 'completion-setup-directory-face)
   #+end_src

   Support Turkish alphabet,

   #+begin_src emacs-lisp 
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
   #+end_src

   Copy/Paste under Linux

   #+begin_src emacs-lisp 
     (when na-os-is-linux
       (setq x-select-enable-clipboard t))
   #+end_src

   #+begin_src emacs-lisp
     (defun na-fullscreen (&optional f)
       (interactive) 
       (if na-os-is-darwin
           ;; included in emacs 23.2 
           ;; FIXME: the ns version doesn't take the frame option 
           (ns-toggle-fullscreen) 
         (set-frame-parameter 
          f 'fullscreen 
          (if (frame-parameter f 'fullscreen) 
              nil 'fullboth))))
   #+end_src

** Input

   #+begin_src emacs-lisp 
     (defun scroll-window-forward-line ()
       "Move window forward one line leaving cursor at relative position in window."
       (interactive)
       (scroll-up 1))
     
     (defun scroll-window-backward-line ()
       "Move window backward one line leaving cursor at relative position in window."
       (interactive)
       (scroll-down 1)) 
     
     (define-key global-map [wheel-up] 'scroll-window-backward-line)
     (define-key global-map [wheel-down] 'scroll-window-forward-line)
   #+end_src

   Mouse setup when running in a terminal,

   #+begin_src emacs-lisp
     (unless window-system
       (xterm-mouse-mode t)
       (require 'mouse)
       (defun track-mouse (e)) 
       (setq mouse-sel-mode t)
     
       (define-key global-map [mouse-4] 'scroll-window-backward-line)
       (define-key global-map [mouse-5] 'scroll-window-forward-line))
   #+end_src

   Set up the keyboard so the delete key on both the regular keyboard
   and the keypad delete the character under the cursor and to the right
   under X, instead of the default, backspace behavior.

   #+begin_src emacs-lisp 
     (global-set-key [delete] 'delete-char)
     (global-set-key [kp-delete] 'delete-char)
   #+end_src

   Mac specific,

   #+begin_src emacs-lisp 
     (global-set-key [(meta h)] 'ns-do-hide-emacs)
     (setq mac-option-modifier 'super)
     (setq mac-command-modifier 'meta)
   #+end_src

   #+begin_src emacs-lisp 
     (global-set-key [f3] 'org-agenda)
     (global-set-key [f8] 'toggle-truncate-lines)
     (global-set-key [f12] 'org-babel-tangle)
     
     (global-set-key [(control d)] 'na-bounce-sexp)
     
     (define-key global-map [(control \])] 'ibuffer)
     (add-hook 'term-mode-hook
               '(lambda ()
                  (define-key term-raw-map [(control \])] 'ibuffer)))
     
     (define-key global-map [(meta p)] 'na-cm-rotate)
     (define-key global-map [(meta control  p)] 'na-cm-save-point)
     
     (add-hook 'term-mode-hook
               '(lambda ()
                  (define-key term-raw-map [(control \\)] 'other-window)))
     (global-set-key [(control \\)] 'other-window)
     
     (global-set-key "\C-xgs" 'na-run-git-switch)
     (global-set-key "\C-xrl" 'na-run-lisp)
     (global-set-key "\C-xtr" 'na-run-term)
     (global-set-key [(control q)] 'na-switch-between-terminals)
     (add-hook 'term-mode-hook
               '(lambda ()
                  (define-key term-raw-map [(control q)] 'na-switch-between-terminals)))
     
     
     (define-key global-map [home] 'beginning-of-line)
     (define-key global-map [end] 'end-of-line)
   #+end_src

** Session

   #+begin_src emacs-lisp 
     (load "desktop")
     (desktop-load-default)
     (setq desktop-enable t)
     (require 'saveplace)
     (setq-default save-place t)
     (setq bookmark-save-flag 1)
   #+end_src

   #+begin_src emacs-lisp 
     (add-hook 'server-visit-hook 'call-raise-frame)
     (add-hook 'find-file-hook 'call-raise-frame)
     
     (defun call-raise-frame ()
       (raise-frame))
   #+end_src

** Theme

  #+begin_src emacs-lisp 
    (setq frame-title-format (list "GNU Emacs " emacs-version))
    (setq display-time-day-and-date nil )
    (setq display-time-format "") 
    (setq display-time-load-average-threshold 0 )
    (setq display-time-string-forms '( load "," (if mail "" "")) )
    (setq display-time-interval 5)
    (display-time-mode 1)
    (setq battery-mode-line-format "%b%p%" )
    (display-battery-mode t)
    
    (setq-default mode-line-format
                  '(""
                    mode-line-modified
                    (-3 . "%p") ;; position
                    "[%b]"
                    "%[("
                    mode-name
                    mode-line-process
                    minor-mode-alist
                    "%n" ")%]-"
                    (line-number-mode "L%l-")
                    (column-number-mode "C%c [")
                    global-mode-string
                    "] "
                    "%f"                ;; print file with full path
                    " %-"))
  #+end_src

  #+begin_src emacs-lisp 
    (if window-system
        (progn 
          (set-face-foreground 'default "#bcbcbc")
          (set-face-background 'default "#121212")
          (set-face-foreground 'font-lock-string-face "#afafff")
          (set-face-foreground 'font-lock-keyword-face "#ff5f00")
          (set-face-foreground 'font-lock-function-name-face "#d7af00")
          (set-face-foreground 'font-lock-builtin-face "#afd700")
          (set-face-foreground 'font-lock-comment-face "#008787")
          (set-face-foreground 'org-block-begin-line "#303030")
          (set-face-foreground 'org-block-end-line "#303030")
          (set-face-foreground 'diff-added "#00ff00")
          (set-face-foreground 'diff-removed "#ff0000")
          (set-face-foreground 'diff-header "#005fff")
          (set-face-background 'diff-header "#121212")
          (set-face-background 'diff-file-header "#121212"))
      (progn 
        (set-face-foreground 'default "color-250")
        (set-face-background 'default "color-233")
        (set-face-foreground 'font-lock-string-face "color-147")
        (set-face-foreground 'font-lock-keyword-face "color-202")
        (set-face-foreground 'font-lock-function-name-face "color-178")
        (set-face-foreground 'font-lock-builtin-face "color-148")
        (set-face-foreground 'font-lock-comment-face "color-30")
        (set-face-foreground 'org-block-begin-line "color-236")
        (set-face-foreground 'org-block-end-line "color-236")
        (set-face-foreground 'diff-added "brightgreen")
        (set-face-foreground 'diff-removed "brightred")
        (set-face-foreground 'diff-header "color-27")
        (set-face-background 'diff-header "color-233")
        (set-face-background 'diff-file-header "color-233")))
  #+end_src

  #+begin_src emacs-lisp
    (when window-system
    
      (variable-pitch-mode -1)
    
      (when na-os-is-linux
        (set-face-attribute 'default nil 
                            :font "DejaVu Sans Mono-11:style=book"))
      (when na-os-is-darwin
        (set-face-attribute 'default nil 
                            :font "DejaVu Sans Mono-14:style=book")))
  #+end_src

* Modes
** Dired
   #+begin_src emacs-lisp 
     (require 'dired)
     
     (defun na-dired-up-directory-after-kill ()
       "Call 'dired-up-directory' after calling '(kill-buffer (current-buffer))'."
       (interactive)
       (let ((buf (current-buffer)))
         (dired-up-directory)
         (kill-buffer buf)))
     (define-key dired-mode-map "\C-w" 'na-dired-up-directory-after-kill)
   #+end_src

** Org

   #+begin_src emacs-lisp
     (add-hook 'org-mode-hook 'abbrev-mode)
     (setq org-directory "~/Dropbox/org/")
     (setq org-return-follows-link t)
     (setq org-hide-leading-stars t)
   #+end_src

*** agenda

    #+begin_src emacs-lisp
      (setq org-mobile-inbox-for-pull "~/Dropbox/org/from-mobile.org")
      (setq org-mobile-directory "~/Dropbox/mobile-org")
      (setq org-mobile-files (quote ("gtd.org")))
      (setq org-agenda-files (list "~/Dropbox/org/gtd.org"))
      
      (setq org-mobile-force-id-on-agenda-items nil)
      (setq org-agenda-custom-commands
            '(("h" "Agenda and Todo"
                    ((agenda "" ((org-agenda-ndays 3)))
                     (todo "TODO")
                     (todo "WAITING")
                     (todo "RESEARCH")))
              ("W" agenda "" ((org-agenda-ndays 21)
                              (org-agenda-show-all-dates nil)))))
      
      (setq org-agenda-window-setup 'other-window)
      (setq org-agenda-restore-windows-after-quit t)
      (setq org-agenda-show-all-dates t)
      
    #+end_src

    if idle for 5 minutes, display the current agenda.

    #+begin_src emacs-lisp
      (defun jump-to-org-agenda ()
        (interactive)
        (let ((agenda-window (get-buffer-window org-agenda-buffer-name t)))
          (if agenda-window
            (with-selected-window agenda-window (org-agenda-redo))
            (funcall (lambda () (org-agenda nil "h"))))))
      
      (run-with-idle-timer 300 t 'jump-to-org-agenda)
    #+end_src

*** latex

    #+begin_src emacs-lisp
      (require 'org-latex)
      (setq org-export-latex-listings t)
      
      
      (add-to-list 'org-export-latex-classes
                   '("literate-code"
                     "\\documentclass{article}\n
                       \\usepackage[x11names]{xcolor} % for a (setq of predefined color names, like LemonChiffon1
                       \\renewcommand{\\rmdefault}{phv} % Arial \n
                       \\renewcommand{\\sfdefault}{phv} % Arial
                       \\setlength{\\parindent}{0pt}
                       \\setlength{\\parskip}{1ex plus 0.5ex minus 0.2ex}
      
                       \\usepackage{tikz}
                       \\usetikzlibrary{backgrounds,shapes,arrows,positioning,calc,snakes,fit}
                       \\usepgflibrary{decorations.markings}
                       \\usepackage{mathtools}
      
                       \\usepackage[hmargin=3cm,vmargin=3.5cm]{geometry} \n
                       \\usepackage{hyperref}
                       \\hypersetup{
                           colorlinks,%
                           citecolor=black,%
                           filecolor=black,%
                           linkcolor=blue,%
                           urlcolor=black
                       }
                       \\RequirePackage[calcwidth]{titlesec}
                       \\RequirePackage{color}
                       
                       \\definecolor{seccol}{rgb}{0.1,0.5,1.0}
                         
                       \\titleformat{\\section}[hang]{\\sffamily\\bfseries}
                       {\\color{seccol}\\Huge\\thesection}{0pt}{\\linebreak\\huge\\raggedleft}[{\\titlerule[0.5pt]}]
        
                       \\titleformat{\\subsection}[hang]{\\sffamily\\bfseries\\underline}
                       {}{0pt}{\\linebreak\\Large}[]
        
                       \\titleformat{\\subsubsection}[hang]{\\sffamily\\bfseries\\underline}
                       {}{0pt}{\\linebreak\\large}[]
        
        
                       \\usepackage{listings}
                       
                       \\definecolor{lineno}{rgb}{0.5,0.5,0.5}
                       \\definecolor{code}{rgb}{0,0.1,0.6}
                       \\definecolor{keyword}{rgb}{0.5,0.1,0.1}
                       
                       \\lstset{
                           basicstyle=\\sffamily\\small\\color{code},
                           showspaces=false,
                           showstringspaces=false,
                           numbers=left,
                           firstnumber=1,
                           stepnumber=5,
                           numberfirstline=true,
                           numberstyle=\\color{lineno}\\sffamily\\scriptsize,
                           keywordstyle=\\color{keyword}\\bfseries,
                           stringstyle=\\itshape
                       }
                       
                       \\makeatletter
                       \\gdef\\lst@SkipOrPrintLabel{%
                           \\ifnum\\lst@skipnumbers=\\z@
                               \\global\\advance\\lst@skipnumbers-\\lst@stepnumber\\relax
                               \\lst@PlaceNumber
                               \\lst@numberfirstlinefalse
                           \\else
                               \\lst@ifnumberfirstline
                                   {\\def\\thelstnumber{Line \\@arabic\\c@lstnumber}\\lst@PlaceNumber}%
                                   \\lst@numberfirstlinefalse
                               \\else
                                   {\\def\\thelstnumber{-}\\lst@PlaceNumber}%
                               \\fi
                           \\fi
                           \\global\\advance\\lst@skipnumbers\\@ne}%
                       \\makeatother
                       
                       \\lstdefinelanguage{Lisp}%
                       {morekeywords={*,*1,*2,*3,*agent*,*allow-unresolved-vars*,*assert*,*clojure-version*,*command-line-args*,%
                       *compile-files*,*compile-path*,*e,*err*,*file*,*flush-on-newline*,*in*,*macro-meta*,%
                       *math-context*,*ns*,*out*,*print-dup*,*print-length*,*print-level*,*print-meta*,*print-readably*,%
                       *read-eval*,*source-path*,*use-context-classloader*,*warn-on-reflection*,+,-,->,->>,..,/,:else,%
                       <,<=,=,==,>,>=,@,accessor,aclone,add-classpath,add-watch,agent,agent-errors,aget,alength,alias,%
                       all-ns,alter,alter-meta!,alter-var-root,amap,ancestors,and,apply,areduce,array-map,aset,%
                       aset-boolean,aset-byte,aset-char,aset-double,aset-float,aset-int,aset-long,aset-short,assert,%
                       assoc,assoc!,assoc-in,associative?,atom,await,await-for,await1,bases,bean,bigdec,bigint,binding,%
                       bit-and,bit-and-not,bit-clear,bit-flip,bit-not,bit-or,bit-set,bit-shift-left,bit-shift-right,%
                       bit-test,bit-xor,boolean,boolean-array,booleans,bound-fn,bound-fn*,butlast,byte,byte-array,%
                       bytes,cast,char,char-array,char-escape-string,char-name-string,char?,chars,chunk,chunk-append,%
                       chunk-buffer,chunk-cons,chunk-first,chunk-next,chunk-rest,chunked-seq?,class,class?,%
                       clear-agent-errors,clojure-version,coll?,comment,commute,comp,comparator,compare,compare-and-set!,%
                       compile,complement,concat,cond,condp,conj,conj!,cons,constantly,construct-proxy,contains?,count,%
                       counted?,create-ns,create-struct,cycle,dec,decimal?,declare,def,definline,defmacro,defmethod,%
                       defmulti,defn,defn-,defonce,defprotocol,defstruct,deftype,delay,delay?,deliver,deref,derive,%
                       descendants,destructure,disj,disj!,dissoc,dissoc!,distinct,distinct?,do,do-template,doall,doc,%
                       dorun,doseq,dosync,dotimes,doto,double,double-array,doubles,drop,drop-last,drop-while,empty,empty?,%
                       ensure,enumeration-seq,eval,even?,every?,false,false?,ffirst,file-seq,filter,finally,find,find-doc,%
                       find-ns,find-var,first,float,float-array,float?,floats,flush,fn,fn?,fnext,for,force,format,future,%
                       future-call,future-cancel,future-cancelled?,future-done?,future?,gen-class,gen-interface,gensym,%
                       get,get-in,get-method,get-proxy-class,get-thread-bindings,get-validator,hash,hash-map,hash-set,%
                       identical?,identity,if,if-let,if-not,ifn?,import,in-ns,inc,init-proxy,instance?,int,int-array,%
                       integer?,interleave,intern,interpose,into,into-array,ints,io!,isa?,iterate,iterator-seq,juxt,%
                       key,keys,keyword,keyword?,last,lazy-cat,lazy-seq,let,letfn,line-seq,list,list*,list?,load,load-file,%
                       load-reader,load-string,loaded-libs,locking,long,long-array,longs,loop,macroexpand,macroexpand-1,%
                       make-array,make-hierarchy,map,map?,mapcat,max,max-key,memfn,memoize,merge,merge-with,meta,%
                       method-sig,methods,min,min-key,mod,monitor-enter,monitor-exit,name,namespace,neg?,new,newline,%
                       next,nfirst,nil,nil?,nnext,not,not-any?,not-empty,not-every?,not=,ns,ns-aliases,ns-imports,%
                       ns-interns,ns-map,ns-name,ns-publics,ns-refers,ns-resolve,ns-unalias,ns-unmap,nth,nthnext,num,%
                       number?,odd?,or,parents,partial,partition,pcalls,peek,persistent!,pmap,pop,pop!,pop-thread-bindings,%
                       pos?,pr,pr-str,prefer-method,prefers,primitives-classnames,print,print-ctor,print-doc,print-dup,%
                       print-method,print-namespace-doc,print-simple,print-special-doc,print-str,printf,println,println-str,%
                       prn,prn-str,promise,proxy,proxy-call-with-super,proxy-mappings,proxy-name,proxy-super,%
                       push-thread-bindings,pvalues,quot,rand,rand-int,range,ratio?,rational?,rationalize,re-find,%
                       re-groups,re-matcher,re-matches,re-pattern,re-seq,read,read-line,read-string,recur,reduce,ref,%
                       ref-history-count,ref-max-history,ref-min-history,ref-set,refer,refer-clojure,reify,%
                       release-pending-sends,rem,remove,remove-method,remove-ns,remove-watch,repeat,repeatedly,%
                       replace,replicate,require,reset!,reset-meta!,resolve,rest,resultset-seq,reverse,reversible?,%
                       rseq,rsubseq,second,select-keys,send,send-off,seq,seq?,seque,sequence,sequential?,set,set!,%
                       set-validator!,set?,short,short-array,shorts,shutdown-agents,slurp,some,sort,sort-by,sorted-map,%
                       sorted-map-by,sorted-set,sorted-set-by,sorted?,special-form-anchor,special-symbol?,split-at,%
                       split-with,str,stream?,string?,struct,struct-map,subs,subseq,subvec,supers,swap!,symbol,symbol?,%
                       sync,syntax-symbol-anchor,take,take-last,take-nth,take-while,test,the-ns,throw,time,to-array,%
                       to-array-2d,trampoline,transient,tree-seq,true,true?,try,type,unchecked-add,unchecked-dec,%
                       unchecked-divide,unchecked-inc,unchecked-multiply,unchecked-negate,unchecked-remainder,%
                       unchecked-subtract,underive,unquote,unquote-splicing,update-in,update-proxy,use,val,vals,%
                       var,var-get,var-set,var?,vary-meta,vec,vector,vector?,when,when-first,when-let,when-not,%
                       while,with-bindings,with-bindings*,with-in-str,with-loading-context,with-local-vars,%
                       with-meta,with-open,with-out-str,with-precision,xml-seq,zero?,zipmap
                       },%
                          sensitive,% ???
                          alsodigit=-,%
                          morecomment=[l];,%
                          morestring=[b]\"%
                         }[keywords,comments,strings]%"
                     
                     ("\\section{%s}" . "\\section*{%s}")
                     ("\\subsection{%s}" . "\\subsection*{%s}")
                     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                     ("\\paragraph{%s}" . "\\paragraph*{%s}")
                     ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
      
    #+end_src

*** html

    #+begin_src emacs-lisp
      (setq org-export-html-style
        "
      <style type=\"text/css\">
        @media all
        {
          body {
            font-family: \"Helvetica Neue\", \"Lucida Grande\", \"Lucida Sans Unicode\", Helvetica, Arial, sans-serif !important;
            font-size: 14px;
            line-height: 21px;
            color: #333;
            width: 850px;
        
            max-width: 95%;
            margin: auto;
            /* background-image: url(http://orgmode.org/worg-unicorn.png); */
            background-position: 25px 5px;
            background-repeat: no-repeat;
            }
            body #content {
              padding-top: 70px;
            }
            body .title {
              margin-left: 120px;
            }
        
          /* TOC inspired by http://jashkenas.github.com/coffee-script */
          #table-of-contents {
            font-size: 10pt;
            position: fixed;
            right: 0em;
            top: 0em;
            background: white;
            -webkit-box-shadow: 0 0 1em #777777;
            -moz-box-shadow: 0 0 1em #777777;
            -webkit-border-bottom-left-radius: 5px;
            -moz-border-radius-bottomleft: 5px;
            text-align: right;
            /* ensure doesn't flow off the screen when expanded */
            max-height: 80%;
            overflow: auto; }
            #table-of-contents h2 {
              font-size: 10pt;
              max-width: 8em;
              font-weight: normal;
              padding-left: 0.5em;
              padding-left: 0.5em;
              padding-top: 0.05em;
              padding-bottom: 0.05em; }
            #table-of-contents #text-table-of-contents {
              display: none;
              text-align: left; }
            #table-of-contents:hover #text-table-of-contents {
              display: block;
              padding: 0.5em;
              margin-top: -1.5em; }
        
          #license {
            padding: .3em;
            border: 1px solid grey;
            background-color: #eeeeee;
          }
        
          h1 {
        /*
            font-family:Sans;
            font-weight:bold; */
            font-size:2.1em;
            padding:0 0 30px 0;
            margin-top: 10px;
            margin-bottom: 10px;
            margin-right: 7%;
            color: #6C5D4F;
          }
        
        /*
          h2:before {
            content: \"* \"
          }
        
          h3:before {
            content: \"** \"
          }
        
          h4:before {
            content: \"*** \"
          }
        ,*/
        
          h2 {
            font-family:Arial,sans-serif;
            font-size:1.45em;
            line-height:16px;
            padding:7px 0 0 0;
            color: #6E2432;
          }
        
          .outline-text-2 {
            margin-left: 0.1em
          }
        
          .title {
        
          }
        
          h3 {
            font-family:Arial,sans-serif;
            font-size:1.3em;
            color: #A34D32;
            margin-left: 0.6em;
          }
        
          .outline-text-3 {
            margin-left: 0.9em;
          }
        
          h4 {
            font-family:Arial,sans-serif;
            font-size:1.2em;
            margin-left: 1.2em;
            color: #A5573E;
          }
        
          .outline-text-4 {
            margin-left: 1.45em;
          }
        
          a {text-decoration: none; color: #537d7b}
          /* a:visited {text-decoration: none; color: #224444} */ /* Taken out because color too similar to text. */
          a:visited {text-decoration: none; color: #98855b}  /* this is now the color of the Unicorns horn */
          a:hover {text-decoration: underline; color: #a34d32}
        
          .todo {
            color: #CA0000;
          }
        
          .done {
            color: #006666;
          }
        
          .timestamp-kwd {
            color: #444;
          }
        
          .tag {
        
          }
        
          li {
            margin: .4em;
          }
        
          table {
            border: none;
          }
        
          td {
            border: none;
          }
        
          th {
            border: none;
          }
        
          code {
            font-size: 100%;
            color: black;
            border: 1px solid #DEDEDE;
            padding: 0px 0.2em;
          }
        
          img {
            border: none;
          }
        
          .share img {
            opacity: .4;
            -moz-opacity: .4;
            filter: alpha(opacity=40);
          }
        
          .share img:hover {
            opacity: 1;
            -moz-opacity: 1;
            filter: alpha(opacity=100);
          }
        
          /* pre {border: 1px solid #555; */
          /*      background: #EEE; */
          /*      font-size: 9pt; */
          /*      padding: 1em; */
          /*     } */
        
          /* pre { */
          /*     color: #e5e5e5; */
          /*     background-color: #000000; */
          /*     padding: 1.4em; */
          /*     border: 2px solid grey; */
          /* } */
        
          /* pre { */
          /*     background-color: #2b2b2b; */
          /*     border: 4px solid grey; */
          /*     color: #EEE; */
          /*     overflow: auto; */
          /*     padding: 1em; */
          /*  } */
        
          pre {
            font-family: Monaco, Consolas, \"Lucida Console\", monospace;
            color: gainsboro;
            background-color: #373737;
            padding: 1.2em;
            border: 1px solid #dddddd;
            overflow: auto;
        
            -webkit-box-shadow: 0px 0px 4px rgba(0,0,0,0.23);
            -moz-box-shadow: 0px 0px 4px rgba(0,0,0,0.23);
            box-shadow: 0px 0px 4px rgba(0,0,0,0.23);
          }
        
          .org-info-box {
            clear:both;
            margin-left:auto;
            margin-right:auto;
            padding:0.7em;
            /* border:1px solid #CCC; */
            /* border-radius:10px; */
            /* -moz-border-radius:10px; */
          }
          .org-info-box img {
            float:left;
            margin:0em 0.5em 0em 0em;
          }
          .org-info-box p {
            margin:0em;
            padding:0em;
          }
        
        
          .builtin {
            /* font-lock-builtin-face */
            color: #f4a460;
          }
          .comment {
            /* font-lock-comment-face */
            color: #737373;
          }
          .comment-delimiter {
            /* font-lock-comment-delimiter-face */
            color: #666666;
          }
          .constant {
            /* font-lock-constant-face */
            color: #db7093;
          }
          .doc {
            /* font-lock-doc-face */
            color: #b3b3b3;
          }
          .function-name {
            /* font-lock-function-name-face */
            color: #5f9ea0;
          }
          .headline {
            /* headline-face */
            color: #ffffff;
            background-color: #000000;
            font-weight: bold;
          }
          .keyword {
            /* font-lock-keyword-face */
            color: #4682b4;
          }
          .negation-char {
          }
          .regexp-grouping-backslash {
          }
          .regexp-grouping-construct {
          }
          .string {
            /* font-lock-string-face */
            color: #ccc79a;
          }
          .todo-comment {
            /* todo-comment-face */
            color: #ffffff;
            background-color: #000000;
            font-weight: bold;
          }
          .variable-name {
            /* font-lock-variable-name-face */
            color: #ff6a6a;
          }
          .warning {
            /* font-lock-warning-face */
            color: #ffffff;
            background-color: #cd5c5c;
            font-weight: bold;
          }
          pre.a {
            color: inherit;
            background-color: inherit;
            font: inherit;
            text-decoration: inherit;
          }
          pre.a:hover {
            text-decoration: underline;
          }
        
          /* Styles for org-info.js */
        
          .org-info-js_info-navigation
          {
            border-style:none;
          }
        
          #org-info-js_console-label
          {
            font-size:10px;
            font-weight:bold;
            white-space:nowrap;
          }
        
          .org-info-js_search-highlight
          {
            background-color:#ffff00;
            color:#000000;
            font-weight:bold;
          }
        
          #org-info-js-window
          {
            border-bottom:1px solid black;
            padding-bottom:10px;
            margin-bottom:10px;
          }
        
        
        
          .org-info-search-highlight
          {
            background-color:#adefef; /* same color as emacs default */
            color:#000000;
            font-weight:bold;
          }
        
          .org-bbdb-company {
            /* bbdb-company */
            font-style: italic;
          }
          .org-bbdb-field-name {
          }
          .org-bbdb-field-value {
          }
          .org-bbdb-name {
            /* bbdb-name */
            text-decoration: underline;
          }
          .org-bold {
            /* bold */
            font-weight: bold;
          }
          .org-bold-italic {
            /* bold-italic */
            font-weight: bold;
            font-style: italic;
          }
          .org-border {
            /* border */
            background-color: #000000;
          }
          .org-buffer-menu-buffer {
            /* buffer-menu-buffer */
            font-weight: bold;
          }
          .org-builtin {
            /* font-lock-builtin-face */
            color: #da70d6;
          }
          .org-button {
            /* button */
            text-decoration: underline;
          }
          .org-c-nonbreakable-space {
            /* c-nonbreakable-space-face */
            background-color: #ff0000;
            font-weight: bold;
          }
          .org-calendar-today {
            /* calendar-today */
            text-decoration: underline;
          }
          .org-comment {
            /* font-lock-comment-face */
            color: #b22222;
          }
          .org-comment-delimiter {
            /* font-lock-comment-delimiter-face */
            color: #b22222;
          }
          .org-constant {
            /* font-lock-constant-face */
            color: #5f9ea0;
          }
          .org-cursor {
            /* cursor */
            background-color: #000000;
          }
          .org-default {
            /* default */
            color: #000000;
            background-color: #ffffff;
          }
          .org-diary {
            /* diary */
            color: #ff0000;
          }
          .org-doc {
            /* font-lock-doc-face */
            color: #bc8f8f;
          }
          .org-escape-glyph {
            /* escape-glyph */
            color: #a52a2a;
          }
          .org-file-name-shadow {
            /* file-name-shadow */
            color: #7f7f7f;
          }
          .org-fixed-pitch {
          }
          .org-fringe {
            /* fringe */
            background-color: #f2f2f2;
          }
          .org-function-name {
            /* font-lock-function-name-face */
            color: #0000ff;
          }
          .org-header-line {
            /* header-line */
            color: #333333;
            background-color: #e5e5e5;
          }
          .org-help-argument-name {
            /* help-argument-name */
            font-style: italic;
          }
          .org-highlight {
            /* highlight */
            background-color: #b4eeb4;
          }
          .org-holiday {
            /* holiday */
            background-color: #ffc0cb;
          }
          .org-info-header-node {
            /* info-header-node */
            color: #a52a2a;
            font-weight: bold;
            font-style: italic;
          }
          .org-info-header-xref {
            /* info-header-xref */
            color: #0000ff;
            text-decoration: underline;
          }
          .org-info-menu-header {
            /* info-menu-header */
            font-weight: bold;
          }
          .org-info-menu-star {
            /* info-menu-star */
            color: #ff0000;
          }
          .org-info-node {
            /* info-node */
            color: #a52a2a;
            font-weight: bold;
            font-style: italic;
          }
          .org-info-title-1 {
            /* info-title-1 */
            font-size: 172%;
            font-weight: bold;
          }
          .org-info-title-2 {
            /* info-title-2 */
            font-size: 144%;
            font-weight: bold;
          }
          .org-info-title-3 {
            /* info-title-3 */
            font-size: 120%;
            font-weight: bold;
          }
          .org-info-title-4 {
            /* info-title-4 */
            font-weight: bold;
          }
          .org-info-xref {
            /* info-xref */
            color: #0000ff;
            text-decoration: underline;
          }
          .org-isearch {
            /* isearch */
            color: #b0e2ff;
            background-color: #cd00cd;
          }
          .org-italic {
            /* italic */
            font-style: italic;
          }
          .org-keyword {
            /* font-lock-keyword-face */
            color: #a020f0;
          }
          .org-lazy-highlight {
            /* lazy-highlight */
            background-color: #afeeee;
          }
          .org-link {
            /* link */
            color: #0000ff;
            text-decoration: underline;
          }
          .org-link-visited {
            /* link-visited */
            color: #8b008b;
            text-decoration: underline;
          }
          .org-match {
            /* match */
            background-color: #ffff00;
          }
          .org-menu {
          }
          .org-message-cited-text {
            /* message-cited-text */
            color: #ff0000;
          }
          .org-message-header-cc {
            /* message-header-cc */
            color: #191970;
          }
          .org-message-header-name {
            /* message-header-name */
            color: #6495ed;
          }
          .org-message-header-newsgroups {
            /* message-header-newsgroups */
            color: #00008b;
            font-weight: bold;
            font-style: italic;
          }
          .org-message-header-other {
            /* message-header-other */
            color: #4682b4;
          }
          .org-message-header-subject {
            /* message-header-subject */
            color: #000080;
            font-weight: bold;
          }
          .org-message-header-to {
            /* message-header-to */
            color: #191970;
            font-weight: bold;
          }
          .org-message-header-xheader {
            /* message-header-xheader */
            color: #0000ff;
          }
          .org-message-mml {
            /* message-mml */
            color: #228b22;
          }
          .org-message-separator {
            /* message-separator */
            color: #a52a2a;
          }
          .org-minibuffer-prompt {
            /* minibuffer-prompt */
            color: #0000cd;
          }
          .org-mm-uu-extract {
            /* mm-uu-extract */
            color: #006400;
            background-color: #ffffe0;
          }
          .org-mode-line {
            /* mode-line */
            color: #000000;
            background-color: #bfbfbf;
          }
          .org-mode-line-buffer-id {
            /* mode-line-buffer-id */
            font-weight: bold;
          }
          .org-mode-line-highlight {
          }
          .org-mode-line-inactive {
            /* mode-line-inactive */
            color: #333333;
            background-color: #e5e5e5;
          }
          .org-mouse {
            /* mouse */
            background-color: #000000;
          }
          .org-negation-char {
          }
          .org-next-error {
            /* next-error */
            background-color: #eedc82;
          }
          .org-nobreak-space {
            /* nobreak-space */
            color: #a52a2a;
            text-decoration: underline;
          }
          .org-org-agenda-date {
            /* org-agenda-date */
            color: #0000ff;
          }
          .org-org-agenda-date-weekend {
            /* org-agenda-date-weekend */
            color: #0000ff;
            font-weight: bold;
          }
          .org-org-agenda-restriction-lock {
            /* org-agenda-restriction-lock */
            background-color: #ffff00;
          }
          .org-org-agenda-structure {
            /* org-agenda-structure */
            color: #0000ff;
          }
          .org-org-archived {
            /* org-archived */
            color: #7f7f7f;
          }
          .org-org-code {
            /* org-code */
            color: #7f7f7f;
          }
          .org-org-column {
            /* org-column */
            background-color: #e5e5e5;
          }
          .org-org-column-title {
            /* org-column-title */
            background-color: #e5e5e5;
            font-weight: bold;
            text-decoration: underline;
          }
          .org-org-date {
            /* org-date */
            color: #a020f0;
            text-decoration: underline;
          }
          .org-org-done {
            /* org-done */
            color: #228b22;
            font-weight: bold;
          }
          .org-org-drawer {
            /* org-drawer */
            color: #0000ff;
          }
          .org-org-ellipsis {
            /* org-ellipsis */
            color: #b8860b;
            text-decoration: underline;
          }
          .org-org-formula {
            /* org-formula */
            color: #b22222;
          }
          .org-org-headline-done {
            /* org-headline-done */
            color: #bc8f8f;
          }
          .org-org-hide {
            /* org-hide */
            color: #e5e5e5;
          }
          .org-org-latex-and-export-specials {
            /* org-latex-and-export-specials */
            color: #8b4513;
          }
          .org-org-level-1 {
            /* org-level-1 */
            color: #0000ff;
          }
          .org-org-level-2 {
            /* org-level-2 */
            color: #b8860b;
          }
          .org-org-level-3 {
            /* org-level-3 */
            color: #a020f0;
          }
          .org-org-level-4 {
            /* org-level-4 */
            color: #b22222;
          }
          .org-org-level-5 {
            /* org-level-5 */
            color: #228b22;
          }
          .org-org-level-6 {
            /* org-level-6 */
            color: #5f9ea0;
          }
          .org-org-level-7 {
            /* org-level-7 */
            color: #da70d6;
          }
          .org-org-level-8 {
            /* org-level-8 */
            color: #bc8f8f;
          }
          .org-org-link {
            /* org-link */
            color: #a020f0;
            text-decoration: underline;
          }
          .org-org-property-value {
          }
          .org-org-scheduled-previously {
            /* org-scheduled-previously */
            color: #b22222;
          }
          .org-org-scheduled-today {
            /* org-scheduled-today */
            color: #006400;
          }
          .org-org-sexp-date {
            /* org-sexp-date */
            color: #a020f0;
          }
          .org-org-special-keyword {
            /* org-special-keyword */
            color: #bc8f8f;
          }
          .org-org-table {
            /* org-table */
            color: #0000ff;
          }
          .org-org-tag {
            /* org-tag */
            font-weight: bold;
          }
          .org-org-target {
            /* org-target */
            text-decoration: underline;
          }
          .org-org-time-grid {
            /* org-time-grid */
            color: #b8860b;
          }
          .org-org-todo {
            /* org-todo */
            color: #ff0000;
          }
          .org-org-upcoming-deadline {
            /* org-upcoming-deadline */
            color: #b22222;
          }
          .org-org-verbatim {
            /* org-verbatim */
            color: #7f7f7f;
            text-decoration: underline;
          }
          .org-org-warning {
            /* org-warning */
            color: #ff0000;
            font-weight: bold;
          }
          .org-outline-1 {
            /* outline-1 */
            color: #0000ff;
          }
          .org-outline-2 {
            /* outline-2 */
            color: #b8860b;
          }
          .org-outline-3 {
            /* outline-3 */
            color: #a020f0;
          }
          .org-outline-4 {
            /* outline-4 */
            color: #b22222;
          }
          .org-outline-5 {
            /* outline-5 */
            color: #228b22;
          }
          .org-outline-6 {
            /* outline-6 */
            color: #5f9ea0;
          }
          .org-outline-7 {
            /* outline-7 */
            color: #da70d6;
          }
          .org-outline-8 {
            /* outline-8 */
            color: #bc8f8f;
          }
          .outline-text-1, .outline-text-2, .outline-text-3, .outline-text-4, .outline-text-5, .outline-text-6 {
            /* Add more spacing between section. Padding, so that folding with org-info.js works as expected. */
        
          }
        
          .org-preprocessor {
            /* font-lock-preprocessor-face */
            color: #da70d6;
          }
          .org-query-replace {
            /* query-replace */
            color: #b0e2ff;
            background-color: #cd00cd;
          }
          .org-regexp-grouping-backslash {
            /* font-lock-regexp-grouping-backslash */
            font-weight: bold;
          }
          .org-regexp-grouping-construct {
            /* font-lock-regexp-grouping-construct */
            font-weight: bold;
          }
          .org-region {
            /* region */
            background-color: #eedc82;
          }
          .org-rmail-highlight {
          }
          .org-scroll-bar {
            /* scroll-bar */
            background-color: #bfbfbf;
          }
          .org-secondary-selection {
            /* secondary-selection */
            background-color: #ffff00;
          }
          .org-shadow {
            /* shadow */
            color: #7f7f7f;
          }
          .org-show-paren-match {
            /* show-paren-match */
            background-color: #40e0d0;
          }
          .org-show-paren-mismatch {
            /* show-paren-mismatch */
            color: #ffffff;
            background-color: #a020f0;
          }
          .org-string {
            /* font-lock-string-face */
            color: #bc8f8f;
          }
          .org-texinfo-heading {
            /* texinfo-heading */
            color: #0000ff;
          }
          .org-tool-bar {
            /* tool-bar */
            color: #000000;
            background-color: #bfbfbf;
          }
          .org-tooltip {
            /* tooltip */
            color: #000000;
            background-color: #ffffe0;
          }
          .org-trailing-whitespace {
            /* trailing-whitespace */
            background-color: #ff0000;
          }
          .org-type {
            /* font-lock-type-face */
            color: #228b22;
          }
          .org-underline {
            /* underline */
            text-decoration: underline;
          }
          .org-variable-name {
            /* font-lock-variable-name-face */
            color: #b8860b;
          }
          .org-variable-pitch {
          }
          .org-vertical-border {
          }
          .org-warning {
            /* font-lock-warning-face */
            color: #ff0000;
            font-weight: bold;
          }
          .rss_box {}
          .rss_title, rss_title a {}
          .rss_items {}
          .rss_item a:link, .rss_item a:visited, .rss_item a:active {}
          .rss_item a:hover {}
          .rss_date {}
        
          #postamble { 
              padding-top: 1em;
              font-size: 0.8em;
              color: #464646;
              line-height: 30%;
          }
        
        } /* END OF @media all */
        
        
        
        @media screen
        {
          #table-of-contents {
            float: right;
            border: 1px solid #CCC;
            max-width: 50%;
            overflow: auto;
          }
        } /* END OF @media screen */
      </style>")
    #+end_src

*** babel

    #+begin_src emacs-lisp
      (require 'ob)
      (require 'ob-sh)
      (require 'ob-latex)
      (setq org-src-window-setup 'current-window)
      (setq org-src-fontify-natively t)
      (setq org-confirm-babel-evaluate nil)
    #+end_src

** IBuffer

   #+begin_src emacs-lisp 
     (setq ibuffer-saved-filter-groups
           (quote (("default"
                 ("Source" (or
                            (mode . java-mode)
                            (mode . clojure-mode)
                            (mode . org-mode)
                            (mode . xml-mode)
                            (mode . scheme-mode)
                            (mode . ruby-mode)
                            (mode . shell-script-mode)
                            (mode . sh-mode)
                            (mode . c-mode)
                            (mode . lisp-mode)
                            (mode . cperl-mode)
                            (mode . asm-mode)
                            (mode . emacs-lisp-mode)
                            (mode . c++-mode)))
                 ("Terminal" (or (mode . term-mode)
                                 (mode . inferior-lisp-mode)))
                 ("Dired" (mode . dired-mode))
                 ("Gnus" (or
                          (mode . message-mode)
                          (mode . mail-mode)
                          (mode . gnus-group-mode)
                          (mode . gnus-summary-mode)
                          (mode . gnus-article-mode)
                          (name . "^\\*offlineimap\\*$")
                          (name . "^\\.newsrc-dribble")))
                 ("Emacs" (or
                           (name . "^\\*info\\*$")
                           (name . "^\\*tramp.+\\*$")
                           (name . "^\\*trace.+SMTP.+\\*$")
                           (name . "^\\.todo-do")
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*git-status\\*$")
                           (name . "^\\*git-diff\\*$")
                           (name . "^\\*git-commit\\*$")
                           (name . "^\\*Git Command Output\\*$")
                           (name . "^\\*Org Export/Publishing Help\\*$")
                           (name . "^\\*Org Agenda\\*$")
                           (name . "^\\*Calendar\\*$")
                           (name . "^\\*Messages\\*$")
                           (name . "^\\*Completions\\*$") 
                           (name . "^\\*Backtrace\\*$")
                           (name . "^TAGS$")
                           (name . "^\\*Help\\*$")
                           (name . "^\\*Shell Command Output\\*$")))))))
     
     (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))
     (setq ibuffer-expert t)
     
     (setq ibuffer-formats '((mark modified read-only " "
                                   (name 18 18 :left :elide)
                                   " "
                                   (mode 16 16 :left :elide)
                                   " " filename-and-process)
                             (mark " "
                                   (name 16 -1)
                                   " " filename)))
     
   #+end_src

** EasyPG

   #+begin_src emacs-lisp 
     (require 'epa)
     (epa-file-enable)
     
     (cond 
      (na-os-is-darwin  (setq epg-gpg-program "/opt/local/bin/gpg"))
      (na-os-is-windows (setq epg-gpg-program (concat "/bin/gpg"))))
   #+end_src

** Text Mode
   #+begin_src emacs-lisp 
     (delete-selection-mode)
     (setq fill-column 80)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   #+end_src

** Flyspell
   #+begin_src emacs-lisp 
     (setq ispell-program-name "/opt/local/bin/ispell")
     (autoload 'flyspell-mode "flyspell" "On-the-fly spelling checker." t)
     (add-hook 'message-mode-hook 'turn-on-flyspell)
     (add-hook 'text-mode-hook 'turn-on-flyspell)
     (add-hook 'c-mode-common-hook 'flyspell-prog-mode)
     (add-hook 'java-mode-hook 'flyspell-prog-mode)
     (add-hook 'ruby-mode-hook 'flyspell-prog-mode)
     (add-hook 'lisp-mode-hook 'flyspell-mode)
     (add-hook 'emacs-lisp-mode-hook 'flyspell-mode)
     (defun turn-on-flyspell ()
       "Force flyspell-mode on using a positive arg.  For use in hooks."
       (interactive)
       (flyspell-mode 1))
   #+end_src

** Lisp
*** Common

    #+begin_src emacs-lisp
      (defun na-bounce-sexp ()
        "Will bounce between matching parens just like % in vi"
        (interactive)
        (let ((prev-char (char-to-string (preceding-char)))
              (next-char (char-to-string (following-char))))
          (cond ((string-match "[[{(<]" next-char) (forward-sexp 1))
                ((string-match "[\]})>]" prev-char) (backward-sexp 1))
                (t (error "%s" "Not on a paren, brace, or bracket")))))
      
      (defun lispy-parens ()
        "Setup parens display for lisp modes"
        (setq show-paren-delay 0)
        (setq show-paren-style 'parenthesis)
        (make-variable-buffer-local 'show-paren-mode)
        (show-paren-mode 1)
        (set-face-background 'show-paren-match-face (face-background 'default))
        (if (boundp 'font-lock-comment-face)
            (set-face-foreground 'show-paren-match-face 
                                 (face-foreground 'font-lock-comment-face))
          (set-face-foreground 'show-paren-match-face 
                               (face-foreground 'default)))
        (set-face-foreground 'show-paren-match-face "red")
        (set-face-attribute 'show-paren-match-face nil :weight 'extra-bold))
      
      (add-hook 'lisp-mode-hook 'lispy-parens)
      (add-hook 'emacs-lisp-mode-hook 'lispy-parens)
      (add-hook 'lisp-mode-hook 'abbrev-mode)
      (add-hook 'emacs-lisp-mode-hook 'abbrev-mode)
      (add-hook 'clojure-mode-hook 'abbrev-mode)
      (add-hook 'scheme-mode-hook 'abbrev-mode)
      (add-hook 'clojure-mode-hook 'lispy-parens)
      (add-hook 'scheme-mode-hook 'lispy-parens)
    #+end_src

*** Clojure

    #+begin_src emacs-lisp 
      (cond 
       (na-os-is-darwin
        (setq clojure-command (concat "/Users/nakkaya/Dropbox/bash/lein repl")))
       (na-os-is-linux
        (setq clojure-command (concat "/home/nakkaya/Dropbox/bash/lein repl")))
       (na-os-is-windows
        (setq clojure-command (concat "/cygdrive/c/Dropbox/bash/lein repl"))))
      
      (setq lisp-programs 
            (list (list "clojure" clojure-command)
                  (list "sbcl" "/opt/local/bin/sbcl")
                  (list "gambit" "/opt/local/bin/gambit-gsc")))
      
      (defun na-run-lisp (arg)
        (interactive "P")
        (if (null arg)
            (run-lisp (second (first lisp-programs)))
          (let (choice) 
            (setq choice (completing-read "Lisp: " (mapcar 'first lisp-programs)))
            (dolist (l lisp-programs)
              (if (string= (first l) choice)
                  (run-lisp (second l)))))))
      
      (defun remote-repl (arg)
        (interactive "P")
        (run-lisp (concat "nc " (read-string "IP: ") " " (read-string "Port: "))))
      
      (defun na-load-buffer ()
        (interactive)
        (point-to-register 5)
        (mark-whole-buffer)
        (lisp-eval-region (point) (mark) nil)
        (jump-to-register 5))
      
      ;;sub process support for clojure
      (add-hook 'clojure-mode-hook
                '(lambda ()
                   (define-key clojure-mode-map 
                     "\e\C-x" 'lisp-eval-defun)
                   (define-key clojure-mode-map 
                     "\C-x\C-e" 'lisp-eval-last-sexp)
                   (define-key clojure-mode-map 
                     "\C-c\C-e" 'lisp-eval-last-sexp)
                   (define-key clojure-mode-map 
                     "\C-c\C-r" 'lisp-eval-region)
                   (define-key clojure-mode-map 
                     "\C-c\C-l" 'na-load-buffer)
                   (define-key clojure-mode-map 
                     "\C-c\C-z" 'run-lisp)))
      
      (define-clojure-indent (from-blackboard 'defun))
    #+end_src

    #+begin_src emacs-lisp
      (add-to-list 'org-babel-tangle-lang-exts '("clojure" . "clj"))
      
      (defvar org-babel-default-header-args:clojure 
        '((:results . "silent")))
      
      (defun org-babel-execute:clojure (body params)
        "Execute a block of Clojure code with Babel."
        (lisp-eval-string body)
        "Done!")
      
      (provide 'ob-clojure)
    #+end_src

    #+begin_src emacs-lisp
      (let ((fn `(("(\\(fn\\)[\[[:space:]]"
                   (0 (progn (compose-region (match-beginning 1)
                                             (match-end 1) "")
                             nil)))))
            (inline-fn `(("\\(#\\)("
                          (0 (progn (compose-region (match-beginning 1)
                                                    (match-end 1) "")
                                    nil))))))
            
            (font-lock-add-keywords 'clojure-mode fn)
            (font-lock-add-keywords 'clojure-mode inline-fn)
            (font-lock-add-keywords 'org-mode fn)
            (font-lock-add-keywords 'org-mode inline-fn))
    #+end_src

*** Scheme

    #+begin_src emacs-lisp
      (add-hook 'scheme-mode-hook
                '(lambda ()
                   (define-key scheme-mode-map 
                     "\e\C-x" 'lisp-eval-defun)
                   (define-key scheme-mode-map 
                     "\C-x\C-e" 'lisp-eval-last-sexp)
                   (define-key scheme-mode-map 
                     "\C-c\C-e" 'lisp-eval-last-sexp)
                   (define-key scheme-mode-map 
                     "\C-c\C-r" 'lisp-eval-region)
                   (define-key scheme-mode-map 
                     "\C-c\C-l" 'na-load-buffer)
                   (define-key scheme-mode-map 
                     "\C-c\C-z" 'run-lisp)))
    #+end_src

** External

   Modules that are not part of emacs,

*** multi-term

   #+begin_src emacs-lisp
     ;;; multi-term.el --- Managing multiple terminal buffers in Emacs.
     
     ;; Author: Andy Stewart <lazycat.manatee@gmail.com>
     ;; Maintainer: ahei <ahei0802@gmail.com>
     ;; Copyright (C) 2008, 2009, Andy Stewart, all rights reserved.
     ;; Copyright (C) 2010, ahei, all rights reserved.
     ;; Created: <2008-09-19 23:02:42>
     ;; Version: 0.8.8
     ;; Last-Updated: <2010-05-13 00:40:24 Thursday by ahei>
     ;; URL: http://www.emacswiki.org/emacs/download/multi-term.el
     ;; Keywords: term, terminal, multiple buffer
     ;; Compatibility: GNU Emacs 23.2.1
     
     ;; This program is free software; you can redistribute it and/or modify
     ;; it under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 3, or (at your option)
     ;; any later version.
     
     ;; This program is distributed in the hope that it will be useful,
     ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     ;; GNU General Public License for more details.
     
     ;; You should have received a copy of the GNU General Public License
     ;; along with this program; see the file COPYING.  If not, write to
     ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
     ;; Floor, Boston, MA 02110-1301, USA.
     
     ;; Features that might be required by this library:
     ;;
     ;;  `term' `cl' `advice'
     ;;
     
     ;;; Commentary:
     ;;
     ;; This package is for creating and managing multiple terminal buffers in Emacs.
     ;;
     ;; By default, term.el provides a great terminal emulator in Emacs.
     ;; But I have some troubles with term-mode:
     ;;
     ;; 1. term.el just provides commands `term' or `ansi-term'
     ;;    for creating a terminal buffer.
     ;;    And there is no special command to create or switch
     ;;    between multiple terminal buffers quickly.
     ;;
     ;; 2. By default, the keystrokes of term.el conflict with global-mode keystrokes,
     ;;    which makes it difficult for the user to integrate term.el with Emacs.
     ;;
     ;; 3. By default, executing *NIX command exit from term-mode,
     ;;    it will leave an unused buffer.
     ;;
     ;; 4. term.el wont quit running sub-process when you kill terminal buffer forcibly.
     ;;
     ;; 5. Havent a dedicated window for debug program.
     ;;
     ;; And multi-term.el is enhanced with those features.
     ;;
     
     ;;; Installation:
     ;;
     ;; Copy multi-term.el to your load-path and add to your ~/.emacs
     ;;
     ;;  (require 'multi-term)
     ;;
     ;; And setup program that `multi-term' will need:
     ;;
     ;; (setq multi-term-program "/bin/bash")
     ;;
     ;;      or setup like me "/bin/zsh" ;)
     ;;
     ;; Below are the commands you can use:
     ;;
     ;;      `multi-term'                    Create a new term buffer.
     ;;      `multi-term-next'               Switch to next term buffer.
     ;;      `multi-term-prev'               Switch to previous term buffer.
     ;;      `multi-term-dedicated-open'     Open dedicated term window.
     ;;      `multi-term-dedicated-close'    Close dedicated term window.
     ;;      `multi-term-dedicated-toggle'   Toggle dedicated term window.
     ;;      `multi-term-dedicated-select'   Select dedicated term window.
     ;;
     ;; Tips:
     ;;
     ;;      You can type `C-u' before command `multi-term' or `multi-term-dedicated-open'
     ;;      then will prompt you shell name for creating terminal buffer.
     ;;
     
     ;;; Customize:
     ;;
     ;; `multi-term-program' default is nil, so when creating new term buffer,
     ;; send environment variable of `SHELL' (`ESHELL', `/bin/sh') to `make-term'.
     ;;
     ;; And you can set it to your liking, like me: ;-)
     ;;
     ;; (setq multi-term-program "/bin/zsh")
     ;;
     ;; `multi-term-default-dir' default is `~/', only use when current buffer
     ;; is not in a real directory.
     ;;
     ;; `multi-term-buffer-name' is the name of term buffer.
     ;;
     ;; `multi-term-scroll-show-maximum-output' controls how interpreter
     ;; output causes window to scroll.
     ;;
     ;; `multi-term-scroll-to-bottom-on-output' controls whether interpreter
     ;; output causes window to scroll.
     ;;
     ;; `multi-term-switch-after-close' try to switch other `multi-term' buffer
     ;; after close current one.
     ;; If you don't like this feature just set it with nil.
     ;;
     ;; `term-unbind-key-list' is a key list to unbind some keystroke.
     ;;
     ;; `term-bind-key-alist' is a key alist that binds some keystroke.
     ;; If you don't like default, modify it.
     ;;
     ;; `multi-term-dedicated-window-height' the height of a dedicated term window.
     ;;
     ;; `multi-term-dedicated-max-window-height' the max height limit that dedicated
     ;; window is allowed.
     ;;
     ;; `multi-term-dedicated-skip-other-window-p' whether skip dedicated term
     ;; window when use command `other-window' to cycle windows order.
     ;;
     ;; All of the above can be customize by:
     ;;      M-x customize-group RET multi-term RET
     ;;
     
     ;;; Change log:
     ;;
     ;; 2009/07/04
     ;;      * Add new option `multi-term-dedicated-select-after-open-p'.
     ;;
     ;; 2009/06/29
     ;;      * Fix regexp bug.
     ;;
     ;; 2009/04/21
     ;;      * Fix a bug that bring at `2009/03/28':
     ;;        It will kill sub-process in other multi-term buffer
     ;;        when we kill current multi-term buffer.
     ;;
     ;; 2009/03/29
     ;;      * Add new command `term-send-reverse-search-history'.
     ;;
     ;; 2009/03/28
     ;;      * Add new option `multi-term-switch-after-close'.
     ;;
     ;; 2009/02/18
     ;;      * Fix bug between ECB and `multi-term-dedicated-close'.
     ;;
     ;; 2009/02/05
     ;;      * Prompt user shell name when type `C-u' before command
     ;;        `multi-term' or `multi-term-dedicated-open'.
     ;;      * Fix doc.
     ;;
     ;; 2009/01/29
     ;;      * Use `term-quit-subjob' instead `term-interrupt-subjob'.
     ;;      * Fix doc.
     ;;
     ;; 2009/01/13
     ;;      * Rewrite advice for `pop-to-buffer' to avoid `pop-to-buffer' not effect
     ;;        when have many dedicated window in current frame.
     ;;      * Rewrite advice for `delete-other-windows' to avoid use common variable
     ;;        `delete-protected-window-list' and use `window-dedicated-p' instead.
     ;;        Remove variable `delete-protected-window-list' and function
     ;;        `multi-term-dedicated-match-protected-window-p'.
     ;;
     ;; 2009/01/06
     ;;      * Improve document.
     ;;
     ;; 2008/12/29
     ;;      * Remove option `multi-term-current-window-height' and
     ;;        function `multi-term-current-directory'.
     ;;      * Add some functions to make get dedicated term buffer,
     ;;        those functions is beginning with `multi-term-dedicated-'.
     ;;      * Modified advice `delete-window', make command `delete-window'
     ;;        and delete dedicated window, but will remember window height
     ;;        before deleted.
     ;;      * Don't remember dedicated window height if larger than max value.
     ;;      * Fix some bug with `delete-other-windows' and window configuration.
     ;;        And this bug exists with another extension `sr-speedbar'.
     ;;      * Add new variable `delete-protected-window-list' for protected
     ;;        special window that won't be deleted.
     ;;        This variable is common for any extension that use dedicated
     ;;        window.
     ;;      * Fix doc.
     ;;
     ;; 2008/12/21
     ;;      * Default bind `C-m' with `term-send-input'.
     ;;
     ;; 2008/12/10
     ;;      * Improve customize interface.
     ;;      * Setup customize automatically, don't need to user setup it up.
     ;;      * Add option `multi-term-try-create'.
     ;;      * Make function `multi-term-switch' accept offset argument.
     ;;      * Fix doc.
     ;;
     ;; 2008/10/22
     ;;      * Add variable `multi-term-current-window-height'.
     ;;      * Add variable `multi-term-buffer-name'.
     ;;      * Add variable `term-unbind-key-list'.
     ;;      * Add variable `term-rebind-key-alist'.
     ;;      * Move key setup and some extension from `term-extension.el'.
     ;;      * Create new function `multi-term-keystroke-setup'.
     ;;      * Fix doc.
     ;;
     ;; 2008/09/19
     ;;      * First released.
     ;;
     
     ;;; Acknowledgments:
     ;;
     ;;      Mark Triggs     <mst@dishevelled.net>
     ;;              For create multi-shell.el
     ;;      Aaron S. Hawley <aaron.s.hawley@gmail.com>
     ;;              For improve document.
     ;;
     
     ;;; Bug
     ;;
     ;;
     
     ;;; TODO
     ;;
     ;;
     ;;
     
     ;;; Require:
     (require 'term)
     (require 'cl)
     (require 'advice)
     
     ;;; Code:
     
     ;;; Customize
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Customize ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defgroup multi-term nil
       "Multi term manager."
       :group 'term)
     
     (defcustom multi-term-program nil
       "The program of term.
     If this is nil, setup to environment variable of `SHELL'."
       :type 'string
       :group 'multi-term)
     
     (defcustom multi-term-program-switches nil
       "The command-line switches to pass to the term program."
       :type 'string
       :group 'multi-term)
     
     (defcustom multi-term-try-create t
       "Try to create a new term buffer when switch.
     
     When use `multi-term-next' or `multi-term-prev', switch term buffer,
     and try to create a new term buffer if no term buffers exist."
       :type 'boolean
       :group 'multi-shell)
     
     (defcustom multi-term-default-dir "~/"
       "The default directory for terms if current directory doesn't exist."
       :type 'string
       :group 'multi-term)
     
     (defcustom multi-term-buffer-name "terminal"
       "The buffer name of term buffer."
       :type 'string
       :group 'multi-term)
     
     (defcustom multi-term-scroll-show-maximum-output nil
       "*Controls how interpreter output causes window to scroll.
     If non-nil, then show the maximum output when the window is scrolled.
     
     See variable `multi-term-scroll-to-bottom-on-output'."
       :type 'boolean
       :group 'multi-term)
     
     (defcustom multi-term-scroll-to-bottom-on-output nil
       "*Controls whether interpreter output causes window to scroll.
     If nil, then do not scroll.  If t or `all', scroll all windows showing buffer.
     If `this', scroll only the selected window.
     If `others', scroll only those that are not the selected window.
     
     The default is nil.
     
     See variable `multi-term-scroll-show-maximum-output'."
       :type 'boolean
       :group 'multi-term)
     
     (defcustom multi-term-switch-after-close 'NEXT
       "Try to switch other `multi-term' buffer after close current one.
     If this option is 'NEXT, switch to next `multi-term' buffer;
     If this option is 'PREVIOUS, switch to previous `multi-term' buffer.
     If this option is nil, don't switch other `multi-term' buffer."
       :type 'symbol
       :group 'multi-term)
     
     (defcustom term-unbind-key-list
       '("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
       "The key list that will need to be unbind."
       :type 'list
       :group 'multi-term)
     
     (defcustom term-bind-key-alist
       '(
         ("C-c C-c" . term-interrupt-subjob)
         ("C-p" . previous-line)
         ("C-n" . next-line)
         ("C-s" . isearch-forward)
         ("C-r" . isearch-backward)
         ("C-m" . term-send-raw)
         ("M-f" . term-send-forward-word)
         ("M-b" . term-send-backward-word)
         ("M-o" . term-send-backspace)
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)
         ("M-M" . term-send-forward-kill-word)
         ("M-N" . term-send-backward-kill-word)
         ("M-r" . term-send-reverse-search-history)
         ("M-," . term-send-input)
         ("M-." . comint-dynamic-complete))
       "The key alist that will need to be bind.
     If you do not like default setup, modify it, with (KEY . COMMAND) format."
       :type 'alist
       :group 'multi-term)
     
     (defcustom multi-term-dedicated-window-height 14
       "The height of `multi-term' dedicated window."
       :type 'integer
       :group 'multi-term)
     
     (defcustom multi-term-dedicated-max-window-height 30
       "The max height limit of `multi-term' dedicated window.
     Default, when hide `multi-term' dedicated window, will remember
     window height before hide, except height is larger than this.`"
       :type 'integer
       :group 'multi-term)
     
     (defcustom multi-term-dedicated-skip-other-window-p nil
       "Default, can have `other-window' select window in cyclic ordering of windows.
     In cases you don't want to select `multi-term' dedicated window, use `other-window'
     and make `multi-term' dedicated window as a viewable sidebar.
     
     So please turn on this option if you want to skip `multi-term' dedicated window with `other-window'.
     
     Default is nil."
       :type 'boolean
       :set (lambda (symbol value)
              (set symbol value)
              (when (ad-advised-definition-p 'other-window)
                (multi-term-dedicated-handle-other-window-advice value)))
       :group 'multi-term)
     
     (defcustom multi-term-dedicated-select-after-open-p nil
       "Default, multi-term won't focus terminal window after you open dedicated window.
     Please make this option with t if you want focus terminal window.
     
     Default is nil."
       :type 'boolean
       :group 'multi-term)
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Constant ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defconst multi-term-dedicated-buffer-name "MULTI-TERM-DEDICATED"
       "The buffer name of dedicated `multi-term'.")
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Variable ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defvar multi-term-dedicated-window nil
       "The dedicated `multi-term' window.")
     
     (defvar multi-term-dedicated-buffer nil
       "The dedicated `multi-term' buffer.")
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Interactive Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;;;###autoload
     (defun multi-term ()
       "Create new term buffer.
     Will prompt you shell name when you type `C-u' before this command."
       (interactive)
       (let (term-buffer)
         ;; Set buffer.
         (setq term-buffer (multi-term-get-buffer current-prefix-arg))
         (set-buffer term-buffer)
         ;; Internal handle for `multi-term' buffer.
         (multi-term-internal)
         ;; Switch buffer
         (switch-to-buffer term-buffer)))
     
     (defun multi-term-next (&optional offset)
       "Go to the next term buffer.
     If OFFSET is `non-nil', will goto next term buffer with OFFSET."
       (interactive "P")
       (multi-term-switch 'NEXT (or offset 1)))
     
     (defun multi-term-prev (&optional offset)
       "Go to the previous term buffer.
     If OFFSET is `non-nil', will goto previous term buffer with OFFSET."
       (interactive "P")
       (multi-term-switch 'PREVIOUS (or offset 1)))
     
     (defun multi-term-dedicated-open ()
       "Open dedicated `multi-term' window.
     Will prompt you shell name when you type `C-u' before this command."
       (interactive)
       (if (not (multi-term-dedicated-exist-p))
           (let ((current-window (selected-window)))
             (if (multi-term-buffer-exist-p multi-term-dedicated-buffer)
                 (unless (multi-term-window-exist-p multi-term-dedicated-window)
                   (multi-term-dedicated-get-window))
               ;; Set buffer.
               (setq multi-term-dedicated-buffer (multi-term-get-buffer current-prefix-arg t))
               (set-buffer (multi-term-dedicated-get-buffer-name))
               ;; Get dedicate window.
               (multi-term-dedicated-get-window)
               ;; Whether skip `other-window'.
               (multi-term-dedicated-handle-other-window-advice multi-term-dedicated-skip-other-window-p)
               ;; Internal handle for `multi-term' buffer.
               (multi-term-internal))
             (set-window-buffer multi-term-dedicated-window (get-buffer (multi-term-dedicated-get-buffer-name)))
             (set-window-dedicated-p multi-term-dedicated-window t)
             ;; Select window.
             (select-window
              (if multi-term-dedicated-select-after-open-p
                  ;; Focus dedicated terminal window if option `multi-term-dedicated-select-after-open-p' is enable.
                  multi-term-dedicated-window
                ;; Otherwise focus current window.
                current-window)))
         (message "`multi-term' dedicated window has exist.")))
     
     (defun multi-term-dedicated-close ()
       "Close dedicated `multi-term' window."
       (interactive)
       (if (multi-term-dedicated-exist-p)
           (let ((current-window (selected-window)))
             ;; Remember height.
             (multi-term-dedicated-select)
             (multi-term-dedicated-remember-window-height)
             ;; Close window.
             (if (and (require 'ecb nil t)
                      ecb-activated-window-configuration)
                 ;; Toggle ECB window when ECB window activated.
                 (progn
                   (ecb-deactivate)
                   (ecb-activate))
               ;; Otherwise delete dedicated window.
               (delete-window multi-term-dedicated-window)
               (if (multi-term-window-exist-p current-window)
                   (select-window current-window))))
         (message "`multi-term' window is not exist.")))
     
     (defun multi-term-dedicated-remember-window-height ()
       "Remember window height."
       (let ((win-height (multi-term-current-window-take-height)))
         (if (and (multi-term-dedicated-window-p) ;in `multi-term' window
                  (> win-height 1)
                  (<= win-height multi-term-dedicated-max-window-height))
             (setq multi-term-dedicated-window-height win-height))))
     
     (defun multi-term-dedicated-toggle ()
       "Toggle dedicated `multi-term' window."
       (interactive)
       (if (multi-term-dedicated-exist-p)
           (multi-term-dedicated-close)
         (multi-term-dedicated-open)))
     
     (defun multi-term-dedicated-select ()
       "Select the `multi-term' dedicated window."
       (interactive)
       (if (multi-term-dedicated-exist-p)
           (select-window multi-term-dedicated-window)
         (message "`multi-term' window is not exist.")))
     
     (defun term-send-backward-kill-word ()
       "Backward kill word in term mode."
       (interactive)
       (term-send-raw-string "\C-w"))
     
     (defun term-send-forward-kill-word ()
       "Kill word in term mode."
       (interactive)
       (term-send-raw-string "\ed"))
     
     (defun term-send-backward-word ()
       "Move backward word in term mode."
       (interactive)
       (term-send-raw-string "\eb"))
     
     (defun term-send-forward-word ()
       "Move forward word in term mode."
       (interactive)
       (term-send-raw-string "\ef"))
     
     (defun term-send-reverse-search-history ()
       "Search history reverse."
       (interactive)
       (term-send-raw-string "\C-r"))
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Utilise Functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defun multi-term-internal ()
       "Internal handle for `multi-term' buffer."
       ;; Add customize keystroke with `term-mode-hook'
       (remove-hook 'term-mode-hook 'multi-term-keystroke-setup)
       (add-hook 'term-mode-hook 'multi-term-keystroke-setup)
       ;; Load term mode
       (term-mode)
       (term-char-mode)
       ;; Handle term buffer close
       (multi-term-handle-close)
       ;; Handle `output' variable.
       (setq term-scroll-show-maximum-output multi-term-scroll-show-maximum-output
             term-scroll-to-bottom-on-output multi-term-scroll-to-bottom-on-output)
       ;; Add hook to be sure `term' quit subjob before buffer killed.
       (add-hook 'kill-buffer-hook 'multi-term-kill-buffer-hook))
     
     (defun multi-term-get-buffer (&optional special-shell dedicated-window)
       "Get term buffer.
     If option SPECIAL-SHELL is `non-nil', will use shell from user input.
     If option DEDICATED-WINDOW is `non-nil' will create dedicated `multi-term' window ."
       (with-temp-buffer
         (let ((shell-name (or multi-term-program ;shell name
                               (getenv "SHELL")
                               (getenv "ESHELL")
                               "/bin/sh"))
               term-list-length              ;get length of term list
               index                         ;setup new term index
               term-name)                    ;term name
           (if dedicated-window
               (setq term-name multi-term-dedicated-buffer-name)
             ;; Compute index.
             (setq term-list-length (length (multi-term-list)))
             (setq index (if term-list-length (1+ term-list-length) 1))
             ;; switch to current local directory,
             ;; if in-existence, switch to `multi-term-default-dir'.
             (cd (or default-directory (expand-file-name multi-term-default-dir)))
             ;; adjust value N when max index of term buffer is less than length of term list
             (while (buffer-live-p (get-buffer (format "*%s<%s>*" multi-term-buffer-name index)))
               (setq index (1+ index)))
             (setq term-name (format "%s<%s>" multi-term-buffer-name index)))
           ;; Try get other shell name if `special-shell' is non-nil.
           (if special-shell
               (setq shell-name (read-from-minibuffer "Run program: " shell-name)))
           ;; Make term, details to see function `make-term' in `term.el'.
           (if multi-term-program-switches
               (make-term term-name shell-name nil multi-term-program-switches)
             (make-term term-name shell-name)))))
     
     
     (defun multi-term-handle-close ()
       "Close current term buffer when `exit' from term buffer."
       (when (ignore-errors (get-buffer-process (current-buffer)))
         (set-process-sentinel (get-buffer-process (current-buffer))
                               (lambda (proc change)
                                 (when (string-match "\\(finished\\|exited\\)" change)
                                   (kill-buffer (process-buffer proc)))))))
     
     (defun multi-term-kill-buffer-hook ()
       "Function that hook `kill-buffer-hook'."
       (when (eq major-mode 'term-mode)
         ;; Quit the current subjob
         ;; when have alive process with current term buffer.
         ;; Must do this job BEFORE `multi-term-switch-after-close' action.
         (when (term-check-proc (current-buffer))
           ;; Quit sub-process.
           (term-quit-subjob))
         ;; Remember dedicated window height.
         (multi-term-dedicated-remember-window-height)
         ;; Try to switch other multi-term buffer
         ;; when option `multi-term-switch-after-close' is non-nil.
         (when multi-term-switch-after-close
           (multi-term-switch-internal multi-term-switch-after-close 1))))
     
     (defun multi-term-list ()
       "List term buffers presently active."
       ;; Autload command `remove-if-not'.
       (autoload 'remove-if-not "cl-seq")
       (sort
        (remove-if-not (lambda (b)
                         (setq case-fold-search t)
                         (string-match
                          (format "^\\\*%s<[0-9]+>\\\*$" multi-term-buffer-name)
                          (buffer-name b)))
                       (buffer-list))
        (lambda (a b)
          (< (string-to-number
              (cadr (split-string (buffer-name a) "[<>]")))
             (string-to-number
              (cadr (split-string (buffer-name b)  "[<>]")))))))
     
     (defun multi-term-switch (direction offset)
       "Switch `multi-term' buffers.
     If DIRECTION is `NEXT', switch to the next term.
     If DIRECTION `PREVIOUS', switch to the previous term.
     Option OFFSET for skip OFFSET number term buffer."
       (unless (multi-term-switch-internal direction offset)
         (if multi-term-try-create
             (progn
               (multi-term)
               (message "Create a new `multi-term' buffer."))
           (message "Haven't any `multi-term' buffer exist."))))
     
     (defun multi-term-switch-internal (direction offset)
       "Internal `multi-term' buffers switch function.
     If DIRECTION is `NEXT', switch to the next term.
     If DIRECTION `PREVIOUS', switch to the previous term.
     Option OFFSET for skip OFFSET number term buffer."
       (let (terms this-buffer)
         (setq terms (multi-term-list))
         (if (consp terms)
             (progn
               (setf (cdr (last terms)) terms)
               (setq this-buffer (position (current-buffer) (multi-term-list)))
               (if this-buffer
                   (if (eql direction 'NEXT)
                       (switch-to-buffer (nth (+ this-buffer offset) terms))
                     (switch-to-buffer (nth (+ (- (length (multi-term-list)) offset)
                                               this-buffer) terms)))
                 (switch-to-buffer (car terms)))
               t)
           nil)))
     
     (defun multi-term-keystroke-setup ()
       "Keystroke setup of `term-char-mode'.
     
     By default, the key bindings of `term-char-mode' conflict with user's keystroke.
     So this function unbinds some keys with `term-raw-map',
     and binds some keystroke with `term-raw-map'."
       (let (bind-key bind-command)
         ;; Unbind base key that conflict with user's keys-tokes.
         (dolist (unbind-key term-unbind-key-list)
           (cond
            ((stringp unbind-key) (setq unbind-key (read-kbd-macro unbind-key)))
            ((vectorp unbind-key) nil)
            (t (signal 'wrong-type-argument (list 'array unbind-key))))
           (define-key term-raw-map unbind-key nil))
         ;; Add some i use keys.
         ;; If you don't like my keystroke,
         ;; just modified `term-bind-key-alist'
         (dolist (element term-bind-key-alist)
           (setq bind-key (car element))
           (setq bind-command (cdr element))
           (cond
            ((stringp bind-key) (setq bind-key (read-kbd-macro bind-key)))
            ((vectorp bind-key) nil)
            (t (signal 'wrong-type-argument (list 'array bind-key))))
           (define-key term-raw-map bind-key bind-command))))
     
     (defun multi-term-dedicated-handle-other-window-advice (activate)
       "Handle advice for function `other-window'.
     If ACTIVATE is `non-nil', will enable advice
     `multi-term-dedicated-other-window-advice'.
     Otherwise, disable it."
       (if activate
           (ad-enable-advice 'other-window 'after 'multi-term-dedicated-other-window-advice)
         (ad-disable-advice 'other-window 'after 'multi-term-dedicated-other-window-advice))
       (ad-activate 'other-window))
     
     (defun multi-term-current-window-take-height (&optional window)
       "Return the height the `window' takes up.
     Not the value of `window-height', it returns usable rows available for WINDOW.
     If `window' is nil, get current window."
       (let ((edges (window-edges window)))
         (- (nth 3 edges) (nth 1 edges))))
     
     (defun multi-term-dedicated-get-window ()
       "Get `multi-term' dedicated window."
       (setq multi-term-dedicated-window
             (split-window
              (selected-window)
              (- (multi-term-current-window-take-height) multi-term-dedicated-window-height))))
     
     (defun multi-term-dedicated-get-buffer-name ()
       "Get the buffer name of `multi-term' dedicated window."
       (format "*%s*" multi-term-dedicated-buffer-name))
     
     (defun multi-term-dedicated-exist-p ()
       "Return `non-nil' if `multi-term' dedicated window exist."
       (and (multi-term-buffer-exist-p multi-term-dedicated-buffer)
            (multi-term-window-exist-p multi-term-dedicated-window)))
     
     (defun multi-term-window-exist-p (window)
       "Return `non-nil' if WINDOW exist.
     Otherwise return nil."
       (and window (window-live-p window)))
     
     (defun multi-term-buffer-exist-p (buffer)
       "Return `non-nil' if `BUFFER' exist.
     Otherwise return nil."
       (and buffer (buffer-live-p buffer)))
     
     (defun multi-term-dedicated-window-p ()
       "Return `non-nil' if current window is `multi-term' dedicated window.
     Otherwise return nil."
       (equal (multi-term-dedicated-get-buffer-name) (buffer-name (window-buffer))))
     
     (defun multi-term-window-dedicated-only-one-p ()
       "Only have one non-dedicated window."
       (interactive)
       (let ((window-number 0)
             (dedicated-window-number 0))
         (walk-windows
          (lambda (w)
            (with-selected-window w
              (incf window-number)
              (if (window-dedicated-p w)
                  (incf dedicated-window-number)))))
         (if (and (> dedicated-window-number 0)
                  (= (- window-number dedicated-window-number) 1))
             t nil)))
     
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Advice ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (defadvice delete-other-windows (around multi-term-delete-other-window-advice activate)
       "This is advice to make `multi-term' avoid dedicated window deleted.
     Dedicated window can't deleted by command `delete-other-windows'."
       (let ((multi-term-dedicated-active-p (multi-term-window-exist-p multi-term-dedicated-window)))
         (if multi-term-dedicated-active-p
             (let ((current-window (selected-window)))
               (dolist (win (window-list))
                 (when (and (window-live-p win)
                            (not (eq current-window win))
                            (not (window-dedicated-p win)))
                   (delete-window win))))
           ad-do-it)))
     
     (defadvice delete-window (before multi-term-delete-window-advice activate)
       "Use `delete-window' delete `multi-term' dedicated window.
     Have same effect as command `multi-term-dedicated-close'.
     This advice to remember `multi-term' dedicated window height before deleting."
       ;; Remember window height before deleted.
       (multi-term-dedicated-remember-window-height))
     
     (defadvice pop-to-buffer (before multi-term-pop-to-buffer-advice activate)
       "This advice fix the problem between `pop-to-buffer' and dedicated window.
     By default, function `display-buffer' can't display buffer in selected window
     if current window is `dedicated'.
     
     So function `display-buffer' conflicts with `sr-speedbar' window, because
     `sr-speedbar' window is a `dedicated' window.
     
     That is to say, when current frame just have one `non-dedicated' window,
     any functions that uses `display-buffer' can't split windows
     to display buffer, even when the option `pop-up-windows' is enabled.
     
     And the example function that can induce the problem is `pop-to-buffer'.
     
     This advice will fix this problem when current frame just have one `non-dedicated' window."
       (when (and pop-up-windows                           ;`pop-up-windows' is enable
                  (multi-term-window-dedicated-only-one-p) ;just have one `non-dedicated' window.
                  (multi-term-window-exist-p multi-term-dedicated-window)
                  (not (multi-term-dedicated-window-p))) ;not in `sr-speedbar' window
         (split-window-vertically)
         (windmove-down)))
     
     (defadvice other-window (after multi-term-dedicated-other-window-advice)
       "Default, can use `other-window' select window in cyclic ordering of windows.
     But sometimes we don't want to select `sr-speedbar' window,
     but use `other-window' and just make `multi-term' dedicated
     window as a viewable sidebar.
     
     This advice can make `other-window' skip `multi-term' dedicated window."
       (let ((count (or (ad-get-arg 0) 1)))
         (when (and (multi-term-window-exist-p multi-term-dedicated-window)
                    (eq multi-term-dedicated-window (selected-window)))
           (other-window count))))
     
     (provide 'multi-term)
     
     ;; Local Variables:
     ;; time-stamp-line-limit: 10
     ;; time-stamp-start: "Last-Updated: <"
     ;; time-stamp-end: ">"
     ;; End:
     
     ;;; multi-term.el ends here
     
     ;;; LocalWords:  multi el dir sr Hawley eb ef cd 
   #+end_src

   #+begin_src emacs-lisp
     (setq multi-term-program "/bin/bash")
     
     (global-set-key (kbd "C-c t") 'multi-term-next)
     (global-set-key (kbd "C-c T") 'multi-term) ;; create a new one
   #+end_src

*** dired-details

   #+begin_src emacs-lisp
     ;;; dired-details.el -- make file details hide-able in dired
     
     ;; Copyright (C) 2003-2005 Rob Giardina
     
     ;; Version: 1.3
     ;; Keywords: dired, hide
     ;; Author: Rob Giardina <rob.giardina.ohmmanepadmespam@oracle.com>
     ;; Maintainer: Rob Giardina
     ;; Last updated: Aug 26, 2003
     ;; Contributors: Harold Maier, Klaus Berndl
     
     ;; This file is not part of GNU Emacs.
     
     ;; This is free software; you can redistribute it and/or modify it
     ;; under the terms of the GNU General Public License as published by
     ;; the Free Software Foundation; either version 2, or (at your option)
     ;; any later version.
     ;;
     ;; This is distributed in the hope that it will be useful, but WITHOUT
     ;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
     ;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
     ;; License for more details.
     ;;
     ;; You should have received a copy of the GNU General Public License
     ;; along with GNU Emacs; see the file COPYING.  If not, write to the
     ;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
     ;; Boston, MA 02111-1307, USA.
     
     ;;; Commentary:
     
     ;; `dired-details-hide' makes dired buffers that look like this:
     ;;
     ;;  /private/rgiardin/lispHome:
     ;;  used 1264 available files
     ;;
     ;;  drwxr-xr-x   5 rgiardin g632         512 Jan 19  2003 ..
     ;;  -rw-r--r--   1 rgiardin svrtech     4141 Aug 23 17:07 dired-details.el
     ;;  -rw-r--r--   1 rgiardin svrtech     4141 Aug 23 17:07 my-really-really-long-I-mean-really-long-filename.el
     ;;  -rw-r--r--   1 rgiardin svrtech       56 Aug 23 17:07 linked-file.el -> /var/tmp/checkouts/linked-file.el
     ;;
     ;; look like this:
     ;;
     ;;  /private/rgiardin/lispHome/emacs.config:
     ;;  used 1264 available files
     ;;
     ;;  [...] ..
     ;;  [...] dired-details.el
     ;;  [...] my-really-really-long-I-mean-really-long-filename.el
     ;;  [...] linked-file.el -> [...]
     ;;
     ;; The function `dired-details-toggle' will toggle details on and off.
     ;;
     ;;
     ;; INSTALLATION:
     ;;
     ;; To apply `dired-details-hide' to all new dired buffers, add the
     ;; following to your .emacs:
     ;;
     ;; (require 'dired-details)
     ;; (dired-details-install)
     ;;
     ;; This also binds the following keys in dired buffers:
     ;;
     ;;   ) - dired-details-show
     ;;   ( - dired-details-hide
     ;;
     ;; CHANGES:
     ;;
     ;; * 1.1: Setup hide and show keybindings earlier than the first hide.
     ;; * 1.1: add dired-details-initially-hide customization as suggested by Harold Maier
     ;; * 1.2: extensive change to support subdirs in dired buffers
     ;; * 1.2.1: respect current hidden state (not initial state) when inserting subdirs
     ;; * 1.3: dired-details-toggle and customization support added by Klaus Berndl
     ;;
     ;; TODO:
     ;;
     ;; * add a hook for dired-add-file to hide new entries as necessary
     ;;
     
     ;;; customizable vars
     
     (defgroup dired-details nil
       "Settings for the dired-details package."
       :group 'dired
       :prefix "dired-details-")
     
     ;[...]
     (defcustom dired-details-hidden-string ""
       "*This string will be shown in place of file details and symbolic links."
       :group 'dired-details
       :type 'string)
     
     (defcustom dired-details-hide-link-targets t
       "*Hide symbolic link target paths."
       :group 'dired-details
       :type 'boolean)
     
     (defcustom dired-details-initially-hide t
       "*Hide dired details on entry to dired buffers."
       :group 'dired-details
       :type 'boolean)
     
     
     ;;; implementation
     
     (defvar dired-details-debug nil)
     
     (defvar dired-details-internal-overlay-list nil)
     (make-variable-buffer-local 'dired-details-internal-overlay-list)
     
     (defvar dired-details-state nil
       "Three possible values: nil (has not been set), 'hidden (details are
     hidden), 'shown (details are visible).")
     (make-variable-buffer-local 'dired-details-state)
     
     (defun dired-details-install()
       (eval-after-load "dired"
         '(progn
            (add-hook 'dired-after-readin-hook 'dired-details-activate)
           
            (define-key dired-mode-map "(" 'dired-details-hide)
            (define-key dired-mode-map ")" 'dired-details-show)
     
           (defadvice dired-revert (before remember-the-details activate)
             (dired-details-delete-overlays)))))
       
     (defun dired-details-activate()
       "Set up dired-details in the current dired buffer. Called by
     dired-after-readin-hook on initial display and when a subdirectory is
     inserted (with `i')."
       ;;if a state has been chosen in this buffer, respect it
       (if dired-details-state
           (when (eq 'hidden dired-details-state)
             (dired-details-hide))
         ;;otherwise, use the default state
         (when dired-details-initially-hide
           (dired-details-hide))))
     
     (defun dired-details-delete-overlays()
       (mapc '(lambda(list) (mapc 'delete-overlay
                                  (cdr list)))
             dired-details-internal-overlay-list)
       (setq dired-details-internal-overlay-list nil))
     
     (defun dired-details-toggle( &optional arg default-too )
       "Toggle visibility of dired details.
     With positive prefix argument ARG hide the details, with negative
     show them."
       (interactive "P")
       (let ((hide (if (null arg)
                       (not (eq 'hidden dired-details-state))
                     (> (prefix-numeric-value arg) 0))))
         (if default-too
             (setq dired-details-initially-hide hide))
         (if hide (dired-details-hide)
           (dired-details-show))))
     
     (defun dired-details-hide()
       "Make an invisible, evaporable overlay for each file-line's details
     in this dired buffer."
       (interactive)
       (unless (memq major-mode '(dired-mode vc-dired-mode))
         (error "dired-details-hide can only be called in dired mode"))
     
       (when dired-details-debug
         (let ((b (get-buffer-create "dired-details-debug")))
           (append-to-buffer b (point) (point-max))))
         
       ;;NOTE - we call this even if we're already hidden. There may be a
       ;;new subdirectory inserted that we have to deal with. Pre-existing
       ;;subdirectories will reuse their cached overlays.
       (save-excursion
         (save-restriction
           (widen)
           ;;hide each displayed subdirectory
           (mapc
            '(lambda( dir-and-pos )
               (let ((cached-overlays (assoc (car dir-and-pos)
                                             dired-details-internal-overlay-list)))
                 (if cached-overlays
                     ;;reuse the existing overlays
                     (dired-details-frob-overlays t)
                   ;;no existing overlays for this subdir, make 'em
                   (let ((cache (list (car dir-and-pos)))
                         (subdir-start (cdr dir-and-pos))
                         (subdir-end (1- (dired-get-subdir-max dir-and-pos))))
                     (goto-char subdir-start)
                     (dired-goto-next-file)
                     (while (< (point) subdir-end)
                       (dired-details-make-current-line-overlay cache)
                       (dired-next-line 1))
                     (setq dired-details-internal-overlay-list
                           (cons cache dired-details-internal-overlay-list))))))
              dired-subdir-alist)))
         (setq dired-details-state 'hidden))
     
     (defun dired-details-show()
       "Show whatever details a call to `dired-details-hide' may have
     hidden in this buffer."
       (interactive)
       (dired-details-frob-overlays nil)
       (setq dired-details-state 'shown))
     
     (defun dired-details-make-current-line-overlay( cache )
       (let ((details ;hide the flags, size, owner, date, etc.
              (make-overlay
               (+ 2 (progn (beginning-of-line) (point)))
               (progn (dired-move-to-filename)(point))))
              
             (ln-target ;hide the destination of a symbolic link
              (when dired-details-hide-link-targets
                (if (progn (beginning-of-line)
                           (search-forward-regexp
                            "-> \\(.*\\)"
                            (save-excursion (end-of-line)(point)) t))
                    (make-overlay (match-beginning 1) (match-end 1))))))
     
         ;;delete the overlay when the dired line goes away
         (overlay-put details 'evaporate t)
         (dired-details-hide-overlay details)
     
         (when ln-target
           (overlay-put ln-target 'evaporate t)
           (dired-details-hide-overlay ln-target))
     
         (setcdr cache (append (if ln-target
                                   (list ln-target details)
                                 (list details))
                               (cdr cache)))))
     
     (defun dired-details-hide-overlay( o )
       (overlay-put o 'invisible t)
       (overlay-put o 'before-string dired-details-hidden-string))
     
     (defun dired-details-show-overlay( o )
       (overlay-put o 'invisible nil)
       (overlay-put o 'before-string nil))
     
     (defun dired-details-frob-overlays( hide )
       (if dired-details-internal-overlay-list
           (mapc '(lambda(list)
                    (mapc (if hide 'dired-details-hide-overlay 'dired-details-show-overlay)
                          (cdr list)))
                 dired-details-internal-overlay-list)))
     
     (provide 'dired-details)
     
     ;;; dired-details.el ends here
   #+end_src

   #+begin_src emacs-lisp
     (require 'dired-details)
     (dired-details-install)
   #+end_src

*** smart-tab

   #+begin_src emacs-lisp
     ;;; smart-tab.el --- Intelligent tab completion and indentation.
     
     ;; This file is NOT part of GNU Emacs.
     
     ;; Copyright (C) 2009-2011 John SJ Anderson,
     ;;                         Sebastien Rocca Serra,
     ;;                         Daniel Hackney
     ;; Author: John SJ Anderson <genehack@genehack.org>,
     ;;         Sebastien Rocca Serra <sroccaserra@gmail.com>,
     ;;         Daniel Hackney <dan@haxney.org>
     ;; Maintainer: John SJ Anderson <genehack@genehack.org>
     ;; Keywords: extensions
     ;; Created: 2009-05-24
     ;; URL: http://github.com/genehack/smart-tab/tree/master
     ;; Version: 0.3
     ;;
     ;; This program is free software; you can redistribute it and/or modify it under
     ;; the terms of the GNU General Public License as published by the Free Software
     ;; Foundation; either version 3, or (at your option) any later version.
     ;;
     ;; This program is distributed in the hope that it will be useful, but WITHOUT
     ;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     ;; FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
     ;; details.
     ;;
     ;; You should have received a copy of the GNU General Public License
     ;; along with this program. If not, see <http://www.gnu.org/licenses/>.
     
     ;;; Commentary:
     
     ;; INSTALL
     ;;
     ;; To install, put this file along your Emacs-Lisp `load-path' and add
     ;; the following into your ~/.emacs startup file or set
     ;; `global-smart-tab-mode' to non-nil with customize:
     ;;
     ;;     (require 'smart-tab)
     ;;     (global-smart-tab-mode 1)
     ;;
     ;; DESCRIPTION
     ;;
     ;; Try to 'do the smart thing' when tab is pressed. `smart-tab'
     ;; attempts to expand the text before the point or indent the current
     ;; line or selection.
     ;;
     ;; See <http://www.emacswiki.org/cgi-bin/wiki/TabCompletion#toc2>. There are a
     ;; number of available customizations on that page.
     ;;
     ;; Features that might be required by this library:
     ;;
     ;;   `easy-mmmode'
     
     ;;; Change Log:
     
     ;;; Code:
     
     (require 'easy-mmode)
     
     (defgroup smart-tab nil
       "Options for `smart-tab-mode'.")
     
     (defcustom smart-tab-using-hippie-expand nil
       "Use `hippie-expand' to expand text.
     Use either `hippie-expand' or `dabbrev-expand' for expanding text
     when we don't have to indent."
       :type '(choice
               (const :tag "hippie-expand" t)
               (const :tag "dabbrev-expand" nil))
       :group 'smart-tab)
     
     (defcustom smart-tab-completion-functions-alist
       '((emacs-lisp-mode . lisp-complete-symbol)
         (text-mode       . dabbrev-completion))
       "A-list of major modes in which to use a mode specific completion function.
     If current major mode is not found in this alist, fall back to
     `hippie-expand' or `dabbrev-expand', depending on the value of
     `smart-tab-using-hippie-expand'"
       :type '(alist :key-type (symbol :tag "Major mode")
                     :value-type (function :tag "Completion function to use in this mode"))
       :group 'smart-tab)
     
     (defcustom smart-tab-disabled-major-modes '(org-mode term-mode)
       "List of major modes that should not use `smart-tab'."
       :type 'sexp
       :group 'smart-tab)
     
     (defun smart-tab-call-completion-function ()
       "Get a completion function according to current major mode."
       (let ((completion-function
              (cdr (assq major-mode smart-tab-completion-functions-alist))))
         (if (null completion-function)
             (if (and (not (minibufferp))
                      (memq 'auto-complete-mode minor-mode-list)
                      auto-complete-mode)
                 (ac-start :force-init t)
               (if smart-tab-using-hippie-expand
                   (hippie-expand nil)
                 (dabbrev-expand nil)))
           (funcall completion-function))))
     
     (defun smart-tab-must-expand (&optional prefix)
       "If PREFIX is \\[universal-argument] or the mark is active, do not expand.
     Otherwise, uses the user's preferred expansion function to expand
     the text at point."
       (unless (or (consp prefix)
                   (use-region-p))
         (looking-at "\\_>")))
     
     (defun smart-tab-default ()
       "Indent region if mark is active, or current line otherwise."
       (interactive)
       (if (use-region-p)
           (indent-region (region-beginning)
                          (region-end))
         (indent-for-tab-command)))
     
     ;;;###autoload
     (defun smart-tab (&optional prefix)
       "Try to 'do the smart thing' when tab is pressed.
     `smart-tab' attempts to expand the text before the point or
     indent the current line or selection.
     
     In a regular buffer, `smart-tab' will attempt to expand with
     either `hippie-expand' or `dabbrev-expand', depending on the
     value of `smart-tab-using-hippie-expand'. Alternatively, if
     `auto-complete-mode' is enabled in the current buffer,
     `auto-complete' will be used to attempt expansion. If the mark is
     active, or PREFIX is \\[universal-argument], then `smart-tab'
     will indent the region or the current line (if the mark is not
     active)."
       (interactive "P")
       (if (smart-tab-must-expand prefix)
           (smart-tab-call-completion-function))
       (smart-tab-default))
     
     ;;;###autoload
     (defun smart-tab-mode-on ()
       "Turn on `smart-tab-mode'."
         (smart-tab-mode 1))
     
     (defun smart-tab-mode-off ()
       "Turn off `smart-tab-mode'."
       (smart-tab-mode -1))
     
     ;;;###autoload
     (define-minor-mode smart-tab-mode
       "Enable `smart-tab' to be used in place of tab.
     
     With no argument, this command toggles the mode.
     Non-null prefix argument turns on the mode.
     Null prefix argument turns off the mode."
       :lighter " Smrt"
       :group 'smart-tab
       :require 'smart-tab
       :keymap '(("\t" . smart-tab)
                 ([(tab)] . smart-tab))
       (if smart-tab-mode
           (progn
             ;; Don't start `smart-tab-mode' when in the minibuffer or a read-only
             ;; buffer.
             (when (or (minibufferp)
                       buffer-read-only
                       (member major-mode smart-tab-disabled-major-modes))
               (smart-tab-mode-off)))))
     
     ;;;###autoload
     (define-globalized-minor-mode global-smart-tab-mode
       smart-tab-mode
       smart-tab-mode-on
       :group 'smart-tab)
     
     (provide 'smart-tab)
     
     ;;; smart-tab.el ends here
     
     (global-smart-tab-mode 1)
   #+end_src

*** jump
   
   #+begin_src emacs-lisp
     ;;create marks in buffer so you can jump between them using these functions
     (defvar na-cm-ring nil
       "List of markers that points to buffer-positions.")
     (defun na-cm-same-pos ()
       (and na-cm-ring
            (equal (point) (marker-position (car na-cm-ring)))
            (equal (current-buffer) (marker-buffer (car na-cm-ring)))))
     
     (defun na-cm-save-point (arg)
       (interactive "P")
       (if (or (and arg (< (prefix-numeric-value arg) 0))
               (na-cm-same-pos))
           (progn
             (setq na-cm-ring (cdr na-cm-ring))
             (message "Point deleted from stack (%d left)" (length na-cm-ring)))
         (setq na-cm-ring (cons (point-marker) na-cm-ring))
         (message "Point saved (%d saved)" (length na-cm-ring))))
     
     (defun na-cm-rotate (num)
       "If point differ from first position in ring then goto that.
     Otherwise rotate the ring of points and go to the now newest point in the ring"
       (interactive "P")
       (if (not na-cm-ring)
           (error "No points saved!"))
       (setq num
             (if (null num) (if (na-cm-same-pos) 1 0)
               (prefix-numeric-value num)))
       (setq num (mod num (length na-cm-ring)))
       (let ((top nil))
         (while (> num 0)
           (setq top (cons (car na-cm-ring) top))
           (setq na-cm-ring (cdr na-cm-ring))
           (setq num (1- num)))
         (setq na-cm-ring (append na-cm-ring (nreverse top)))
         (if (marker-position (car na-cm-ring))
             (progn
               (switch-to-buffer (marker-buffer (car na-cm-ring)))
               (goto-char (car na-cm-ring)))
           (setq na-cm-ring (cdr na-cm-ring))
           (na-cm-rotate 1))))
   #+end_src

*** git

   #+begin_src emacs-lisp
     ;;; git.el --- A user interface for git
     
     ;; Copyright (C) 2005, 2006, 2007, 2008, 2009 Alexandre Julliard <julliard@winehq.org>
     
     ;; Version: 1.0
     
     ;; This program is free software; you can redistribute it and/or
     ;; modify it under the terms of the GNU General Public License as
     ;; published by the Free Software Foundation; either version 2 of
     ;; the License, or (at your option) any later version.
     ;;
     ;; This program is distributed in the hope that it will be
     ;; useful, but WITHOUT ANY WARRANTY; without even the implied
     ;; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     ;; PURPOSE.  See the GNU General Public License for more details.
     ;;
     ;; You should have received a copy of the GNU General Public
     ;; License along with this program; if not, write to the Free
     ;; Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     ;; MA 02111-1307 USA
     
     ;;; Commentary:
     
     ;; This file contains an interface for the git version control
     ;; system. It provides easy access to the most frequently used git
     ;; commands. The user interface is as far as possible identical to
     ;; that of the PCL-CVS mode.
     ;;
     ;; To install: put this file on the load-path and place the following
     ;; in your .emacs file:
     ;;
     ;;    (require 'git)
     ;;
     ;; To start: `M-x git-status'
     ;;
     ;; TODO
     ;;  - diff against other branch
     ;;  - renaming files from the status buffer
     ;;  - creating tags
     ;;  - fetch/pull
     ;;  - revlist browser
     ;;  - git-show-branch browser
     ;;
     
     ;;; Compatibility:
     ;;
     ;; This file works on GNU Emacs 21 or later. It may work on older
     ;; versions but this is not guaranteed.
     ;;
     ;; It may work on XEmacs 21, provided that you first install the ewoc
     ;; and log-edit packages.
     ;;
     
     (eval-when-compile (require 'cl))
     (require 'ewoc)
     (require 'log-edit)
     (require 'easymenu)
     
     
     ;;;; Customizations
     ;;;; ------------------------------------------------------------
     
     (defgroup git nil
       "A user interface for the git versioning system."
       :group 'tools)
     
     (defcustom git-committer-name nil
       "User name to use for commits.
     The default is to fall back to the repository config,
     then to `add-log-full-name' and then to `user-full-name'."
       :group 'git
       :type '(choice (const :tag "Default" nil)
                      (string :tag "Name")))
     
     (defcustom git-committer-email nil
       "Email address to use for commits.
     The default is to fall back to the git repository config,
     then to `add-log-mailing-address' and then to `user-mail-address'."
       :group 'git
       :type '(choice (const :tag "Default" nil)
                      (string :tag "Email")))
     
     (defcustom git-commits-coding-system nil
       "Default coding system for the log message of git commits."
       :group 'git
       :type '(choice (const :tag "From repository config" nil)
                      (coding-system)))
     
     (defcustom git-append-signed-off-by nil
       "Whether to append a Signed-off-by line to the commit message before editing."
       :group 'git
       :type 'boolean)
     
     (defcustom git-reuse-status-buffer t
       "Whether `git-status' should try to reuse an existing buffer
     if there is already one that displays the same directory."
       :group 'git
       :type 'boolean)
     
     (defcustom git-per-dir-ignore-file ".gitignore"
       "Name of the per-directory ignore file."
       :group 'git
       :type 'string)
     
     (defcustom git-show-uptodate nil
       "Whether to display up-to-date files."
       :group 'git
       :type 'boolean)
     
     (defcustom git-show-ignored nil
       "Whether to display ignored files."
       :group 'git
       :type 'boolean)
     
     (defcustom git-show-unknown t
       "Whether to display unknown files."
       :group 'git
       :type 'boolean)
     
     
     (defface git-status-face
       '((((class color) (background light)) (:foreground "purple"))
         (((class color) (background dark)) (:foreground "salmon")))
       "Git mode face used to highlight added and modified files."
       :group 'git)
     
     (defface git-unmerged-face
       '((((class color) (background light)) (:foreground "red" :bold t))
         (((class color) (background dark)) (:foreground "red" :bold t)))
       "Git mode face used to highlight unmerged files."
       :group 'git)
     
     (defface git-unknown-face
       '((((class color) (background light)) (:foreground "goldenrod" :bold t))
         (((class color) (background dark)) (:foreground "goldenrod" :bold t)))
       "Git mode face used to highlight unknown files."
       :group 'git)
     
     (defface git-uptodate-face
       '((((class color) (background light)) (:foreground "grey60"))
         (((class color) (background dark)) (:foreground "grey40")))
       "Git mode face used to highlight up-to-date files."
       :group 'git)
     
     (defface git-ignored-face
       '((((class color) (background light)) (:foreground "grey60"))
         (((class color) (background dark)) (:foreground "grey40")))
       "Git mode face used to highlight ignored files."
       :group 'git)
     
     (defface git-mark-face
       '((((class color) (background light)) (:foreground "red" :bold t))
         (((class color) (background dark)) (:foreground "tomato" :bold t)))
       "Git mode face used for the file marks."
       :group 'git)
     
     (defface git-header-face
       '((((class color) (background light)) (:foreground "blue"))
         (((class color) (background dark)) (:foreground "blue")))
       "Git mode face used for commit headers."
       :group 'git)
     
     (defface git-separator-face
       '((((class color) (background light)) (:foreground "brown"))
         (((class color) (background dark)) (:foreground "brown")))
       "Git mode face used for commit separator."
       :group 'git)
     
     (defface git-permission-face
       '((((class color) (background light)) (:foreground "green" :bold t))
         (((class color) (background dark)) (:foreground "green" :bold t)))
       "Git mode face used for permission changes."
       :group 'git)
     
     
     ;;;; Utilities
     ;;;; ------------------------------------------------------------
     
     (defconst git-log-msg-separator "--- log message follows this line ---")
     
     (defvar git-log-edit-font-lock-keywords
       `(("^\\(Author:\\|Date:\\|Merge:\\|Signed-off-by:\\)\\(.*\\)$"
          (1 font-lock-keyword-face)
          (2 font-lock-function-name-face))
         (,(concat "^\\(" (regexp-quote git-log-msg-separator) "\\)$")
          (1 font-lock-comment-face))))
     
     (defun git-get-env-strings (env)
       "Build a list of NAME=VALUE strings from a list of environment strings."
       (mapcar (lambda (entry) (concat (car entry) "=" (cdr entry))) env))
     
     (defun git-call-process (buffer &rest args)
       "Wrapper for call-process that sets environment strings."
       (apply #'call-process "git" nil buffer nil args))
     
     (defun git-call-process-display-error (&rest args)
       "Wrapper for call-process that displays error messages."
       (let* ((dir default-directory)
              (buffer (get-buffer-create "*Git Command Output*"))
              (ok (with-current-buffer buffer
                    (let ((default-directory dir)
                          (buffer-read-only nil))
                      (erase-buffer)
                      (eq 0 (apply #'git-call-process (list buffer t) args))))))
         (unless ok (display-message-or-buffer buffer))
         ok))
     
     (defun git-call-process-string (&rest args)
       "Wrapper for call-process that returns the process output as a string,
     or nil if the git command failed."
       (with-temp-buffer
         (and (eq 0 (apply #'git-call-process t args))
              (buffer-string))))
     
     (defun git-call-process-string-display-error (&rest args)
       "Wrapper for call-process that displays error message and returns
     the process output as a string, or nil if the git command failed."
       (with-temp-buffer
         (if (eq 0 (apply #'git-call-process (list t t) args))
             (buffer-string)
           (display-message-or-buffer (current-buffer))
           nil)))
     
     (defun git-run-process-region (buffer start end program args)
       "Run a git process with a buffer region as input."
       (let ((output-buffer (current-buffer))
             (dir default-directory))
         (with-current-buffer buffer
           (cd dir)
           (apply #'call-process-region start end program
                  nil (list output-buffer t) nil args))))
     
     (defun git-run-command-buffer (buffer-name &rest args)
       "Run a git command, sending the output to a buffer named BUFFER-NAME."
       (let ((dir default-directory)
             (buffer (get-buffer-create buffer-name)))
         (message "Running git %s..." (car args))
         (with-current-buffer buffer
           (let ((default-directory dir)
                 (buffer-read-only nil))
             (erase-buffer)
             (apply #'git-call-process buffer args)))
         (message "Running git %s...done" (car args))
         buffer))
     
     (defun git-run-command-region (buffer start end env &rest args)
       "Run a git command with specified buffer region as input."
       (with-temp-buffer
         (if (eq 0 (if env
                       (git-run-process-region
                        buffer start end "env"
                        (append (git-get-env-strings env) (list "git") args))
                     (git-run-process-region buffer start end "git" args)))
             (buffer-string)
           (display-message-or-buffer (current-buffer))
           nil)))
     
     (defun git-run-hook (hook env &rest args)
       "Run a git hook and display its output if any."
       (let ((dir default-directory)
             (hook-name (expand-file-name (concat ".git/hooks/" hook))))
         (or (not (file-executable-p hook-name))
             (let (status (buffer (get-buffer-create "*Git Hook Output*")))
               (with-current-buffer buffer
                 (erase-buffer)
                 (cd dir)
                 (setq status
                       (if env
                           (apply #'call-process "env" nil (list buffer t) nil
                                  (append (git-get-env-strings env) (list hook-name) args))
                         (apply #'call-process hook-name nil (list buffer t) nil args))))
               (display-message-or-buffer buffer)
               (eq 0 status)))))
     
     (defun git-get-string-sha1 (string)
       "Read a SHA1 from the specified string."
       (and string
            (string-match "[0-9a-f]\\{40\\}" string)
            (match-string 0 string)))
     
     (defun git-get-committer-name ()
       "Return the name to use as GIT_COMMITTER_NAME."
       ; copied from log-edit
       (or git-committer-name
           (git-config "user.name")
           (and (boundp 'add-log-full-name) add-log-full-name)
           (and (fboundp 'user-full-name) (user-full-name))
           (and (boundp 'user-full-name) user-full-name)))
     
     (defun git-get-committer-email ()
       "Return the email address to use as GIT_COMMITTER_EMAIL."
       ; copied from log-edit
       (or git-committer-email
           (git-config "user.email")
           (and (boundp 'add-log-mailing-address) add-log-mailing-address)
           (and (fboundp 'user-mail-address) (user-mail-address))
           (and (boundp 'user-mail-address) user-mail-address)))
     
     (defun git-get-commits-coding-system ()
       "Return the coding system to use for commits."
       (let ((repo-config (git-config "i18n.commitencoding")))
         (or git-commits-coding-system
             (and repo-config
                  (fboundp 'locale-charset-to-coding-system)
                  (locale-charset-to-coding-system repo-config))
           'utf-8)))
     
     (defun git-get-logoutput-coding-system ()
       "Return the coding system used for git-log output."
       (let ((repo-config (or (git-config "i18n.logoutputencoding")
                              (git-config "i18n.commitencoding"))))
         (or git-commits-coding-system
             (and repo-config
                  (fboundp 'locale-charset-to-coding-system)
                  (locale-charset-to-coding-system repo-config))
           'utf-8)))
     
     (defun git-escape-file-name (name)
       "Escape a file name if necessary."
       (if (string-match "[\n\t\"\\]" name)
           (concat "\""
                   (mapconcat (lambda (c)
                        (case c
                          (?\n "\\n")
                          (?\t "\\t")
                          (?\\ "\\\\")
                          (?\" "\\\"")
                          (t (char-to-string c))))
                      name "")
                   "\"")
         name))
     
     (defun git-success-message (text files)
       "Print a success message after having handled FILES."
       (let ((n (length files)))
         (if (equal n 1)
             (message "%s %s" text (car files))
           (message "%s %d files" text n))))
     
     (defun git-get-top-dir (dir)
       "Retrieve the top-level directory of a git tree."
       (let ((cdup (with-output-to-string
                     (with-current-buffer standard-output
                       (cd dir)
                       (unless (eq 0 (git-call-process t "rev-parse" "--show-cdup"))
                         (error "cannot find top-level git tree for %s." dir))))))
         (expand-file-name (concat (file-name-as-directory dir)
                                   (car (split-string cdup "\n"))))))
     
     ;stolen from pcl-cvs
     (defun git-append-to-ignore (file)
       "Add a file name to the ignore file in its directory."
       (let* ((fullname (expand-file-name file))
              (dir (file-name-directory fullname))
              (name (file-name-nondirectory fullname))
              (ignore-name (expand-file-name git-per-dir-ignore-file dir))
              (created (not (file-exists-p ignore-name))))
       (save-window-excursion
         (set-buffer (find-file-noselect ignore-name))
         (goto-char (point-max))
         (unless (zerop (current-column)) (insert "\n"))
         (insert "/" name "\n")
         (sort-lines nil (point-min) (point-max))
         (save-buffer))
       (when created
         (git-call-process nil "update-index" "--add" "--" (file-relative-name ignore-name)))
       (git-update-status-files (list (file-relative-name ignore-name)))))
     
     ; propertize definition for XEmacs, stolen from erc-compat
     (eval-when-compile
       (unless (fboundp 'propertize)
         (defun propertize (string &rest props)
           (let ((string (copy-sequence string)))
             (while props
               (put-text-property 0 (length string) (nth 0 props) (nth 1 props) string)
               (setq props (cddr props)))
             string))))
     
     ;;;; Wrappers for basic git commands
     ;;;; ------------------------------------------------------------
     
     (defun git-rev-parse (rev)
       "Parse a revision name and return its SHA1."
       (git-get-string-sha1
        (git-call-process-string "rev-parse" rev)))
     
     (defun git-config (key)
       "Retrieve the value associated to KEY in the git repository config file."
       (let ((str (git-call-process-string "config" key)))
         (and str (car (split-string str "\n")))))
     
     (defun git-symbolic-ref (ref)
       "Wrapper for the git-symbolic-ref command."
       (let ((str (git-call-process-string "symbolic-ref" ref)))
         (and str (car (split-string str "\n")))))
     
     (defun git-update-ref (ref newval &optional oldval reason)
       "Update a reference by calling git-update-ref."
       (let ((args (and oldval (list oldval))))
         (when newval (push newval args))
         (push ref args)
         (when reason
          (push reason args)
          (push "-m" args))
         (unless newval (push "-d" args))
         (apply 'git-call-process-display-error "update-ref" args)))
     
     (defun git-for-each-ref (&rest specs)
       "Return a list of refs using git-for-each-ref.
     Each entry is a cons of (SHORT-NAME . FULL-NAME)."
       (let (refs)
         (with-temp-buffer
           (apply #'git-call-process t "for-each-ref" "--format=%(refname)" specs)
           (goto-char (point-min))
           (while (re-search-forward "^[^/\n]+/[^/\n]+/\\(.+\\)$" nil t)
             (push (cons (match-string 1) (match-string 0)) refs)))
         (nreverse refs)))
     
     (defun git-read-tree (tree &optional index-file)
       "Read a tree into the index file."
       (let ((process-environment
              (append (and index-file (list (concat "GIT_INDEX_FILE=" index-file))) process-environment)))
         (apply 'git-call-process-display-error "read-tree" (if tree (list tree)))))
     
     (defun git-write-tree (&optional index-file)
       "Call git-write-tree and return the resulting tree SHA1 as a string."
       (let ((process-environment
              (append (and index-file (list (concat "GIT_INDEX_FILE=" index-file))) process-environment)))
         (git-get-string-sha1
          (git-call-process-string-display-error "write-tree"))))
     
     (defun git-commit-tree (buffer tree parent)
       "Create a commit and possibly update HEAD.
     Create a commit with the message in BUFFER using the tree with hash TREE.
     Use PARENT as the parent of the new commit. If PARENT is the current \"HEAD\",
     update the \"HEAD\" reference to the new commit."
       (let ((author-name (git-get-committer-name))
             (author-email (git-get-committer-email))
             (subject "commit (initial): ")
             author-date log-start log-end args coding-system-for-write)
         (when parent
           (setq subject "commit: ")
           (push "-p" args)
           (push parent args))
         (with-current-buffer buffer
           (goto-char (point-min))
           (if
               (setq log-start (re-search-forward (concat "^" (regexp-quote git-log-msg-separator) "\n") nil t))
               (save-restriction
                 (narrow-to-region (point-min) log-start)
                 (goto-char (point-min))
                 (when (re-search-forward "^Author: +\\(.*?\\) *<\\(.*\\)> *$" nil t)
                   (setq author-name (match-string 1)
                         author-email (match-string 2)))
                 (goto-char (point-min))
                 (when (re-search-forward "^Date: +\\(.*\\)$" nil t)
                   (setq author-date (match-string 1)))
                 (goto-char (point-min))
                 (when (re-search-forward "^Merge: +\\(.*\\)" nil t)
                   (setq subject "commit (merge): ")
                   (dolist (parent (split-string (match-string 1) " +" t))
                     (push "-p" args)
                     (push parent args))))
             (setq log-start (point-min)))
           (setq log-end (point-max))
           (goto-char log-start)
           (when (re-search-forward ".*$" nil t)
             (setq subject (concat subject (match-string 0))))
           (setq coding-system-for-write buffer-file-coding-system))
         (let ((commit
                (git-get-string-sha1
                 (let ((env `(("GIT_AUTHOR_NAME" . ,author-name)
                              ("GIT_AUTHOR_EMAIL" . ,author-email)
                              ("GIT_COMMITTER_NAME" . ,(git-get-committer-name))
                              ("GIT_COMMITTER_EMAIL" . ,(git-get-committer-email)))))
                   (when author-date (push `("GIT_AUTHOR_DATE" . ,author-date) env))
                   (apply #'git-run-command-region
                          buffer log-start log-end env
                          "commit-tree" tree (nreverse args))))))
           (when commit (git-update-ref "HEAD" commit parent subject))
           commit)))
     
     (defun git-empty-db-p ()
       "Check if the git db is empty (no commit done yet)."
       (not (eq 0 (git-call-process nil "rev-parse" "--verify" "HEAD"))))
     
     (defun git-get-merge-heads ()
       "Retrieve the merge heads from the MERGE_HEAD file if present."
       (let (heads)
         (when (file-readable-p ".git/MERGE_HEAD")
           (with-temp-buffer
             (insert-file-contents ".git/MERGE_HEAD" nil nil nil t)
             (goto-char (point-min))
             (while (re-search-forward "[0-9a-f]\\{40\\}" nil t)
               (push (match-string 0) heads))))
         (nreverse heads)))
     
     (defun git-get-commit-description (commit)
       "Get a one-line description of COMMIT."
       (let ((coding-system-for-read (git-get-logoutput-coding-system)))
         (let ((descr (git-call-process-string "log" "--max-count=1" "--pretty=oneline" commit)))
           (if (and descr (string-match "\\`\\([0-9a-f]\\{40\\}\\) *\\(.*\\)$" descr))
               (concat (substring (match-string 1 descr) 0 10) " - " (match-string 2 descr))
             descr))))
     
     ;;;; File info structure
     ;;;; ------------------------------------------------------------
     
     ; fileinfo structure stolen from pcl-cvs
     (defstruct (git-fileinfo
                 (:copier nil)
                 (:constructor git-create-fileinfo (state name &optional old-perm new-perm rename-state orig-name marked))
                 (:conc-name git-fileinfo->))
       marked              ;; t/nil
       state               ;; current state
       name                ;; file name
       old-perm new-perm   ;; permission flags
       rename-state        ;; rename or copy state
       orig-name           ;; original name for renames or copies
       needs-update        ;; whether file needs to be updated
       needs-refresh)      ;; whether file needs to be refreshed
     
     (defvar git-status nil)
     
     (defun git-set-fileinfo-state (info state)
       "Set the state of a file info."
       (unless (eq (git-fileinfo->state info) state)
         (setf (git-fileinfo->state info) state
               (git-fileinfo->new-perm info) (git-fileinfo->old-perm info)
               (git-fileinfo->rename-state info) nil
               (git-fileinfo->orig-name info) nil
               (git-fileinfo->needs-update info) nil
               (git-fileinfo->needs-refresh info) t)))
     
     (defun git-status-filenames-map (status func files &rest args)
       "Apply FUNC to the status files names in the FILES list.
     The list must be sorted."
       (when files
         (let ((file (pop files))
               (node (ewoc-nth status 0)))
           (while (and file node)
             (let* ((info (ewoc-data node))
                    (name (git-fileinfo->name info)))
               (if (string-lessp name file)
                   (setq node (ewoc-next status node))
                 (if (string-equal name file)
                     (apply func info args))
                 (setq file (pop files))))))))
     
     (defun git-set-filenames-state (status files state)
       "Set the state of a list of named files. The list must be sorted"
       (when files
         (git-status-filenames-map status #'git-set-fileinfo-state files state)
         (unless state  ;; delete files whose state has been set to nil
           (ewoc-filter status (lambda (info) (git-fileinfo->state info))))))
     
     (defun git-state-code (code)
       "Convert from a string to a added/deleted/modified state."
       (case (string-to-char code)
         (?M 'modified)
         (?? 'unknown)
         (?A 'added)
         (?D 'deleted)
         (?U 'unmerged)
         (?T 'modified)
         (t nil)))
     
     (defun git-status-code-as-string (code)
       "Format a git status code as string."
       (case code
         ('modified (propertize "Modified" 'face 'git-status-face))
         ('unknown  (propertize "Unknown " 'face 'git-unknown-face))
         ('added    (propertize "Added   " 'face 'git-status-face))
         ('deleted  (propertize "Deleted " 'face 'git-status-face))
         ('unmerged (propertize "Unmerged" 'face 'git-unmerged-face))
         ('uptodate (propertize "Uptodate" 'face 'git-uptodate-face))
         ('ignored  (propertize "Ignored " 'face 'git-ignored-face))
         (t "?       ")))
     
     (defun git-file-type-as-string (old-perm new-perm)
       "Return a string describing the file type based on its permissions."
       (let* ((old-type (lsh (or old-perm 0) -9))
              (new-type (lsh (or new-perm 0) -9))
              (str (case new-type
                     (64  ;; file
                      (case old-type
                        (64 nil)
                        (80 "   (type change symlink -> file)")
                        (112 "   (type change subproject -> file)")))
                      (80  ;; symlink
                       (case old-type
                         (64 "   (type change file -> symlink)")
                         (112 "   (type change subproject -> symlink)")
                         (t "   (symlink)")))
                       (112  ;; subproject
                        (case old-type
                          (64 "   (type change file -> subproject)")
                          (80 "   (type change symlink -> subproject)")
                          (t "   (subproject)")))
                       (72 nil)  ;; directory (internal, not a real git state)
                       (0  ;; deleted or unknown
                        (case old-type
                          (80 "   (symlink)")
                          (112 "   (subproject)")))
                       (t (format "   (unknown type %o)" new-type)))))
         (cond (str (propertize str 'face 'git-status-face))
               ((eq new-type 72) "/")
               (t ""))))
     
     (defun git-rename-as-string (info)
       "Return a string describing the copy or rename associated with INFO, or an empty string if none."
       (let ((state (git-fileinfo->rename-state info)))
         (if state
             (propertize
              (concat "   ("
                      (if (eq state 'copy) "copied from "
                        (if (eq (git-fileinfo->state info) 'added) "renamed from "
                          "renamed to "))
                      (git-escape-file-name (git-fileinfo->orig-name info))
                      ")") 'face 'git-status-face)
           "")))
     
     (defun git-permissions-as-string (old-perm new-perm)
       "Format a permission change as string."
       (propertize
        (if (or (not old-perm)
                (not new-perm)
                (eq 0 (logand ?\111 (logxor old-perm new-perm))))
            "  "
          (if (eq 0 (logand ?\111 old-perm)) "+x" "-x"))
       'face 'git-permission-face))
     
     (defun git-fileinfo-prettyprint (info)
       "Pretty-printer for the git-fileinfo structure."
       (let ((old-perm (git-fileinfo->old-perm info))
             (new-perm (git-fileinfo->new-perm info)))
         (insert (concat "   " (if (git-fileinfo->marked info) (propertize "*" 'face 'git-mark-face) " ")
                         " " (git-status-code-as-string (git-fileinfo->state info))
                         " " (git-permissions-as-string old-perm new-perm)
                         "  " (git-escape-file-name (git-fileinfo->name info))
                         (git-file-type-as-string old-perm new-perm)
                         (git-rename-as-string info)))))
     
     (defun git-update-node-fileinfo (node info)
       "Update the fileinfo of the specified node. The names are assumed to match already."
       (let ((data (ewoc-data node)))
         (setf
          ;; preserve the marked flag
          (git-fileinfo->marked info) (git-fileinfo->marked data)
          (git-fileinfo->needs-update data) nil)
         (when (not (equal info data))
           (setf (git-fileinfo->needs-refresh info) t
                 (ewoc-data node) info))))
     
     (defun git-insert-info-list (status infolist files)
       "Insert a sorted list of file infos in the status buffer, replacing existing ones if any."
       (let* ((info (pop infolist))
              (node (ewoc-nth status 0))
              (name (and info (git-fileinfo->name info)))
              remaining)
         (while info
           (let ((nodename (and node (git-fileinfo->name (ewoc-data node)))))
             (while (and files (string-lessp (car files) name))
               (push (pop files) remaining))
             (when (and files (string-equal (car files) name))
               (setq files (cdr files)))
             (cond ((not nodename)
                    (setq node (ewoc-enter-last status info))
                    (setq info (pop infolist))
                    (setq name (and info (git-fileinfo->name info))))
                   ((string-lessp nodename name)
                    (setq node (ewoc-next status node)))
                   ((string-equal nodename name)
                    ;; preserve the marked flag
                    (git-update-node-fileinfo node info)
                    (setq info (pop infolist))
                    (setq name (and info (git-fileinfo->name info))))
                   (t
                    (setq node (ewoc-enter-before status node info))
                    (setq info (pop infolist))
                    (setq name (and info (git-fileinfo->name info)))))))
         (nconc (nreverse remaining) files)))
     
     (defun git-run-diff-index (status files)
       "Run git-diff-index on FILES and parse the results into STATUS.
     Return the list of files that haven't been handled."
       (let (infolist)
         (with-temp-buffer
           (apply #'git-call-process t "diff-index" "-z" "-M" "HEAD" "--" files)
           (goto-char (point-min))
           (while (re-search-forward
                   ":\\([0-7]\\{6\\}\\) \\([0-7]\\{6\\}\\) [0-9a-f]\\{40\\} [0-9a-f]\\{40\\} \\(\\([ADMUT]\\)\0\\([^\0]+\\)\\|\\([CR]\\)[0-9]*\0\\([^\0]+\\)\0\\([^\0]+\\)\\)\0"
                   nil t 1)
             (let ((old-perm (string-to-number (match-string 1) 8))
                   (new-perm (string-to-number (match-string 2) 8))
                   (state (or (match-string 4) (match-string 6)))
                   (name (or (match-string 5) (match-string 7)))
                   (new-name (match-string 8)))
               (if new-name  ; copy or rename
                   (if (eq ?C (string-to-char state))
                       (push (git-create-fileinfo 'added new-name old-perm new-perm 'copy name) infolist)
                     (push (git-create-fileinfo 'deleted name 0 0 'rename new-name) infolist)
                     (push (git-create-fileinfo 'added new-name old-perm new-perm 'rename name) infolist))
                 (push (git-create-fileinfo (git-state-code state) name old-perm new-perm) infolist)))))
         (setq infolist (sort (nreverse infolist)
                              (lambda (info1 info2)
                                (string-lessp (git-fileinfo->name info1)
                                              (git-fileinfo->name info2)))))
         (git-insert-info-list status infolist files)))
     
     (defun git-find-status-file (status file)
       "Find a given file in the status ewoc and return its node."
       (let ((node (ewoc-nth status 0)))
         (while (and node (not (string= file (git-fileinfo->name (ewoc-data node)))))
           (setq node (ewoc-next status node)))
         node))
     
     (defun git-run-ls-files (status files default-state &rest options)
       "Run git-ls-files on FILES and parse the results into STATUS.
     Return the list of files that haven't been handled."
       (let (infolist)
         (with-temp-buffer
           (apply #'git-call-process t "ls-files" "-z" (append options (list "--") files))
           (goto-char (point-min))
           (while (re-search-forward "\\([^\0]*?\\)\\(/?\\)\0" nil t 1)
             (let ((name (match-string 1)))
               (push (git-create-fileinfo default-state name 0
                                          (if (string-equal "/" (match-string 2)) (lsh ?\110 9) 0))
                     infolist))))
         (setq infolist (nreverse infolist))  ;; assume it is sorted already
         (git-insert-info-list status infolist files)))
     
     (defun git-run-ls-files-cached (status files default-state)
       "Run git-ls-files -c on FILES and parse the results into STATUS.
     Return the list of files that haven't been handled."
       (let (infolist)
         (with-temp-buffer
           (apply #'git-call-process t "ls-files" "-z" "-s" "-c" "--" files)
           (goto-char (point-min))
           (while (re-search-forward "\\([0-7]\\{6\\}\\) [0-9a-f]\\{40\\} 0\t\\([^\0]+\\)\0" nil t)
             (let* ((new-perm (string-to-number (match-string 1) 8))
                    (old-perm (if (eq default-state 'added) 0 new-perm))
                    (name (match-string 2)))
               (push (git-create-fileinfo default-state name old-perm new-perm) infolist))))
         (setq infolist (nreverse infolist))  ;; assume it is sorted already
         (git-insert-info-list status infolist files)))
     
     (defun git-run-ls-unmerged (status files)
       "Run git-ls-files -u on FILES and parse the results into STATUS."
       (with-temp-buffer
         (apply #'git-call-process t "ls-files" "-z" "-u" "--" files)
         (goto-char (point-min))
         (let (unmerged-files)
           (while (re-search-forward "[0-7]\\{6\\} [0-9a-f]\\{40\\} [123]\t\\([^\0]+\\)\0" nil t)
             (push (match-string 1) unmerged-files))
           (setq unmerged-files (nreverse unmerged-files))  ;; assume it is sorted already
           (git-set-filenames-state status unmerged-files 'unmerged))))
     
     (defun git-get-exclude-files ()
       "Get the list of exclude files to pass to git-ls-files."
       (let (files
             (config (git-config "core.excludesfile")))
         (when (file-readable-p ".git/info/exclude")
           (push ".git/info/exclude" files))
         (when (and config (file-readable-p config))
           (push config files))
         files))
     
     (defun git-run-ls-files-with-excludes (status files default-state &rest options)
       "Run git-ls-files on FILES with appropriate --exclude-from options."
       (let ((exclude-files (git-get-exclude-files)))
         (apply #'git-run-ls-files status files default-state "--directory" "--no-empty-directory"
                (concat "--exclude-per-directory=" git-per-dir-ignore-file)
                (append options (mapcar (lambda (f) (concat "--exclude-from=" f)) exclude-files)))))
     
     (defun git-update-status-files (&optional files mark-files)
       "Update the status of FILES from the index.
     The FILES list must be sorted."
       (unless git-status (error "Not in git-status buffer."))
       ;; set the needs-update flag on existing files
       (if files
           (git-status-filenames-map
            git-status (lambda (info) (setf (git-fileinfo->needs-update info) t)) files)
         (ewoc-map (lambda (info) (setf (git-fileinfo->needs-update info) t) nil) git-status)
         (git-call-process nil "update-index" "--refresh")
         (when git-show-uptodate
           (git-run-ls-files-cached git-status nil 'uptodate)))
       (let ((remaining-files
               (if (git-empty-db-p) ; we need some special handling for an empty db
                   (git-run-ls-files-cached git-status files 'added)
                 (git-run-diff-index git-status files))))
         (git-run-ls-unmerged git-status files)
         (when (or remaining-files (and git-show-unknown (not files)))
           (setq remaining-files (git-run-ls-files-with-excludes git-status remaining-files 'unknown "-o")))
         (when (or remaining-files (and git-show-ignored (not files)))
           (setq remaining-files (git-run-ls-files-with-excludes git-status remaining-files 'ignored "-o" "-i")))
         (unless files
           (setq remaining-files (git-get-filenames (ewoc-collect git-status #'git-fileinfo->needs-update))))
         (when remaining-files
           (setq remaining-files (git-run-ls-files-cached git-status remaining-files 'uptodate)))
         (git-set-filenames-state git-status remaining-files nil)
         (when mark-files (git-mark-files git-status files))
         (git-refresh-files)
         (git-refresh-ewoc-hf git-status)))
     
     (defun git-mark-files (status files)
       "Mark all the specified FILES, and unmark the others."
       (let ((file (and files (pop files)))
             (node (ewoc-nth status 0)))
         (while node
           (let ((info (ewoc-data node)))
             (if (and file (string-equal (git-fileinfo->name info) file))
                 (progn
                   (unless (git-fileinfo->marked info)
                     (setf (git-fileinfo->marked info) t)
                     (setf (git-fileinfo->needs-refresh info) t))
                   (setq file (pop files))
                   (setq node (ewoc-next status node)))
               (when (git-fileinfo->marked info)
                 (setf (git-fileinfo->marked info) nil)
                 (setf (git-fileinfo->needs-refresh info) t))
               (if (and file (string-lessp file (git-fileinfo->name info)))
                   (setq file (pop files))
                 (setq node (ewoc-next status node))))))))
     
     (defun git-marked-files ()
       "Return a list of all marked files, or if none a list containing just the file at cursor position."
       (unless git-status (error "Not in git-status buffer."))
       (or (ewoc-collect git-status (lambda (info) (git-fileinfo->marked info)))
           (list (ewoc-data (ewoc-locate git-status)))))
     
     (defun git-marked-files-state (&rest states)
       "Return a sorted list of marked files that are in the specified states."
       (let ((files (git-marked-files))
             result)
         (dolist (info files)
           (when (memq (git-fileinfo->state info) states)
             (push info result)))
         (nreverse result)))
     
     (defun git-refresh-files ()
       "Refresh all files that need it and clear the needs-refresh flag."
       (unless git-status (error "Not in git-status buffer."))
       (ewoc-map
        (lambda (info)
          (let ((refresh (git-fileinfo->needs-refresh info)))
            (setf (git-fileinfo->needs-refresh info) nil)
            refresh))
        git-status)
       ; move back to goal column
       (when goal-column (move-to-column goal-column)))
     
     (defun git-refresh-ewoc-hf (status)
       "Refresh the ewoc header and footer."
       (let ((branch (git-symbolic-ref "HEAD"))
             (head (if (git-empty-db-p) "Nothing committed yet"
                     (git-get-commit-description "HEAD")))
             (merge-heads (git-get-merge-heads)))
         (ewoc-set-hf status
                      (format "Directory:  %s\nBranch:     %s\nHead:       %s%s\n"
                              default-directory
                              (if branch
                                  (if (string-match "^refs/heads/" branch)
                                      (substring branch (match-end 0))
                                    branch)
                                "none (detached HEAD)")
                              head
                              (if merge-heads
                                  (concat "\nMerging:    "
                                          (mapconcat (lambda (str) (git-get-commit-description str)) merge-heads "\n            "))
                                ""))
                      (if (ewoc-nth status 0) "" "    No changes."))))
     
     (defun git-get-filenames (files)
       (mapcar (lambda (info) (git-fileinfo->name info)) files))
     
     (defun git-update-index (index-file files)
       "Run git-update-index on a list of files."
       (let ((process-environment (append (and index-file (list (concat "GIT_INDEX_FILE=" index-file)))
                                          process-environment))
             added deleted modified)
         (dolist (info files)
           (case (git-fileinfo->state info)
             ('added (push info added))
             ('deleted (push info deleted))
             ('modified (push info modified))))
         (and
          (or (not added) (apply #'git-call-process-display-error "update-index" "--add" "--" (git-get-filenames added)))
          (or (not deleted) (apply #'git-call-process-display-error "update-index" "--remove" "--" (git-get-filenames deleted)))
          (or (not modified) (apply #'git-call-process-display-error "update-index" "--" (git-get-filenames modified))))))
     
     (defun git-run-pre-commit-hook ()
       "Run the pre-commit hook if any."
       (unless git-status (error "Not in git-status buffer."))
       (let ((files (git-marked-files-state 'added 'deleted 'modified)))
         (or (not files)
             (not (file-executable-p ".git/hooks/pre-commit"))
             (let ((index-file (make-temp-file "gitidx")))
               (unwind-protect
                 (let ((head-tree (unless (git-empty-db-p) (git-rev-parse "HEAD^{tree}"))))
                   (git-read-tree head-tree index-file)
                   (git-update-index index-file files)
                   (git-run-hook "pre-commit" `(("GIT_INDEX_FILE" . ,index-file))))
               (delete-file index-file))))))
     
     (defun git-do-commit ()
       "Perform the actual commit using the current buffer as log message."
       (interactive)
       (let ((buffer (current-buffer))
             (index-file (make-temp-file "gitidx")))
         (with-current-buffer log-edit-parent-buffer
           (if (git-marked-files-state 'unmerged)
               (message "You cannot commit unmerged files, resolve them first.")
             (unwind-protect
                 (let ((files (git-marked-files-state 'added 'deleted 'modified))
                       head tree head-tree)
                   (unless (git-empty-db-p)
                     (setq head (git-rev-parse "HEAD")
                           head-tree (git-rev-parse "HEAD^{tree}")))
                   (message "Running git commit...")
                   (when
                       (and
                        (git-read-tree head-tree index-file)
                        (git-update-index nil files)         ;update both the default index
                        (git-update-index index-file files)  ;and the temporary one
                        (setq tree (git-write-tree index-file)))
                     (if (or (not (string-equal tree head-tree))
                             (yes-or-no-p "The tree was not modified, do you really want to perform an empty commit? "))
                         (let ((commit (git-commit-tree buffer tree head)))
                           (when commit
                             (condition-case nil (delete-file ".git/MERGE_HEAD") (error nil))
                             (condition-case nil (delete-file ".git/MERGE_MSG") (error nil))
                             (with-current-buffer buffer (erase-buffer))
                             (git-update-status-files (git-get-filenames files))
                             (git-call-process nil "rerere")
                             (git-call-process nil "gc" "--auto")
                             (message "Committed %s." commit)
                             (git-run-hook "post-commit" nil)))
                       (message "Commit aborted."))))
               (delete-file index-file))))))
     
     
     ;;;; Interactive functions
     ;;;; ------------------------------------------------------------
     
     (defun git-mark-file ()
       "Mark the file that the cursor is on and move to the next one."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (let* ((pos (ewoc-locate git-status))
              (info (ewoc-data pos)))
         (setf (git-fileinfo->marked info) t)
         (ewoc-invalidate git-status pos)
         (ewoc-goto-next git-status 1)))
     
     (defun git-unmark-file ()
       "Unmark the file that the cursor is on and move to the next one."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (let* ((pos (ewoc-locate git-status))
              (info (ewoc-data pos)))
         (setf (git-fileinfo->marked info) nil)
         (ewoc-invalidate git-status pos)
         (ewoc-goto-next git-status 1)))
     
     (defun git-unmark-file-up ()
       "Unmark the file that the cursor is on and move to the previous one."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (let* ((pos (ewoc-locate git-status))
              (info (ewoc-data pos)))
         (setf (git-fileinfo->marked info) nil)
         (ewoc-invalidate git-status pos)
         (ewoc-goto-prev git-status 1)))
     
     (defun git-mark-all ()
       "Mark all files."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (ewoc-map (lambda (info) (unless (git-fileinfo->marked info)
                                  (setf (git-fileinfo->marked info) t))) git-status)
       ; move back to goal column after invalidate
       (when goal-column (move-to-column goal-column)))
     
     (defun git-unmark-all ()
       "Unmark all files."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (ewoc-map (lambda (info) (when (git-fileinfo->marked info)
                                  (setf (git-fileinfo->marked info) nil)
                                  t)) git-status)
       ; move back to goal column after invalidate
       (when goal-column (move-to-column goal-column)))
     
     (defun git-toggle-all-marks ()
       "Toggle all file marks."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (ewoc-map (lambda (info) (setf (git-fileinfo->marked info) (not (git-fileinfo->marked info))) t) git-status)
       ; move back to goal column after invalidate
       (when goal-column (move-to-column goal-column)))
     
     (defun git-next-file (&optional n)
       "Move the selection down N files."
       (interactive "p")
       (unless git-status (error "Not in git-status buffer."))
       (ewoc-goto-next git-status n))
     
     (defun git-prev-file (&optional n)
       "Move the selection up N files."
       (interactive "p")
       (unless git-status (error "Not in git-status buffer."))
       (ewoc-goto-prev git-status n))
     
     (defun git-next-unmerged-file (&optional n)
       "Move the selection down N unmerged files."
       (interactive "p")
       (unless git-status (error "Not in git-status buffer."))
       (let* ((last (ewoc-locate git-status))
              (node (ewoc-next git-status last)))
         (while (and node (> n 0))
           (when (eq 'unmerged (git-fileinfo->state (ewoc-data node)))
             (setq n (1- n))
             (setq last node))
           (setq node (ewoc-next git-status node)))
         (ewoc-goto-node git-status last)))
     
     (defun git-prev-unmerged-file (&optional n)
       "Move the selection up N unmerged files."
       (interactive "p")
       (unless git-status (error "Not in git-status buffer."))
       (let* ((last (ewoc-locate git-status))
              (node (ewoc-prev git-status last)))
         (while (and node (> n 0))
           (when (eq 'unmerged (git-fileinfo->state (ewoc-data node)))
             (setq n (1- n))
             (setq last node))
           (setq node (ewoc-prev git-status node)))
         (ewoc-goto-node git-status last)))
     
     (defun git-insert-file (file)
       "Insert file(s) into the git-status buffer."
       (interactive "fInsert file: ")
       (git-update-status-files (list (file-relative-name file))))
     
     (defun git-add-file ()
       "Add marked file(s) to the index cache."
       (interactive)
       (let ((files (git-get-filenames (git-marked-files-state 'unknown 'ignored 'unmerged))))
         ;; FIXME: add support for directories
         (unless files
           (push (file-relative-name (read-file-name "File to add: " nil nil t)) files))
         (when (apply 'git-call-process-display-error "update-index" "--add" "--" files)
           (git-update-status-files files)
           (git-success-message "Added" files))))
     
     (defun git-ignore-file ()
       "Add marked file(s) to the ignore list."
       (interactive)
       (let ((files (git-get-filenames (git-marked-files-state 'unknown))))
         (unless files
           (push (file-relative-name (read-file-name "File to ignore: " nil nil t)) files))
         (dolist (f files) (git-append-to-ignore f))
         (git-update-status-files files)
         (git-success-message "Ignored" files)))
     
     (defun git-remove-file ()
       "Remove the marked file(s)."
       (interactive)
       (let ((files (git-get-filenames (git-marked-files-state 'added 'modified 'unknown 'uptodate 'ignored))))
         (unless files
           (push (file-relative-name (read-file-name "File to remove: " nil nil t)) files))
         (if (yes-or-no-p
              (if (cdr files)
                  (format "Remove %d files? " (length files))
                (format "Remove %s? " (car files))))
             (progn
               (dolist (name files)
                 (ignore-errors
                   (if (file-directory-p name)
                       (delete-directory name)
                     (delete-file name))))
               (when (apply 'git-call-process-display-error "update-index" "--remove" "--" files)
                 (git-update-status-files files)
                 (git-success-message "Removed" files)))
           (message "Aborting"))))
     
     (defun git-revert-file ()
       "Revert changes to the marked file(s)."
       (interactive)
       (let ((files (git-marked-files-state 'added 'deleted 'modified 'unmerged))
             added modified)
         (when (and files
                    (yes-or-no-p
                     (if (cdr files)
                         (format "Revert %d files? " (length files))
                       (format "Revert %s? " (git-fileinfo->name (car files))))))
           (dolist (info files)
             (case (git-fileinfo->state info)
               ('added (push (git-fileinfo->name info) added))
               ('deleted (push (git-fileinfo->name info) modified))
               ('unmerged (push (git-fileinfo->name info) modified))
               ('modified (push (git-fileinfo->name info) modified))))
           ;; check if a buffer contains one of the files and isn't saved
           (dolist (file modified)
             (let ((buffer (get-file-buffer file)))
               (when (and buffer (buffer-modified-p buffer))
                 (error "Buffer %s is modified. Please kill or save modified buffers before reverting." (buffer-name buffer)))))
           (let ((ok (and
                      (or (not added)
                          (apply 'git-call-process-display-error "update-index" "--force-remove" "--" added))
                      (or (not modified)
                          (apply 'git-call-process-display-error "checkout" "HEAD" modified))))
                 (names (git-get-filenames files)))
             (git-update-status-files names)
             (when ok
               (dolist (file modified)
                 (let ((buffer (get-file-buffer file)))
                   (when buffer (with-current-buffer buffer (revert-buffer t t t)))))
               (git-success-message "Reverted" names))))))
     
     (defun git-remove-handled ()
       "Remove handled files from the status list."
       (interactive)
       (ewoc-filter git-status
                    (lambda (info)
                      (case (git-fileinfo->state info)
                        ('ignored git-show-ignored)
                        ('uptodate git-show-uptodate)
                        ('unknown git-show-unknown)
                        (t t))))
       (unless (ewoc-nth git-status 0)  ; refresh header if list is empty
         (git-refresh-ewoc-hf git-status)))
     
     (defun git-toggle-show-uptodate ()
       "Toogle the option for showing up-to-date files."
       (interactive)
       (if (setq git-show-uptodate (not git-show-uptodate))
           (git-refresh-status)
         (git-remove-handled)))
     
     (defun git-toggle-show-ignored ()
       "Toogle the option for showing ignored files."
       (interactive)
       (if (setq git-show-ignored (not git-show-ignored))
           (progn
             (message "Inserting ignored files...")
             (git-run-ls-files-with-excludes git-status nil 'ignored "-o" "-i")
             (git-refresh-files)
             (git-refresh-ewoc-hf git-status)
             (message "Inserting ignored files...done"))
         (git-remove-handled)))
     
     (defun git-toggle-show-unknown ()
       "Toogle the option for showing unknown files."
       (interactive)
       (if (setq git-show-unknown (not git-show-unknown))
           (progn
             (message "Inserting unknown files...")
             (git-run-ls-files-with-excludes git-status nil 'unknown "-o")
             (git-refresh-files)
             (git-refresh-ewoc-hf git-status)
             (message "Inserting unknown files...done"))
         (git-remove-handled)))
     
     (defun git-expand-directory (info)
       "Expand the directory represented by INFO to list its files."
       (when (eq (lsh (git-fileinfo->new-perm info) -9) ?\110)
         (let ((dir (git-fileinfo->name info)))
           (git-set-filenames-state git-status (list dir) nil)
           (git-run-ls-files-with-excludes git-status (list (concat dir "/")) 'unknown "-o")
           (git-refresh-files)
           (git-refresh-ewoc-hf git-status)
           t)))
     
     (defun git-setup-diff-buffer (buffer)
       "Setup a buffer for displaying a diff."
       (let ((dir default-directory))
         (with-current-buffer buffer
           (diff-mode)
           (goto-char (point-min))
           (setq default-directory dir)
           (setq buffer-read-only t)))
       (display-buffer buffer)
       ; shrink window only if it displays the status buffer
       (when (eq (window-buffer) (current-buffer))
         (shrink-window-if-larger-than-buffer)))
     
     (defun git-diff-file ()
       "Diff the marked file(s) against HEAD."
       (interactive)
       (let ((files (git-marked-files)))
         (git-setup-diff-buffer
          (apply #'git-run-command-buffer "*git-diff*" "diff-index" "-p" "-M" "HEAD" "--" (git-get-filenames files)))))
     
     (defun git-diff-file-merge-head (arg)
       "Diff the marked file(s) against the first merge head (or the nth one with a numeric prefix)."
       (interactive "p")
       (let ((files (git-marked-files))
             (merge-heads (git-get-merge-heads)))
         (unless merge-heads (error "No merge in progress"))
         (git-setup-diff-buffer
          (apply #'git-run-command-buffer "*git-diff*" "diff-index" "-p" "-M"
                 (or (nth (1- arg) merge-heads) "HEAD") "--" (git-get-filenames files)))))
     
     (defun git-diff-unmerged-file (stage)
       "Diff the marked unmerged file(s) against the specified stage."
       (let ((files (git-marked-files)))
         (git-setup-diff-buffer
          (apply #'git-run-command-buffer "*git-diff*" "diff-files" "-p" stage "--" (git-get-filenames files)))))
     
     (defun git-diff-file-base ()
       "Diff the marked unmerged file(s) against the common base file."
       (interactive)
       (git-diff-unmerged-file "-1"))
     
     (defun git-diff-file-mine ()
       "Diff the marked unmerged file(s) against my pre-merge version."
       (interactive)
       (git-diff-unmerged-file "-2"))
     
     (defun git-diff-file-other ()
       "Diff the marked unmerged file(s) against the other's pre-merge version."
       (interactive)
       (git-diff-unmerged-file "-3"))
     
     (defun git-diff-file-combined ()
       "Do a combined diff of the marked unmerged file(s)."
       (interactive)
       (git-diff-unmerged-file "-c"))
     
     (defun git-diff-file-idiff ()
       "Perform an interactive diff on the current file."
       (interactive)
       (let ((files (git-marked-files-state 'added 'deleted 'modified)))
         (unless (eq 1 (length files))
           (error "Cannot perform an interactive diff on multiple files."))
         (let* ((filename (car (git-get-filenames files)))
                (buff1 (find-file-noselect filename))
                (buff2 (git-run-command-buffer (concat filename ".~HEAD~") "cat-file" "blob" (concat "HEAD:" filename))))
           (ediff-buffers buff1 buff2))))
     
     (defun git-log-file ()
       "Display a log of changes to the marked file(s)."
       (interactive)
       (let* ((files (git-marked-files))
              (coding-system-for-read git-commits-coding-system)
              (buffer (apply #'git-run-command-buffer "*git-log*" "rev-list" "--pretty" "HEAD" "--" (git-get-filenames files))))
         (with-current-buffer buffer
           ; (git-log-mode)  FIXME: implement log mode
           (goto-char (point-min))
           (setq buffer-read-only t))
         (display-buffer buffer)))
     
     (defun git-log-edit-files ()
       "Return a list of marked files for use in the log-edit buffer."
       (with-current-buffer log-edit-parent-buffer
         (git-get-filenames (git-marked-files-state 'added 'deleted 'modified))))
     
     (defun git-log-edit-diff ()
       "Run a diff of the current files being committed from a log-edit buffer."
       (with-current-buffer log-edit-parent-buffer
         (git-diff-file)))
     
     (defun git-append-sign-off (name email)
       "Append a Signed-off-by entry to the current buffer, avoiding duplicates."
       (let ((sign-off (format "Signed-off-by: %s <%s>" name email))
             (case-fold-search t))
         (goto-char (point-min))
         (unless (re-search-forward (concat "^" (regexp-quote sign-off)) nil t)
           (goto-char (point-min))
           (unless (re-search-forward "^Signed-off-by: " nil t)
             (setq sign-off (concat "\n" sign-off)))
           (goto-char (point-max))
           (insert sign-off "\n"))))
     
     (defun git-setup-log-buffer (buffer &optional merge-heads author-name author-email subject date msg)
       "Setup the log buffer for a commit."
       (unless git-status (error "Not in git-status buffer."))
       (let ((dir default-directory)
             (committer-name (git-get-committer-name))
             (committer-email (git-get-committer-email))
             (sign-off git-append-signed-off-by))
         (with-current-buffer buffer
           (cd dir)
           (erase-buffer)
           (insert
            (propertize
             (format "Author: %s <%s>\n%s%s"
                     (or author-name committer-name)
                     (or author-email committer-email)
                     (if date (format "Date: %s\n" date) "")
                     (if merge-heads
                         (format "Merge: %s\n"
                                 (mapconcat 'identity merge-heads " "))
                       ""))
             'face 'git-header-face)
            (propertize git-log-msg-separator 'face 'git-separator-face)
            "\n")
           (when subject (insert subject "\n\n"))
           (cond (msg (insert msg "\n"))
                 ((file-readable-p ".git/rebase-apply/msg")
                  (insert-file-contents ".git/rebase-apply/msg"))
                 ((file-readable-p ".git/MERGE_MSG")
                  (insert-file-contents ".git/MERGE_MSG")))
           ; delete empty lines at end
           (goto-char (point-min))
           (when (re-search-forward "\n+\\'" nil t)
             (replace-match "\n" t t))
           (when sign-off (git-append-sign-off committer-name committer-email)))
         buffer))
     
     (define-derived-mode git-log-edit-mode log-edit-mode "Git-Log-Edit"
       "Major mode for editing git log messages.
     
     Set up git-specific `font-lock-keywords' for `log-edit-mode'."
       (set (make-local-variable 'font-lock-defaults)
            '(git-log-edit-font-lock-keywords t t)))
     
     (defun git-commit-file ()
       "Commit the marked file(s), asking for a commit message."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (when (git-run-pre-commit-hook)
         (let ((buffer (get-buffer-create "*git-commit*"))
               (coding-system (git-get-commits-coding-system))
               author-name author-email subject date)
           (when (eq 0 (buffer-size buffer))
             (when (file-readable-p ".git/rebase-apply/info")
               (with-temp-buffer
                 (insert-file-contents ".git/rebase-apply/info")
                 (goto-char (point-min))
                 (when (re-search-forward "^Author: \\(.*\\)\nEmail: \\(.*\\)$" nil t)
                   (setq author-name (match-string 1))
                   (setq author-email (match-string 2)))
                 (goto-char (point-min))
                 (when (re-search-forward "^Subject: \\(.*\\)$" nil t)
                   (setq subject (match-string 1)))
                 (goto-char (point-min))
                 (when (re-search-forward "^Date: \\(.*\\)$" nil t)
                   (setq date (match-string 1)))))
             (git-setup-log-buffer buffer (git-get-merge-heads) author-name author-email subject date))
           (if (boundp 'log-edit-diff-function)
               (log-edit 'git-do-commit nil '((log-edit-listfun . git-log-edit-files)
                                              (log-edit-diff-function . git-log-edit-diff)) buffer 'git-log-edit-mode)
             (log-edit 'git-do-commit nil 'git-log-edit-files buffer
                       'git-log-edit-mode))
           (setq paragraph-separate (concat (regexp-quote git-log-msg-separator) "$\\|Author: \\|Date: \\|Merge: \\|Signed-off-by: \\|\f\\|[         ]*$"))
           (setq buffer-file-coding-system coding-system)
           (re-search-forward (regexp-quote (concat git-log-msg-separator "\n")) nil t))))
     
     (defun git-setup-commit-buffer (commit)
       "Setup the commit buffer with the contents of COMMIT."
       (let (parents author-name author-email subject date msg)
         (with-temp-buffer
           (let ((coding-system (git-get-logoutput-coding-system)))
             (git-call-process t "log" "-1" "--pretty=medium" "--abbrev=40" commit)
             (goto-char (point-min))
             (when (re-search-forward "^Merge: *\\(.*\\)$" nil t)
               (setq parents (cdr (split-string (match-string 1) " +"))))
             (when (re-search-forward "^Author: *\\(.*\\) <\\(.*\\)>$" nil t)
               (setq author-name (match-string 1))
               (setq author-email (match-string 2)))
             (when (re-search-forward "^Date: *\\(.*\\)$" nil t)
               (setq date (match-string 1)))
             (while (re-search-forward "^    \\(.*\\)$" nil t)
               (push (match-string 1) msg))
             (setq msg (nreverse msg))
             (setq subject (pop msg))
             (while (and msg (zerop (length (car msg))) (pop msg)))))
         (git-setup-log-buffer (get-buffer-create "*git-commit*")
                               parents author-name author-email subject date
                               (mapconcat #'identity msg "\n"))))
     
     (defun git-get-commit-files (commit)
       "Retrieve a sorted list of files modified by COMMIT."
       (let (files)
         (with-temp-buffer
           (git-call-process t "diff-tree" "-m" "-r" "-z" "--name-only" "--no-commit-id" "--root" commit)
           (goto-char (point-min))
           (while (re-search-forward "\\([^\0]*\\)\0" nil t 1)
             (push (match-string 1) files)))
         (sort files #'string-lessp)))
     
     (defun git-read-commit-name (prompt &optional default)
       "Ask for a commit name, with completion for local branch, remote branch and tag."
       (completing-read prompt
                        (list* "HEAD" "ORIG_HEAD" "FETCH_HEAD" (mapcar #'car (git-for-each-ref)))
                        nil nil nil nil default))
     
     (defun git-checkout (branch &optional merge)
       "Checkout a branch, tag, or any commit.
     Use a prefix arg if git should merge while checking out."
       (interactive
        (list (git-read-commit-name "Checkout: ")
              current-prefix-arg))
       (unless git-status (error "Not in git-status buffer."))
       (let ((args (list branch "--")))
         (when merge (push "-m" args))
         (when (apply #'git-call-process-display-error "checkout" args)
           (git-update-status-files))))
     
     (defun git-branch (branch)
       "Create a branch from the current HEAD and switch to it."
       (interactive (list (git-read-commit-name "Branch: ")))
       (unless git-status (error "Not in git-status buffer."))
       (if (git-rev-parse (concat "refs/heads/" branch))
           (if (yes-or-no-p (format "Branch %s already exists, replace it? " branch))
               (and (git-call-process-display-error "branch" "-f" branch)
                    (git-call-process-display-error "checkout" branch))
             (message "Canceled."))
         (git-call-process-display-error "checkout" "-b" branch))
         (git-refresh-ewoc-hf git-status))
     
     (defun git-amend-commit ()
       "Undo the last commit on HEAD, and set things up to commit an
     amended version of it."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (when (git-empty-db-p) (error "No commit to amend."))
       (let* ((commit (git-rev-parse "HEAD"))
              (files (git-get-commit-files commit)))
         (when (if (git-rev-parse "HEAD^")
                   (git-call-process-display-error "reset" "--soft" "HEAD^")
                 (and (git-update-ref "ORIG_HEAD" commit)
                      (git-update-ref "HEAD" nil commit)))
           (git-update-status-files files t)
           (git-setup-commit-buffer commit)
           (git-commit-file))))
     
     (defun git-cherry-pick-commit (arg)
       "Cherry-pick a commit."
       (interactive (list (git-read-commit-name "Cherry-pick commit: ")))
       (unless git-status (error "Not in git-status buffer."))
       (let ((commit (git-rev-parse (concat arg "^0"))))
         (unless commit (error "Not a valid commit '%s'." arg))
         (when (git-rev-parse (concat commit "^2"))
           (error "Cannot cherry-pick a merge commit."))
         (let ((files (git-get-commit-files commit))
               (ok (git-call-process-display-error "cherry-pick" "-n" commit)))
           (git-update-status-files files ok)
           (with-current-buffer (git-setup-commit-buffer commit)
             (goto-char (point-min))
             (if (re-search-forward "^\n*Signed-off-by:" nil t 1)
                 (goto-char (match-beginning 0))
               (goto-char (point-max)))
             (insert "(cherry picked from commit " commit ")\n"))
           (when ok (git-commit-file)))))
     
     (defun git-revert-commit (arg)
       "Revert a commit."
       (interactive (list (git-read-commit-name "Revert commit: ")))
       (unless git-status (error "Not in git-status buffer."))
       (let ((commit (git-rev-parse (concat arg "^0"))))
         (unless commit (error "Not a valid commit '%s'." arg))
         (when (git-rev-parse (concat commit "^2"))
           (error "Cannot revert a merge commit."))
         (let ((files (git-get-commit-files commit))
               (subject (git-get-commit-description commit))
               (ok (git-call-process-display-error "revert" "-n" commit)))
           (git-update-status-files files ok)
           (when (string-match "^[0-9a-f]+ - \\(.*\\)$" subject)
             (setq subject (match-string 1 subject)))
           (git-setup-log-buffer (get-buffer-create "*git-commit*")
                                 (git-get-merge-heads) nil nil (format "Revert \"%s\"" subject) nil
                                 (format "This reverts commit %s.\n" commit))
           (when ok (git-commit-file)))))
     
     (defun git-find-file ()
       "Visit the current file in its own buffer."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (let ((info (ewoc-data (ewoc-locate git-status))))
         (unless (git-expand-directory info)
           (find-file (git-fileinfo->name info))
           (when (eq 'unmerged (git-fileinfo->state info))
             (smerge-mode 1)))))
     
     (defun git-find-file-other-window ()
       "Visit the current file in its own buffer in another window."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (let ((info (ewoc-data (ewoc-locate git-status))))
         (find-file-other-window (git-fileinfo->name info))
         (when (eq 'unmerged (git-fileinfo->state info))
           (smerge-mode))))
     
     (defun git-find-file-imerge ()
       "Visit the current file in interactive merge mode."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (let ((info (ewoc-data (ewoc-locate git-status))))
         (find-file (git-fileinfo->name info))
         (smerge-ediff)))
     
     (defun git-view-file ()
       "View the current file in its own buffer."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (let ((info (ewoc-data (ewoc-locate git-status))))
         (view-file (git-fileinfo->name info))))
     
     (defun git-refresh-status ()
       "Refresh the git status buffer."
       (interactive)
       (unless git-status (error "Not in git-status buffer."))
       (message "Refreshing git status...")
       (git-update-status-files)
       (message "Refreshing git status...done"))
     
     (defun git-status-quit ()
       "Quit git-status mode."
       (interactive)
       (bury-buffer))
     
     ;;;; Major Mode
     ;;;; ------------------------------------------------------------
     
     (defvar git-status-mode-hook nil
       "Run after `git-status-mode' is setup.")
     
     (defvar git-status-mode-map nil
       "Keymap for git major mode.")
     
     (defvar git-status nil
       "List of all files managed by the git-status mode.")
     
     (unless git-status-mode-map
       (let ((map (make-keymap))
             (commit-map (make-sparse-keymap))
             (diff-map (make-sparse-keymap))
             (toggle-map (make-sparse-keymap)))
         (suppress-keymap map)
         (define-key map "?"   'git-help)
         (define-key map "h"   'git-help)
         (define-key map " "   'git-next-file)
         (define-key map "a"   'git-add-file)
         (define-key map "c"   'git-commit-file)
         (define-key map "\C-c" commit-map)
         (define-key map "d"    diff-map)
         (define-key map "="   'git-diff-file)
         (define-key map "f"   'git-find-file)
         (define-key map "\r"  'git-find-file)
         (define-key map "g"   'git-refresh-status)
         (define-key map "i"   'git-ignore-file)
         (define-key map "I"   'git-insert-file)
         (define-key map "l"   'git-log-file)
         (define-key map "m"   'git-mark-file)
         (define-key map "M"   'git-mark-all)
         (define-key map "n"   'git-next-file)
         (define-key map "N"   'git-next-unmerged-file)
         (define-key map "o"   'git-find-file-other-window)
         (define-key map "p"   'git-prev-file)
         (define-key map "P"   'git-prev-unmerged-file)
         (define-key map "q"   'git-status-quit)
         (define-key map "r"   'git-remove-file)
         (define-key map "t"    toggle-map)
         (define-key map "T"   'git-toggle-all-marks)
         (define-key map "u"   'git-unmark-file)
         (define-key map "U"   'git-revert-file)
         (define-key map "v"   'git-view-file)
         (define-key map "x"   'git-remove-handled)
         (define-key map "\C-?" 'git-unmark-file-up)
         (define-key map "\M-\C-?" 'git-unmark-all)
         ; the commit submap
         (define-key commit-map "\C-a" 'git-amend-commit)
         (define-key commit-map "\C-b" 'git-branch)
         (define-key commit-map "\C-o" 'git-checkout)
         (define-key commit-map "\C-p" 'git-cherry-pick-commit)
         (define-key commit-map "\C-v" 'git-revert-commit)
         ; the diff submap
         (define-key diff-map "b" 'git-diff-file-base)
         (define-key diff-map "c" 'git-diff-file-combined)
         (define-key diff-map "=" 'git-diff-file)
         (define-key diff-map "e" 'git-diff-file-idiff)
         (define-key diff-map "E" 'git-find-file-imerge)
         (define-key diff-map "h" 'git-diff-file-merge-head)
         (define-key diff-map "m" 'git-diff-file-mine)
         (define-key diff-map "o" 'git-diff-file-other)
         ; the toggle submap
         (define-key toggle-map "u" 'git-toggle-show-uptodate)
         (define-key toggle-map "i" 'git-toggle-show-ignored)
         (define-key toggle-map "k" 'git-toggle-show-unknown)
         (define-key toggle-map "m" 'git-toggle-all-marks)
         (setq git-status-mode-map map))
       (easy-menu-define git-menu git-status-mode-map
         "Git Menu"
         `("Git"
           ["Refresh" git-refresh-status t]
           ["Commit" git-commit-file t]
           ["Checkout..." git-checkout t]
           ["New Branch..." git-branch t]
           ["Cherry-pick Commit..." git-cherry-pick-commit t]
           ["Revert Commit..." git-revert-commit t]
           ("Merge"
             ["Next Unmerged File" git-next-unmerged-file t]
             ["Prev Unmerged File" git-prev-unmerged-file t]
             ["Interactive Merge File" git-find-file-imerge t]
             ["Diff Against Common Base File" git-diff-file-base t]
             ["Diff Combined" git-diff-file-combined t]
             ["Diff Against Merge Head" git-diff-file-merge-head t]
             ["Diff Against Mine" git-diff-file-mine t]
             ["Diff Against Other" git-diff-file-other t])
           "--------"
           ["Add File" git-add-file t]
           ["Revert File" git-revert-file t]
           ["Ignore File" git-ignore-file t]
           ["Remove File" git-remove-file t]
           ["Insert File" git-insert-file t]
           "--------"
           ["Find File" git-find-file t]
           ["View File" git-view-file t]
           ["Diff File" git-diff-file t]
           ["Interactive Diff File" git-diff-file-idiff t]
           ["Log" git-log-file t]
           "--------"
           ["Mark" git-mark-file t]
           ["Mark All" git-mark-all t]
           ["Unmark" git-unmark-file t]
           ["Unmark All" git-unmark-all t]
           ["Toggle All Marks" git-toggle-all-marks t]
           ["Hide Handled Files" git-remove-handled t]
           "--------"
           ["Show Uptodate Files" git-toggle-show-uptodate :style toggle :selected git-show-uptodate]
           ["Show Ignored Files" git-toggle-show-ignored :style toggle :selected git-show-ignored]
           ["Show Unknown Files" git-toggle-show-unknown :style toggle :selected git-show-unknown]
           "--------"
           ["Quit" git-status-quit t])))
     
     
     ;; git mode should only run in the *git status* buffer
     (put 'git-status-mode 'mode-class 'special)
     
     (defun git-status-mode ()
       "Major mode for interacting with Git.
     Commands:
     \\{git-status-mode-map}"
       (kill-all-local-variables)
       (buffer-disable-undo)
       (setq mode-name "git status"
             major-mode 'git-status-mode
             goal-column 17
             buffer-read-only t)
       (use-local-map git-status-mode-map)
       (let ((buffer-read-only nil))
         (erase-buffer)
       (let ((status (ewoc-create 'git-fileinfo-prettyprint "" "")))
         (set (make-local-variable 'git-status) status))
       (set (make-local-variable 'list-buffers-directory) default-directory)
       (make-local-variable 'git-show-uptodate)
       (make-local-variable 'git-show-ignored)
       (make-local-variable 'git-show-unknown)
       (run-hooks 'git-status-mode-hook)))
     
     (defun git-find-status-buffer (dir)
       "Find the git status buffer handling a specified directory."
       (let ((list (buffer-list))
             (fulldir (expand-file-name dir))
             found)
         (while (and list (not found))
           (let ((buffer (car list)))
             (with-current-buffer buffer
               (when (and list-buffers-directory
                          (string-equal fulldir (expand-file-name list-buffers-directory))
                          (eq major-mode 'git-status-mode))
                 (setq found buffer))))
           (setq list (cdr list)))
         found))
     
     (defun git-status (dir)
       "Entry point into git-status mode."
       (interactive "DSelect directory: ")
       (setq dir (git-get-top-dir dir))
       (if (file-directory-p (concat (file-name-as-directory dir) ".git"))
           (let ((buffer (or (and git-reuse-status-buffer (git-find-status-buffer dir))
                             (create-file-buffer (expand-file-name "*git-status*" dir)))))
             (switch-to-buffer buffer)
             (cd dir)
             (git-status-mode)
             (git-refresh-status)
             (goto-char (point-min))
             (add-hook 'after-save-hook 'git-update-saved-file))
         (message "%s is not a git working tree." dir)))
     
     (defun git-update-saved-file ()
       "Update the corresponding git-status buffer when a file is saved.
     Meant to be used in `after-save-hook'."
       (let* ((file (expand-file-name buffer-file-name))
              (dir (condition-case nil (git-get-top-dir (file-name-directory file)) (error nil)))
              (buffer (and dir (git-find-status-buffer dir))))
         (when buffer
           (with-current-buffer buffer
             (let ((filename (file-relative-name file dir)))
               ; skip files located inside the .git directory
               (unless (string-match "^\\.git/" filename)
                 (git-call-process nil "add" "--refresh" "--" filename)
                 (git-update-status-files (list filename))))))))
     
     (defun git-help ()
       "Display help for Git mode."
       (interactive)
       (describe-function 'git-status-mode))
     
     (provide 'git)
     ;;; git.el ends here
   #+end_src

   #+begin_src emacs-lisp 
     (require 'git)
     (require 'gitsum)
     (setq git-committer-name "Nurullah Akkaya")
     (setq git-committer-email "nurullah@nakkaya.com")
     
     (when (equal system-type 'darwin)
       (setenv "PATH" (concat "/opt/local/bin:/usr/local/bin:" (getenv "PATH")))
       (push "/opt/local/bin" exec-path))
     (setq exec-path (append exec-path '("/opt/local/bin")))
     
     (defun na-run-git-switch ()
       "Switch to git buffer or run git-status"
       (interactive)  
       (window-configuration-to-register 'z)
       (if (not (eq (get-buffer "*git-status*") nil))
           (switch-to-buffer "*git-status*")
         (git-status (read-directory-name "Select Directory: "))))
     
     (define-key git-status-mode-map (kbd "Q")
       '(lambda ()
          (interactive)
          (jump-to-register 'z)))
     
     (define-key git-status-mode-map (kbd "K")
       '(lambda ()
          (interactive)
          (kill-buffer)
          (jump-to-register 'z)))
   #+end_src

*** htmlize

    #+begin_src emacs-lisp
      ;; htmlize.el -- Convert buffer text and decorations to HTML.
      
      ;; Copyright (C) 1997,1998,1999,2000,2001,2002,2003,2005,2006,2009 Hrvoje Niksic
      
      ;; Author: Hrvoje Niksic <hniksic@xemacs.org>
      ;; Keywords: hypermedia, extensions
      ;; Version: 1.37
      
      ;; This program is free software; you can redistribute it and/or modify
      ;; it under the terms of the GNU General Public License as published by
      ;; the Free Software Foundation; either version 2, or (at your option)
      ;; any later version.
      
      ;; This program is distributed in the hope that it will be useful,
      ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
      ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      ;; GNU General Public License for more details.
      
      ;; You should have received a copy of the GNU General Public License
      ;; along with this program; see the file COPYING.  If not, write to the
      ;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
      ;; Boston, MA 02111-1307, USA.
      
      ;;; Commentary:
      
      ;; This package converts the buffer text and the associated
      ;; decorations to HTML.  Mail to <hniksic@xemacs.org> to discuss
      ;; features and additions.  All suggestions are more than welcome.
      
      ;; To use this, just switch to the buffer you want HTML-ized and type
      ;; `M-x htmlize-buffer'.  You will be switched to a new buffer that
      ;; contains the resulting HTML code.  You can edit and inspect this
      ;; buffer, or you can just save it with C-x C-w.  `M-x htmlize-file'
      ;; will find a file, fontify it, and save the HTML version in
      ;; FILE.html, without any additional intervention.  `M-x
      ;; htmlize-many-files' allows you to htmlize any number of files in
      ;; the same manner.  `M-x htmlize-many-files-dired' does the same for
      ;; files marked in a dired buffer.
      
      ;; htmlize supports three types of HTML output, selected by setting
      ;; `htmlize-output-type': `css', `inline-css', and `font'.  In `css'
      ;; mode, htmlize uses cascading style sheets to specify colors; it
      ;; generates classes that correspond to Emacs faces and uses <span
      ;; class=FACE>...</span> to color parts of text.  In this mode, the
      ;; produced HTML is valid under the 4.01 strict DTD, as confirmed by
      ;; the W3C validator.  `inline-css' is like `css', except the CSS is
      ;; put directly in the STYLE attribute of the SPAN element, making it
      ;; possible to paste the generated HTML to other documents.  In `font'
      ;; mode, htmlize uses <font color="...">...</font> to colorize HTML,
      ;; which is not standard-compliant, but works better in older
      ;; browsers.  `css' mode is the default.
      
      ;; You can also use htmlize from your Emacs Lisp code.  When called
      ;; non-interactively, `htmlize-buffer' and `htmlize-region' will
      ;; return the resulting HTML buffer, but will not change current
      ;; buffer or move the point.
      
      ;; I tried to make the package elisp-compatible with multiple Emacsen,
      ;; specifically aiming for XEmacs 19.14+ and GNU Emacs 19.34+.  Please
      ;; let me know if it doesn't work on some of those, and I'll try to
      ;; fix it.  I relied heavily on the presence of CL extensions,
      ;; especially for cross-emacs compatibility; please don't try to
      ;; remove that particular dependency.  When byte-compiling under GNU
      ;; Emacs, you're likely to get some warnings; just ignore them.
      
      ;; The latest version should be available at:
      ;;
      ;;        <http://fly.srk.fer.hr/~hniksic/emacs/htmlize.el>
      ;;
      ;; You can find a sample of htmlize's output (possibly generated with
      ;; an older version) at:
      ;;
      ;;        <http://fly.srk.fer.hr/~hniksic/emacs/htmlize.el.html>
      
      ;; Thanks go to the multitudes of people who have sent reports and
      ;; contributed comments, suggestions, and fixes.  They include Ron
      ;; Gut, Bob Weiner, Toni Drabik, Peter Breton, Thomas Vogels, Juri
      ;; Linkov, Maciek Pasternacki, and many others.
      
      ;; User quotes: "You sir, are a sick, sick, _sick_ person. :)"
      ;;                  -- Bill Perry, author of Emacs/W3
      
      
      ;;; Code:
      
      (require 'cl)
      (eval-when-compile
        (if (string-match "XEmacs" emacs-version)
            (byte-compiler-options
              (warnings (- unresolved))))
        (defvar font-lock-auto-fontify)
        (defvar font-lock-support-mode)
        (defvar global-font-lock-mode)
        (when (and (eq emacs-major-version 19)
                   (not (string-match "XEmacs" emacs-version)))
          ;; Older versions of GNU Emacs fail to autoload cl-extra even when
          ;; `cl' is loaded.
          (load "cl-extra")))
      
      (defconst htmlize-version "1.37")
      
      ;; Incantations to make custom stuff work without customize, e.g. on
      ;; XEmacs 19.14 or GNU Emacs 19.34.
      (eval-and-compile
        (condition-case ()
            (require 'custom)
          (error nil))
        (if (and (featurep 'custom) (fboundp 'custom-declare-variable))
            nil                               ; we've got what we needed
          ;; No custom or obsolete custom, define surrogates.  Define all
          ;; three macros, so we don't hose another library that expects
          ;; e.g. `defface' to work after (fboundp 'defcustom) succeeds.
          (defmacro defgroup (&rest ignored) nil)
          (defmacro defcustom (var value doc &rest ignored)
            `(defvar ,var ,value ,doc))
          (defmacro defface (face value doc &rest stuff)
            `(make-face ,face))))
      
      (defgroup htmlize nil
        "Convert buffer text and faces to HTML."
        :group 'hypermedia)
      
      (defcustom htmlize-head-tags ""
        "*Additional tags to insert within HEAD of the generated document."
        :type 'string
        :group 'htmlize)
      
      (defcustom htmlize-output-type 'css
        "*Output type of generated HTML, one of `css', `inline-css', or `font'.
      When set to `css' (the default), htmlize will generate a style sheet
      with description of faces, and use it in the HTML document, specifying
      the faces in the actual text with <span class=\"FACE\">.
      
      When set to `inline-css', the style will be generated as above, but
      placed directly in the STYLE attribute of the span ELEMENT: <span
      style=\"STYLE\">.  This makes it easier to paste the resulting HTML to
      other documents.
      
      When set to `font', the properties will be set using layout tags
      <font>, <b>, <i>, <u>, and <strike>.
      
      `css' output is normally preferred, but `font' is still useful for
      supporting old, pre-CSS browsers, and both `inline-css' and `font' for
      easier embedding of colorized text in foreign HTML documents (no style
      sheet to carry around)."
        :type '(choice (const css) (const inline-css) (const font))
        :group 'htmlize)
      
      (defcustom htmlize-generate-hyperlinks t
        "*Non-nil means generate the hyperlinks for URLs and mail addresses.
      This is on by default; set it to nil if you don't want htmlize to
      insert hyperlinks in the resulting HTML.  (In which case you can still
      do your own hyperlinkification from htmlize-after-hook.)"
        :type 'boolean
        :group 'htmlize)
      
      (defcustom htmlize-hyperlink-style "
            a {
              color: inherit;
              background-color: inherit;
              font: inherit;
              text-decoration: inherit;
            }
            a:hover {
              text-decoration: underline;
            }
      "
        "*The CSS style used for hyperlinks when in CSS mode."
        :type 'string
        :group 'htmlize)
      
      (defcustom htmlize-replace-form-feeds t
        "*Non-nil means replace form feeds in source code with HTML separators.
      Form feeds are the ^L characters at line beginnings that are sometimes
      used to separate sections of source code.  If this variable is set to
      `t', form feed characters are replaced with the <hr> separator.  If this
      is a string, it specifies the replacement to use.  Note that <pre> is
      temporarily closed before the separator is inserted, so the default
      replacement is effectively \"</pre><hr /><pre>\".  If you specify
      another replacement, don't forget to close and reopen the <pre> if you
      want the output to remain valid HTML.
      
      If you need more elaborate processing, set this to nil and use
      htmlize-after-hook."
        :type 'boolean
        :group 'htmlize)
      
      (defcustom htmlize-html-charset nil
        "*The charset declared by the resulting HTML documents.
      When non-nil, causes htmlize to insert the following in the HEAD section
      of the generated HTML:
      
        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=CHARSET\">
      
      where CHARSET is the value you've set for htmlize-html-charset.  Valid
      charsets are defined by MIME and include strings like \"iso-8859-1\",
      \"iso-8859-15\", \"utf-8\", etc.
      
      If you are using non-Latin-1 charsets, you might need to set this for
      your documents to render correctly.  Also, the W3C validator requires
      submitted HTML documents to declare a charset.  So if you care about
      validation, you can use this to prevent the validator from bitching.
      
      Needless to say, if you set this, you should actually make sure that
      the buffer is in the encoding you're claiming it is in.  (Under Mule
      that is done by ensuring the correct \"file coding system\" for the
      buffer.)  If you don't understand what that means, this option is
      probably not for you."
        :type '(choice (const :tag "Unset" nil)
                       string)
        :group 'htmlize)
      
      (defcustom htmlize-convert-nonascii-to-entities (featurep 'mule)
        "*Whether non-ASCII characters should be converted to HTML entities.
      
      When this is non-nil, characters with codes in the 128-255 range will be
      considered Latin 1 and rewritten as \"&#CODE;\".  Characters with codes
      above 255 will be converted to \"&#UCS;\", where UCS denotes the Unicode
      code point of the character.  If the code point cannot be determined,
      the character will be copied unchanged, as would be the case if the
      option were nil.
      
      When the option is nil, the non-ASCII characters are copied to HTML
      without modification.  In that case, the web server and/or the browser
      must be set to understand the encoding that was used when saving the
      buffer.  (You might also want to specify it by setting
      `htmlize-html-charset'.)
      
      Note that in an HTML entity \"&#CODE;\", CODE is always a UCS code point,
      which has nothing to do with the charset the page is in.  For example,
      \"&#169;\" *always* refers to the copyright symbol, regardless of charset
      specified by the META tag or the charset sent by the HTTP server.  In
      other words, \"&#169;\" is exactly equivalent to \"&copy;\".
      
      By default, entity conversion is turned on for Mule-enabled Emacsen and
      turned off otherwise.  This is because Mule knows the charset of
      non-ASCII characters in the buffer.  A non-Mule Emacs cannot tell
      whether a character with code 0xA9 represents Latin 1 copyright symbol,
      Latin 2 \"S with caron\", or something else altogether.  Setting this to
      t without Mule means asserting that 128-255 characters always mean Latin
      1.
      
      For most people htmlize will work fine with this option left at the
      default setting; don't change it unless you know what you're doing."
        :type 'sexp
        :group 'htmlize)
      
      (defcustom htmlize-ignore-face-size 'absolute
        "*Whether face size should be ignored when generating HTML.
      If this is nil, face sizes are used.  If set to t, sizes are ignored
      If set to `absolute', only absolute size specifications are ignored.
      Please note that font sizes only work with CSS-based output types."
        :type '(choice (const :tag "Don't ignore" nil)
                       (const :tag "Ignore all" t)
                       (const :tag "Ignore absolute" absolute))
        :group 'htmlize)
      
      (defcustom htmlize-css-name-prefix ""
        "*The prefix used for CSS names.
      The CSS names that htmlize generates from face names are often too
      generic for CSS files; for example, `font-lock-type-face' is transformed
      to `type'.  Use this variable to add a prefix to the generated names.
      The string \"htmlize-\" is an example of a reasonable prefix."
        :type 'string
        :group 'htmlize)
      
      (defcustom htmlize-use-rgb-txt t
        "*Whether `rgb.txt' should be used to convert color names to RGB.
      
      This conversion means determining, for instance, that the color
      \"IndianRed\" corresponds to the (205, 92, 92) RGB triple.  `rgb.txt'
      is the X color database that maps hundreds of color names to such RGB
      triples.  When this variable is non-nil, `htmlize' uses `rgb.txt' to
      look up color names.
      
      If this variable is nil, htmlize queries Emacs for RGB components of
      colors using `color-instance-rgb-components' and `x-color-values'.
      This can yield incorrect results on non-true-color displays.
      
      If the `rgb.txt' file is not found (which will be the case if you're
      running Emacs on non-X11 systems), this option is ignored."
        :type 'boolean
        :group 'htmlize)
      
      (defcustom htmlize-html-major-mode nil
        "The mode the newly created HTML buffer will be put in.
      Set this to nil if you prefer the default (fundamental) mode."
        :type '(radio (const :tag "No mode (fundamental)" nil)
                       (function-item html-mode)
                       (function :tag "User-defined major mode"))
        :group 'htmlize)
      
      (defvar htmlize-before-hook nil
        "Hook run before htmlizing a buffer.
      The hook functions are run in the source buffer (not the resulting HTML
      buffer).")
      
      (defvar htmlize-after-hook nil
        "Hook run after htmlizing a buffer.
      Unlike `htmlize-before-hook', these functions are run in the generated
      HTML buffer.  You may use them to modify the outlook of the final HTML
      output.")
      
      (defvar htmlize-file-hook nil
        "Hook run by `htmlize-file' after htmlizing a file, but before saving it.")
      
      (defvar htmlize-buffer-places)
      
      ;;; Some cross-Emacs compatibility.
      
      ;; I try to conditionalize on features rather than Emacs version, but
      ;; in some cases checking against the version *is* necessary.
      (defconst htmlize-running-xemacs (string-match "XEmacs" emacs-version))
      
      (eval-and-compile
        ;; save-current-buffer, with-current-buffer, and with-temp-buffer
        ;; are not available in 19.34 and in older XEmacsen.  Strictly
        ;; speaking, we should stick to our own namespace and define and use
        ;; htmlize-save-current-buffer, etc.  But non-standard special forms
        ;; are a pain because they're not properly fontified or indented and
        ;; because they look weird and ugly.  So I'll just go ahead and
        ;; define the real ones if they're not available.  If someone
        ;; convinces me that this breaks something, I'll switch to the
        ;; "htmlize-" namespace.
        (unless (fboundp 'save-current-buffer)
          (defmacro save-current-buffer (&rest forms)
            `(let ((__scb_current (current-buffer)))
               (unwind-protect
                   (progn ,@forms)
                 (set-buffer __scb_current)))))
        (unless (fboundp 'with-current-buffer)
          (defmacro with-current-buffer (buffer &rest forms)
            `(save-current-buffer (set-buffer ,buffer) ,@forms)))
        (unless (fboundp 'with-temp-buffer)
          (defmacro with-temp-buffer (&rest forms)
            (let ((temp-buffer (gensym "tb-")))
              `(let ((,temp-buffer
                      (get-buffer-create (generate-new-buffer-name " *temp*"))))
                 (unwind-protect
                     (with-current-buffer ,temp-buffer
                       ,@forms)
                   (and (buffer-live-p ,temp-buffer)
                        (kill-buffer ,temp-buffer))))))))
      
      ;; We need a function that efficiently finds the next change of a
      ;; property (usually `face'), preferably regardless of whether the
      ;; change occurred because of a text property or an extent/overlay.
      ;; As it turns out, it is not easy to do that compatibly.
      ;;
      ;; Under XEmacs, `next-single-property-change' does that.  Under GNU
      ;; Emacs beginning with version 21, `next-single-char-property-change'
      ;; is available and does the same.  GNU Emacs 20 had
      ;; `next-char-property-change', which we can use.  GNU Emacs 19 didn't
      ;; provide any means for simultaneously examining overlays and text
      ;; properties, so when using Emacs 19.34, we punt and fall back to
      ;; `next-single-property-change', thus ignoring overlays altogether.
      
      (cond
       (htmlize-running-xemacs
        ;; XEmacs: good.
        (defun htmlize-next-change (pos prop &optional limit)
          (next-single-property-change pos prop nil (or limit (point-max)))))
       ((fboundp 'next-single-char-property-change)
        ;; GNU Emacs 21: good.
        (defun htmlize-next-change (pos prop &optional limit)
          (next-single-char-property-change pos prop nil limit)))
       ((fboundp 'next-char-property-change)
        ;; GNU Emacs 20: bad, but fixable.
        (defun htmlize-next-change (pos prop &optional limit)
          (let ((done nil)
                (current-value (get-char-property pos prop))
                newpos next-value)
            ;; Loop over positions returned by next-char-property-change
            ;; until the value of PROP changes or we've hit EOB.
            (while (not done)
              (setq newpos (next-char-property-change pos limit)
                    next-value (get-char-property newpos prop))
              (cond ((eq newpos pos)
                     ;; Possibly at EOB?  Whatever, just don't infloop.
                     (setq done t))
                    ((eq next-value current-value)
                     ;; PROP hasn't changed -- keep looping.
                     )
                    (t
                     (setq done t)))
              (setq pos newpos))
            pos)))
       (t
        ;; GNU Emacs 19.34: hopeless, cannot properly support overlays.
        (defun htmlize-next-change (pos prop &optional limit)
          (unless limit
            (setq limit (point-max)))
          (let ((res (next-single-property-change pos prop)))
            (if (or (null res)
                    (> res limit))
                limit
              res)))))
      
      ;;; Transformation of buffer text: HTML escapes, untabification, etc.
      
      (defvar htmlize-basic-character-table
        ;; Map characters in the 0-127 range to either one-character strings
        ;; or to numeric entities.
        (let ((table (make-vector 128 ?\0)))
          ;; Map characters in the 32-126 range to themselves, others to
          ;; &#CODE entities;
          (dotimes (i 128)
            (setf (aref table i) (if (and (>= i 32) (<= i 126))
                                     (char-to-string i)
                                   (format "&#%d;" i))))
          ;; Set exceptions manually.
          (setf
           ;; Don't escape newline, carriage return, and TAB.
           (aref table ?\n) "\n"
           (aref table ?\r) "\r"
           (aref table ?\t) "\t"
           ;; Escape &, <, and >.
           (aref table ?&) "&amp;"
           (aref table ?<) "&lt;"
           (aref table ?>) "&gt;"
           ;; Not escaping '"' buys us a measurable speedup.  It's only
           ;; necessary to quote it for strings used in attribute values,
           ;; which htmlize doesn't do.
           ;(aref table ?\") "&quot;"
           )
          table))
      
      ;; A cache of HTML representation of non-ASCII characters.  Depending
      ;; on availability of `encode-char' and the setting of
      ;; `htmlize-convert-nonascii-to-entities', this maps non-ASCII
      ;; characters to either "&#<code>;" or "<char>" (mapconcat's mapper
      ;; must always return strings).  It's only filled as characters are
      ;; encountered, so that in a buffer with e.g. French text, it will
      ;; only ever contain French accented characters as keys.  It's cleared
      ;; on each entry to htmlize-buffer-1 to allow modifications of
      ;; `htmlize-convert-nonascii-to-entities' to take effect.
      (defvar htmlize-extended-character-cache (make-hash-table :test 'eq))
      
      (defun htmlize-protect-string (string)
        "HTML-protect string, escaping HTML metacharacters and I18N chars."
        ;; Only protecting strings that actually contain unsafe or non-ASCII
        ;; chars removes a lot of unnecessary funcalls and consing.
        (if (not (string-match "[^\r\n\t -%'-;=?-~]" string))
            string
          (mapconcat (lambda (char)
                       (cond
                        ((< char 128)
                         ;; ASCII: use htmlize-basic-character-table.
                         (aref htmlize-basic-character-table char))
                        ((gethash char htmlize-extended-character-cache)
                         ;; We've already seen this char; return the cached
                         ;; string.
                         )
                        ((not htmlize-convert-nonascii-to-entities)
                         ;; If conversion to entities is not desired, always
                         ;; copy the char literally.
                         (setf (gethash char htmlize-extended-character-cache)
                               (char-to-string char)))
                        ((< char 256)
                         ;; Latin 1: no need to call encode-char.
                         (setf (gethash char htmlize-extended-character-cache)
                               (format "&#%d;" char)))
                        ((and (fboundp 'encode-char)
                              ;; Must check if encode-char works for CHAR;
                              ;; it fails for Arabic and possibly elsewhere.
                              (encode-char char 'ucs))
                         (setf (gethash char htmlize-extended-character-cache)
                               (format "&#%d;" (encode-char char 'ucs))))
                        (t
                         ;; encode-char doesn't work for this char.  Copy it
                         ;; unchanged and hope for the best.
                         (setf (gethash char htmlize-extended-character-cache)
                               (char-to-string char)))))
                     string "")))
      
      (defconst htmlize-ellipsis "...")
      (put-text-property 0 (length htmlize-ellipsis) 'htmlize-ellipsis t htmlize-ellipsis)
      
      (defun htmlize-buffer-substring-no-invisible (beg end)
        ;; Like buffer-substring-no-properties, but don't copy invisible
        ;; parts of the region.  Where buffer-substring-no-properties
        ;; mandates an ellipsis to be shown, htmlize-ellipsis is inserted.
        (let ((pos beg)
              visible-list invisible show next-change)
          ;; Iterate over the changes in the `invisible' property and filter
          ;; out the portions where it's non-nil, i.e. where the text is
          ;; invisible.
          (while (< pos end)
            (setq invisible (get-char-property pos 'invisible)
                  next-change (htmlize-next-change pos 'invisible end))
            (if (not (listp buffer-invisibility-spec))
                ;; If buffer-invisibility-spec is not a list, then all
                ;; characters with non-nil `invisible' property are visible.
                (setq show (not invisible))
              ;; Otherwise, the value of a non-nil `invisible' property can be:
              ;; 1. a symbol -- make the text invisible if it matches
              ;;    buffer-invisibility-spec.
              ;; 2. a list of symbols -- make the text invisible if
              ;;    any symbol in the list matches
              ;;    buffer-invisibility-spec.
              ;; If the match of buffer-invisibility-spec has a non-nil
              ;; CDR, replace the invisible text with an ellipsis.
              (let (match)
                (if (symbolp invisible)
                    (setq match (member* invisible buffer-invisibility-spec
                                         :key (lambda (i)
                                                (if (symbolp i) i (car i)))))
                  (setq match (block nil
                                (dolist (elem invisible)
                                  (let ((m (member*
                                            elem buffer-invisibility-spec
                                            :key (lambda (i)
                                                   (if (symbolp i) i (car i))))))
                                    (when m (return m))))
                                nil)))
                (setq show (cond ((null match) t)
                                 ((and (cdr-safe (car match))
                                       ;; Conflate successive ellipses.
                                       (not (eq show htmlize-ellipsis)))
                                  htmlize-ellipsis)
                                 (t nil)))))
            (cond ((eq show t)
                   (push (buffer-substring-no-properties pos next-change) visible-list))
                  ((stringp show)
                   (push show visible-list)))
            (setq pos next-change))
          (if (= (length visible-list) 1)
              ;; If VISIBLE-LIST consists of only one element, return it
              ;; without concatenation.  This avoids additional consing in
              ;; regions without any invisible text.
              (car visible-list)
            (apply #'concat (nreverse visible-list)))))
      
      (defun htmlize-trim-ellipsis (text)
        ;; Remove htmlize-ellipses ("...") from the beginning of TEXT if it
        ;; starts with it.  It checks for the special property of the
        ;; ellipsis so it doesn't work on ordinary text that begins with
        ;; "...".
        (if (get-text-property 0 'htmlize-ellipsis text)
            (substring text (length htmlize-ellipsis))
          text))
      
      (defconst htmlize-tab-spaces
        ;; A table of strings with spaces.  (aref htmlize-tab-spaces 5) is
        ;; like (make-string 5 ?\ ), except it doesn't cons.
        (let ((v (make-vector 32 nil)))
          (dotimes (i (length v))
            (setf (aref v i) (make-string i ?\ )))
          v))
      
      (defun htmlize-untabify (text start-column)
        "Untabify TEXT, assuming it starts at START-COLUMN."
        (let ((column start-column)
              (last-match 0)
              (chunk-start 0)
              chunks match-pos tab-size)
          (while (string-match "[\t\n]" text last-match)
            (setq match-pos (match-beginning 0))
            (cond ((eq (aref text match-pos) ?\t)
                   ;; Encountered a tab: create a chunk of text followed by
                   ;; the expanded tab.
                   (push (substring text chunk-start match-pos) chunks)
                   ;; Increase COLUMN by the length of the text we've
                   ;; skipped since last tab or newline.  (Encountering
                   ;; newline resets it.)
                   (incf column (- match-pos last-match))
                   ;; Calculate tab size based on tab-width and COLUMN.
                   (setq tab-size (- tab-width (% column tab-width)))
                   ;; Expand the tab.
                   (push (aref htmlize-tab-spaces tab-size) chunks)
                   (incf column tab-size)
                   (setq chunk-start (1+ match-pos)))
                  (t
                   ;; Reset COLUMN at beginning of line.
                   (setq column 0)))
            (setq last-match (1+ match-pos)))
          ;; If no chunks have been allocated, it means there have been no
          ;; tabs to expand.  Return TEXT unmodified.
          (if (null chunks)
              text
            (when (< chunk-start (length text))
              ;; Push the remaining chunk.
              (push (substring text chunk-start) chunks))
            ;; Generate the output from the available chunks.
            (apply #'concat (nreverse chunks)))))
      
      (defun htmlize-despam-address (string)
        "Replace every occurrence of '@' in STRING with &#64;.
      `htmlize-make-hyperlinks' uses this to spam-protect mailto links
      without modifying their meaning."
        ;; Suggested by Ville Skytta.
        (while (string-match "@" string)
          (setq string (replace-match "&#64;" nil t string)))
        string)
      
      (defun htmlize-make-hyperlinks ()
        "Make hyperlinks in HTML."
        ;; Function originally submitted by Ville Skytta.  Rewritten by
        ;; Hrvoje Niksic, then modified by Ville Skytta and Hrvoje Niksic.
        (goto-char (point-min))
        (while (re-search-forward
                "&lt;\\(\\(mailto:\\)?\\([-=+_.a-zA-Z0-9]+@[-_.a-zA-Z0-9]+\\)\\)&gt;"
                nil t)
          (let ((address (match-string 3))
                (link-text (match-string 1)))
            (delete-region (match-beginning 0) (match-end 0))
            (insert "&lt;<a href=\"mailto:"
                    (htmlize-despam-address address)
                    "\">"
                    (htmlize-despam-address link-text)
                    "</a>&gt;")))
        (goto-char (point-min))
        (while (re-search-forward "&lt;\\(\\(URL:\\)?\\([a-zA-Z]+://[^;]+\\)\\)&gt;"
                                  nil t)
          (let ((url (match-string 3))
                (link-text (match-string 1)))
            (delete-region (match-beginning 0) (match-end 0))
            (insert "&lt;<a href=\"" url "\">" link-text "</a>&gt;"))))
      
      ;; Tests for htmlize-make-hyperlinks:
      
      ;; <mailto:hniksic@xemacs.org>
      ;; <http://fly.srk.fer.hr>
      ;; <URL:http://www.xemacs.org>
      ;; <http://www.mail-archive.com/bbdb-info@xemacs.org/>
      ;; <hniksic@xemacs.org>
      ;; <xalan-dev-sc.10148567319.hacuhiucknfgmpfnjcpg-john=doe.com@xml.apache.org>
      
      (defun htmlize-defang-local-variables ()
        ;; Juri Linkov reports that an HTML-ized "Local variables" can lead
        ;; visiting the HTML to fail with "Local variables list is not
        ;; properly terminated".  He suggested changing the phrase to
        ;; syntactically equivalent HTML that Emacs doesn't recognize.
        (goto-char (point-min))
        (while (search-forward "Local Variables:" nil t)
          (replace-match "Local Variables&#58;" nil t)))
        
      
      ;;; Color handling.
      
      (if (fboundp 'locate-file)
          (defalias 'htmlize-locate-file 'locate-file)
        (defun htmlize-locate-file (file path)
          (dolist (dir path nil)
            (when (file-exists-p (expand-file-name file dir))
              (return (expand-file-name file dir))))))
      
      (defvar htmlize-x-library-search-path
        '("/usr/X11R6/lib/X11/"
          "/usr/X11R5/lib/X11/"
          "/usr/lib/X11R6/X11/"
          "/usr/lib/X11R5/X11/"
          "/usr/local/X11R6/lib/X11/"
          "/usr/local/X11R5/lib/X11/"
          "/usr/local/lib/X11R6/X11/"
          "/usr/local/lib/X11R5/X11/"
          "/usr/X11/lib/X11/"
          "/usr/lib/X11/"
          "/usr/local/lib/X11/"
          "/usr/X386/lib/X11/"
          "/usr/x386/lib/X11/"
          "/usr/XFree86/lib/X11/"
          "/usr/unsupported/lib/X11/"
          "/usr/athena/lib/X11/"
          "/usr/local/x11r5/lib/X11/"
          "/usr/lpp/Xamples/lib/X11/"
          "/usr/openwin/lib/X11/"
          "/usr/openwin/share/lib/X11/"))
      
      (defun htmlize-get-color-rgb-hash (&optional rgb-file)
        "Return a hash table mapping X color names to RGB values.
      The keys in the hash table are X11 color names, and the values are the
      #rrggbb RGB specifications, extracted from `rgb.txt'.
      
      If RGB-FILE is nil, the function will try hard to find a suitable file
      in the system directories.
      
      If no rgb.txt file is found, return nil."
        (let ((rgb-file (or rgb-file (htmlize-locate-file
                                      "rgb.txt"
                                      htmlize-x-library-search-path)))
              (hash nil))
          (when rgb-file
            (with-temp-buffer
              (insert-file-contents rgb-file)
              (setq hash (make-hash-table :test 'equal))
              (while (not (eobp))
                (cond ((looking-at "^\\s-*\\([!#]\\|$\\)")
                       ;; Skip comments and empty lines.
                       )
                      ((looking-at
                        "[ \t]*\\([0-9]+\\)[ \t]+\\([0-9]+\\)[ \t]+\\([0-9]+\\)[ \t]+\\(.*\\)")
                       (setf (gethash (downcase (match-string 4)) hash)
                             (format "#%02x%02x%02x"
                                     (string-to-number (match-string 1))
                                     (string-to-number (match-string 2))
                                     (string-to-number (match-string 3)))))
                      (t
                       (error
                        "Unrecognized line in %s: %s"
                        rgb-file
                        (buffer-substring (point) (progn (end-of-line) (point))))))
                (forward-line 1))))
          hash))
      
      ;; Compile the RGB map when loaded.  On systems where rgb.txt is
      ;; missing, the value of the variable will be nil, and rgb.txt will
      ;; not be used.
      (defvar htmlize-color-rgb-hash (htmlize-get-color-rgb-hash))
      
      ;;; Face handling.
      
      (defun htmlize-face-specifies-property (face prop)
        ;; Return t if face specifies PROP, as opposed to it being inherited
        ;; from the default face.  The problem with e.g.
        ;; `face-foreground-instance' is that it returns an instance for
        ;; EVERY face because every face inherits from the default face.
        ;; However, we'd like htmlize-face-{fore,back}ground to return nil
        ;; when called with a face that doesn't specify its own foreground
        ;; or background.
        (or (eq face 'default)
            (assq 'global (specifier-spec-list (face-property face prop)))))
      
      (defun htmlize-face-color-internal (face fg)
        ;; Used only under GNU Emacs.  Return the color of FACE, but don't
        ;; return "unspecified-fg" or "unspecified-bg".  If the face is
        ;; `default' and the color is unspecified, look up the color in
        ;; frame parameters.
        (let* ((function (if fg #'face-foreground #'face-background))
               color)
          (if (>= emacs-major-version 22)
              ;; For GNU Emacs 22+ set INHERIT to get the inherited values.
              (setq color (funcall function face nil t))
            (setq color (funcall function face))
            ;; For GNU Emacs 21 (which has `face-attribute'): if the color
            ;; is nil, recursively check for the face's parent.
            (when (and (null color)
                       (fboundp 'face-attribute)
                       (face-attribute face :inherit)
                       (not (eq (face-attribute face :inherit) 'unspecified)))
              (setq color (htmlize-face-color-internal
                           (face-attribute face :inherit) fg))))
          (when (and (eq face 'default) (null color))
            (setq color (cdr (assq (if fg 'foreground-color 'background-color)
                                   (frame-parameters)))))
          (when (or (eq color 'unspecified)
                    (equal color "unspecified-fg")
                    (equal color "unspecified-bg"))
            (setq color nil))
          (when (and (eq face 'default)
                     (null color))
            ;; Assuming black on white doesn't seem right, but I can't think
            ;; of anything better to do.
            (setq color (if fg "black" "white")))
          color))
      
      (defun htmlize-face-foreground (face)
        ;; Return the name of the foreground color of FACE.  If FACE does
        ;; not specify a foreground color, return nil.
        (cond (htmlize-running-xemacs
               ;; XEmacs.
               (and (htmlize-face-specifies-property face 'foreground)
                    (color-instance-name (face-foreground-instance face))))
              (t
               ;; GNU Emacs.
               (htmlize-face-color-internal face t))))
      
      (defun htmlize-face-background (face)
        ;; Return the name of the background color of FACE.  If FACE does
        ;; not specify a background color, return nil.
        (cond (htmlize-running-xemacs
               ;; XEmacs.
               (and (htmlize-face-specifies-property face 'background)
                    (color-instance-name (face-background-instance face))))
              (t
               ;; GNU Emacs.
               (htmlize-face-color-internal face nil))))
      
      ;; Convert COLOR to the #RRGGBB string.  If COLOR is already in that
      ;; format, it's left unchanged.
      
      (defun htmlize-color-to-rgb (color)
        (let ((rgb-string nil))
          (cond ((null color)
                 ;; Ignore nil COLOR because it means that the face is not
                 ;; specifying any color.  Hence (htmlize-color-to-rgb nil)
                 ;; returns nil.
                 )
                ((string-match "\\`#" color)
                 ;; The color is already in #rrggbb format.
                 (setq rgb-string color))
                ((and htmlize-use-rgb-txt
                      htmlize-color-rgb-hash)
                 ;; Use of rgb.txt is requested, and it's available on the
                 ;; system.  Use it.
                 (setq rgb-string (gethash (downcase color) htmlize-color-rgb-hash)))
                (t
                 ;; We're getting the RGB components from Emacs.
                 (let ((rgb
                        ;; Here I cannot conditionalize on (fboundp ...) 
                        ;; because ps-print under some versions of GNU Emacs
                        ;; defines its own dummy version of
                        ;; `color-instance-rgb-components'.
                        (if htmlize-running-xemacs
                            (mapcar (lambda (arg)
                                      (/ arg 256))
                                    (color-instance-rgb-components
                                     (make-color-instance color)))
                          (mapcar (lambda (arg)
                                    (/ arg 256))
                                  (x-color-values color)))))
                   (when rgb
                     (setq rgb-string (apply #'format "#%02x%02x%02x" rgb))))))
          ;; If RGB-STRING is still nil, it means the color cannot be found,
          ;; for whatever reason.  In that case just punt and return COLOR.
          ;; Most browsers support a decent set of color names anyway.
          (or rgb-string color)))
      
      ;; We store the face properties we care about into an
      ;; `htmlize-fstruct' type.  That way we only have to analyze face
      ;; properties, which can be time consuming, once per each face.  The
      ;; mapping between Emacs faces and htmlize-fstructs is established by
      ;; htmlize-make-face-map.  The name "fstruct" refers to variables of
      ;; type `htmlize-fstruct', while the term "face" is reserved for Emacs
      ;; faces.
      
      (defstruct htmlize-fstruct
        foreground                            ; foreground color, #rrggbb
        background                            ; background color, #rrggbb
        size                                  ; size
        boldp                                 ; whether face is bold
        italicp                               ; whether face is italic
        underlinep                            ; whether face is underlined
        overlinep                             ; whether face is overlined
        strikep                               ; whether face is struck through
        css-name                              ; CSS name of face
        )
      
      (defun htmlize-face-emacs21-attr (fstruct attr value)
        ;; For ATTR and VALUE, set the equivalent value in FSTRUCT.
        (case attr
          (:foreground
           (setf (htmlize-fstruct-foreground fstruct) (htmlize-color-to-rgb value)))
          (:background
           (setf (htmlize-fstruct-background fstruct) (htmlize-color-to-rgb value)))
          (:height
           (setf (htmlize-fstruct-size fstruct) value))
          (:weight
           (when (string-match (symbol-name value) "bold")
             (setf (htmlize-fstruct-boldp fstruct) t)))
          (:slant
           (setf (htmlize-fstruct-italicp fstruct) (or (eq value 'italic)
                                                       (eq value 'oblique))))
          (:bold
           (setf (htmlize-fstruct-boldp fstruct) value))
          (:italic
           (setf (htmlize-fstruct-italicp fstruct) value))
          (:underline
           (setf (htmlize-fstruct-underlinep fstruct) value))
          (:overline
           (setf (htmlize-fstruct-overlinep fstruct) value))
          (:strike-through
           (setf (htmlize-fstruct-strikep fstruct) value))))
      
      (defun htmlize-face-size (face)
        ;; The size (height) of FACE, taking inheritance into account.
        ;; Only works in Emacs 21 and later.
        (let ((size-list
               (loop
                for f = face then (face-attribute f :inherit)
                until (or (not f) (eq f 'unspecified))
                for h = (face-attribute f :height)
                collect (if (eq h 'unspecified) nil h))))
          (reduce 'htmlize-merge-size (cons nil size-list))))
      
      (defun htmlize-face-to-fstruct (face)
        "Convert Emacs face FACE to fstruct."
        (let ((fstruct (make-htmlize-fstruct
                        :foreground (htmlize-color-to-rgb
                                     (htmlize-face-foreground face))
                        :background (htmlize-color-to-rgb
                                     (htmlize-face-background face)))))
          (cond (htmlize-running-xemacs
                 ;; XEmacs doesn't provide a way to detect whether a face is
                 ;; bold or italic, so we need to examine the font instance.
                 ;; #### This probably doesn't work under MS Windows and/or
                 ;; GTK devices.  I'll need help with those.
                 (let* ((font-instance (face-font-instance face))
                        (props (font-instance-properties font-instance)))
                   (when (equalp (cdr (assq 'WEIGHT_NAME props)) "bold")
                     (setf (htmlize-fstruct-boldp fstruct) t))
                   (when (or (equalp (cdr (assq 'SLANT props)) "i")
                             (equalp (cdr (assq 'SLANT props)) "o"))
                     (setf (htmlize-fstruct-italicp fstruct) t))
                   (setf (htmlize-fstruct-strikep fstruct)
                         (face-strikethru-p face))
                   (setf (htmlize-fstruct-underlinep fstruct)
                         (face-underline-p face))))
                ((fboundp 'face-attribute)
                 ;; GNU Emacs 21 and further.
                 (dolist (attr '(:weight :slant :underline :overline :strike-through))
                   (let ((value (if (>= emacs-major-version 22)
                                    ;; Use the INHERIT arg in GNU Emacs 22.
                                    (face-attribute face attr nil t)
                                  ;; Otherwise, fake it.
                                  (let ((face face))
                                    (while (and (eq (face-attribute face attr)
                                                    'unspecified)
                                                (not (eq (face-attribute face :inherit)
                                                         'unspecified)))
                                      (setq face (face-attribute face :inherit)))
                                    (face-attribute face attr)))))
                     (when (and value (not (eq value 'unspecified)))
                       (htmlize-face-emacs21-attr fstruct attr value))))
                 (let ((size (htmlize-face-size face)))
                   (unless (eql size 1.0)     ; ignore non-spec
                     (setf (htmlize-fstruct-size fstruct) size))))
                (t
                 ;; Older GNU Emacs.  Some of these functions are only
                 ;; available under Emacs 20+, hence the guards.
                 (when (fboundp 'face-bold-p)
                   (setf (htmlize-fstruct-boldp fstruct) (face-bold-p face)))
                 (when (fboundp 'face-italic-p)
                   (setf (htmlize-fstruct-italicp fstruct) (face-italic-p face)))
                 (setf (htmlize-fstruct-underlinep fstruct)
                       (face-underline-p face))))
          ;; Generate the css-name property.  Emacs places no restrictions
          ;; on the names of symbols that represent faces -- any characters
          ;; may be in the name, even ^@.  We try hard to beat the face name
          ;; into shape, both esthetically and according to CSS1 specs.
          (setf (htmlize-fstruct-css-name fstruct)
                (let ((name (downcase (symbol-name face))))
                  (when (string-match "\\`font-lock-" name)
                    ;; Change font-lock-FOO-face to FOO.
                    (setq name (replace-match "" t t name)))
                  (when (string-match "-face\\'" name)
                    ;; Drop the redundant "-face" suffix.
                    (setq name (replace-match "" t t name)))
                  (while (string-match "[^-a-zA-Z0-9]" name)
                    ;; Drop the non-alphanumerics.
                    (setq name (replace-match "X" t t name)))
                  (when (string-match "\\`[-0-9]" name)
                    ;; CSS identifiers may not start with a digit.
                    (setq name (concat "X" name)))
                  ;; After these transformations, the face could come
                  ;; out empty.
                  (when (equal name "")
                    (setq name "face"))
                  ;; Apply the prefix.
                  (setq name (concat htmlize-css-name-prefix name))
                  name))
          fstruct))
      
      (defmacro htmlize-copy-attr-if-set (attr-list dest source)
        ;; Expand the code of the type
        ;; (and (htmlize-fstruct-ATTR source)
        ;;      (setf (htmlize-fstruct-ATTR dest) (htmlize-fstruct-ATTR source)))
        ;; for the given list of boolean attributes.
        (cons 'progn
              (loop for attr in attr-list
                    for attr-sym = (intern (format "htmlize-fstruct-%s" attr))
                    collect `(and (,attr-sym ,source)
                                  (setf (,attr-sym ,dest) (,attr-sym ,source))))))
      
      (defun htmlize-merge-size (merged next)
        ;; Calculate the size of the merge of MERGED and NEXT.
        (cond ((null merged)     next)
              ((integerp next)   next)
              ((null next)       merged)
              ((floatp merged)   (* merged next))
              ((integerp merged) (round (* merged next)))))
      
      (defun htmlize-merge-two-faces (merged next)
        (htmlize-copy-attr-if-set
         (foreground background boldp italicp underlinep overlinep strikep)
         merged next)
        (setf (htmlize-fstruct-size merged)
              (htmlize-merge-size (htmlize-fstruct-size merged)
                                  (htmlize-fstruct-size next)))
        merged)
      
      (defun htmlize-merge-faces (fstruct-list)
        (cond ((null fstruct-list)
               ;; Nothing to do, return a dummy face.
               (make-htmlize-fstruct))
              ((null (cdr fstruct-list))
               ;; Optimize for the common case of a single face, simply
               ;; return it.
               (car fstruct-list))
              (t
               (reduce #'htmlize-merge-two-faces
                       (cons (make-htmlize-fstruct) fstruct-list)))))
      
      ;; GNU Emacs 20+ supports attribute lists in `face' properties.  For
      ;; example, you can use `(:foreground "red" :weight bold)' as an
      ;; overlay's "face", or you can even use a list of such lists, etc.
      ;; We call those "attrlists".
      ;;
      ;; htmlize supports attrlist by converting them to fstructs, the same
      ;; as with regular faces.
      
      (defun htmlize-attrlist-to-fstruct (attrlist)
        ;; Like htmlize-face-to-fstruct, but accepts an ATTRLIST as input.
        (let ((fstruct (make-htmlize-fstruct)))
          (cond ((eq (car attrlist) 'foreground-color)
                 ;; ATTRLIST is (foreground-color . COLOR)
                 (setf (htmlize-fstruct-foreground fstruct)
                       (htmlize-color-to-rgb (cdr attrlist))))
                ((eq (car attrlist) 'background-color)
                 ;; ATTRLIST is (background-color . COLOR)
                 (setf (htmlize-fstruct-background fstruct)
                       (htmlize-color-to-rgb (cdr attrlist))))
                (t
                 ;; ATTRLIST is a plist.
                 (while attrlist
                   (let ((attr (pop attrlist))
                         (value (pop attrlist)))
                     (when (and value (not (eq value 'unspecified)))
                       (htmlize-face-emacs21-attr fstruct attr value))))))
          (setf (htmlize-fstruct-css-name fstruct) "ATTRLIST")
          fstruct))
      
      (defun htmlize-face-list-p (face-prop)
        "Return non-nil if FACE-PROP is a list of faces, nil otherwise."
        ;; If not for attrlists, this would return (listp face-prop).  This
        ;; way we have to be more careful because attrlist is also a list!
        (cond
         ((eq face-prop nil)
          ;; FACE-PROP being nil means empty list (no face), so return t.
          t)
         ((symbolp face-prop)
          ;; A symbol other than nil means that it's only one face, so return
          ;; nil.
          nil)
         ((not (consp face-prop))
          ;; Huh?  Not a symbol or cons -- treat it as a single element.
          nil)
         (t
          ;; We know that FACE-PROP is a cons: check whether it looks like an
          ;; ATTRLIST.
          (let* ((car (car face-prop))
                 (attrlist-p (and (symbolp car)
                                  (or (eq car 'foreground-color)
                                      (eq car 'background-color)
                                      (eq (aref (symbol-name car) 0) ?:)))))
            ;; If FACE-PROP is not an ATTRLIST, it means it's a list of
            ;; faces.
            (not attrlist-p)))))
      
      (defun htmlize-make-face-map (faces)
        ;; Return a hash table mapping Emacs faces to htmlize's fstructs.
        ;; The keys are either face symbols or attrlists, so the test
        ;; function must be `equal'.
        (let ((face-map (make-hash-table :test 'equal))
              css-names)
          (dolist (face faces)
            (unless (gethash face face-map)
              ;; Haven't seen FACE yet; convert it to an fstruct and cache
              ;; it.
              (let ((fstruct (if (symbolp face)
                                 (htmlize-face-to-fstruct face)
                               (htmlize-attrlist-to-fstruct face))))
                (setf (gethash face face-map) fstruct)
                (let* ((css-name (htmlize-fstruct-css-name fstruct))
                       (new-name css-name)
                       (i 0))
                  ;; Uniquify the face's css-name by using NAME-1, NAME-2,
                  ;; etc.
                  (while (member new-name css-names)
                    (setq new-name (format "%s-%s" css-name (incf i))))
                  (unless (equal new-name css-name)
                    (setf (htmlize-fstruct-css-name fstruct) new-name))
                  (push new-name css-names)))))
          face-map))
      
      (defun htmlize-unstringify-face (face)
        "If FACE is a string, return it interned, otherwise return it unchanged."
        (if (stringp face)
            (intern face)
          face))
      
      (defun htmlize-faces-in-buffer ()
        "Return a list of faces used in the current buffer.
      Under XEmacs, this returns the set of faces specified by the extents
      with the `face' property.  (This covers text properties as well.)  Under
      GNU Emacs, it returns the set of faces specified by the `face' text
      property and by buffer overlays that specify `face'."
        (let (faces)
          ;; Testing for (fboundp 'map-extents) doesn't work because W3
          ;; defines `map-extents' under FSF.
          (if htmlize-running-xemacs
              (let (face-prop)
                (map-extents (lambda (extent ignored)
                               (setq face-prop (extent-face extent)
                                     ;; FACE-PROP can be a face or a list of
                                     ;; faces.
                                     faces (if (listp face-prop)
                                               (union face-prop faces)
                                             (adjoin face-prop faces)))
                               nil)
                             nil
                             ;; Specify endpoints explicitly to respect
                             ;; narrowing.
                             (point-min) (point-max) nil nil 'face))
            ;; FSF Emacs code.
            ;; Faces used by text properties.
            (let ((pos (point-min)) face-prop next)
              (while (< pos (point-max))
                (setq face-prop (get-text-property pos 'face)
                      next (or (next-single-property-change pos 'face) (point-max)))
                ;; FACE-PROP can be a face/attrlist or a list thereof.
                (setq faces (if (htmlize-face-list-p face-prop)
                                (nunion (mapcar #'htmlize-unstringify-face face-prop)
                                        faces :test 'equal)
                              (adjoin (htmlize-unstringify-face face-prop)
                                      faces :test 'equal)))
                (setq pos next)))
            ;; Faces used by overlays.
            (dolist (overlay (overlays-in (point-min) (point-max)))
              (let ((face-prop (overlay-get overlay 'face)))
                ;; FACE-PROP can be a face/attrlist or a list thereof.
                (setq faces (if (htmlize-face-list-p face-prop)
                                (nunion (mapcar #'htmlize-unstringify-face face-prop)
                                        faces :test 'equal)
                              (adjoin (htmlize-unstringify-face face-prop)
                                      faces :test 'equal))))))
          faces))
      
      ;; htmlize-faces-at-point returns the faces in use at point.  The
      ;; faces are sorted by increasing priority, i.e. the last face takes
      ;; precedence.
      ;;
      ;; Under XEmacs, this returns all the faces in all the extents at
      ;; point.  Under GNU Emacs, this returns all the faces in the `face'
      ;; property and all the faces in the overlays at point.
      
      (cond (htmlize-running-xemacs
             (defun htmlize-faces-at-point ()
               (let (extent extent-list face-list face-prop)
                 (while (setq extent (extent-at (point) nil 'face extent))
                   (push extent extent-list))
                 ;; extent-list is in reverse display order, meaning that
                 ;; smallest ones come last.  That is the order we want,
                 ;; except it can be overridden by the `priority' property.
                 (setq extent-list (stable-sort extent-list #'<
                                                :key #'extent-priority))
                 (dolist (extent extent-list)
                   (setq face-prop (extent-face extent))
                   ;; extent's face-list is in reverse order from what we
                   ;; want, but the `nreverse' below will take care of it.
                   (setq face-list (if (listp face-prop)
                                       (append face-prop face-list)
                                     (cons face-prop face-list))))
                 (nreverse face-list))))
            (t
             (defun htmlize-faces-at-point ()
               (let (all-faces)
                 ;; Faces from text properties.
                 (let ((face-prop (get-text-property (point) 'face)))
                   (setq all-faces (if (htmlize-face-list-p face-prop)
                                       (nreverse (mapcar #'htmlize-unstringify-face
                                                         face-prop))
                                     (list (htmlize-unstringify-face face-prop)))))
                 ;; Faces from overlays.
                 (let ((overlays
                        ;; Collect overlays at point that specify `face'.
                        (delete-if-not (lambda (o)
                                         (overlay-get o 'face))
                                       (overlays-at (point))))
                       list face-prop)
                   ;; Sort the overlays so the smaller (more specific) ones
                   ;; come later.  The number of overlays at each one
                   ;; position should be very small, so the sort shouldn't
                   ;; slow things down.
                   (setq overlays (sort* overlays
                                         ;; Sort by ascending...
                                         #'<
                                         ;; ...overlay size.
                                         :key (lambda (o)
                                                (- (overlay-end o)
                                                   (overlay-start o)))))
                   ;; Overlay priorities, if present, override the above
                   ;; established order.  Larger overlay priority takes
                   ;; precedence and therefore comes later in the list.
                   (setq overlays (stable-sort
                                   overlays
                                   ;; Reorder (stably) by acending...
                                   #'<
                                   ;; ...overlay priority.
                                   :key (lambda (o)
                                          (or (overlay-get o 'priority) 0))))
                   (dolist (overlay overlays)
                     (setq face-prop (overlay-get overlay 'face))
                     (setq list (if (htmlize-face-list-p face-prop)
                                    (nconc (nreverse (mapcar
                                                      #'htmlize-unstringify-face
                                                      face-prop))
                                           list)
                                  (cons (htmlize-unstringify-face face-prop) list))))
                   ;; Under "Merging Faces" the manual explicitly states
                   ;; that faces specified by overlays take precedence over
                   ;; faces specified by text properties.
                   (setq all-faces (nconc all-faces list)))
                 all-faces))))
      
      ;; htmlize supports generating HTML in two several fundamentally
      ;; different ways, one with the use of CSS and nested <span> tags, and
      ;; the other with the use of the old <font> tags.  Rather than adding
      ;; a bunch of ifs to many places, we take a semi-OO approach.
      ;; `htmlize-buffer-1' calls a number of "methods", which indirect to
      ;; the functions that depend on `htmlize-output-type'.  The currently
      ;; used methods are `doctype', `insert-head', `body-tag', and
      ;; `insert-text'.  Not all output types define all methods.
      ;;
      ;; Methods are called either with (htmlize-method METHOD ARGS...) 
      ;; special form, or by accessing the function with
      ;; (htmlize-method-function 'METHOD) and calling (funcall FUNCTION).
      ;; The latter form is useful in tight loops because `htmlize-method'
      ;; conses.
      ;;
      ;; Currently defined output types are `css' and `font'.
      
      (defmacro htmlize-method (method &rest args)
        ;; Expand to (htmlize-TYPE-METHOD ...ARGS...).  TYPE is the value of
        ;; `htmlize-output-type' at run time.
        `(funcall (htmlize-method-function ',method) ,@args))
      
      (defun htmlize-method-function (method)
        ;; Return METHOD's function definition for the current output type.
        ;; The returned object can be safely funcalled.
        (let ((sym (intern (format "htmlize-%s-%s" htmlize-output-type method))))
          (indirect-function (if (fboundp sym)
                                 sym
                               (let ((default (intern (concat "htmlize-default-"
                                                              (symbol-name method)))))
                                 (if (fboundp default)
                                     default
                                   'ignore))))))
      
      (defvar htmlize-memoization-table (make-hash-table :test 'equal))
      
      (defmacro htmlize-memoize (key generator)
        "Return the value of GENERATOR, memoized as KEY.
      That means that GENERATOR will be evaluated and returned the first time
      it's called with the same value of KEY.  All other times, the cached
      \(memoized) value will be returned."
        (let ((value (gensym)))
          `(let ((,value (gethash ,key htmlize-memoization-table)))
             (unless ,value
               (setq ,value ,generator)
               (setf (gethash ,key htmlize-memoization-table) ,value))
             ,value)))
      
      ;;; Default methods.
      
      (defun htmlize-default-doctype ()
        nil                                   ; no doc-string
        ;; According to DTDs published by the W3C, it is illegal to embed
        ;; <font> in <pre>.  This makes sense in general, but is bad for
        ;; htmlize's intended usage of <font> to specify the document color.
      
        ;; To make generated HTML legal, htmlize's `font' mode used to
        ;; specify the SGML declaration of "HTML Pro" DTD here.  HTML Pro
        ;; aka Silmaril DTD was a project whose goal was to produce a GPL'ed
        ;; DTD that would encompass all the incompatible HTML extensions
        ;; procured by Netscape, MSIE, and other players in the field.
        ;; Apparently the project got abandoned, the last available version
        ;; being "Draft 0 Revision 11" from January 1997, as documented at
        ;; <http://imbolc.ucc.ie/~pflynn/articles/htmlpro.html>.
      
        ;; Since by now HTML Pro is remembered by none but the most die-hard
        ;; early-web-days nostalgics and used by not even them, there is no
        ;; use in specifying it.  So we return the standard HTML 4.0
        ;; declaration, which makes generated HTML technically illegal.  If
        ;; you have a problem with that, use the `css' engine designed to
        ;; create fully conforming HTML.
      
        "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\">"
      
        ;; Now-abandoned HTML Pro declaration.
        ;"<!DOCTYPE HTML PUBLIC \"+//Silmaril//DTD HTML Pro v0r11 19970101//EN\">"
        )
      
      (defun htmlize-default-body-tag (face-map)
        nil                                   ; no doc-string
        "<body>")
      
      ;;; CSS based output support.
      
      ;; Internal function; not a method.
      (defun htmlize-css-specs (fstruct)
        (let (result)
          (when (htmlize-fstruct-foreground fstruct)
            (push (format "color: %s;" (htmlize-fstruct-foreground fstruct))
                  result))
          (when (htmlize-fstruct-background fstruct)
            (push (format "background-color: %s;"
                          (htmlize-fstruct-background fstruct))
                  result))
          (let ((size (htmlize-fstruct-size fstruct)))
            (when (and size (not (eq htmlize-ignore-face-size t)))
              (cond ((floatp size)
                     (push (format "font-size: %d%%;" (* 100 size)) result))
                    ((not (eq htmlize-ignore-face-size 'absolute))
                     (push (format "font-size: %spt;" (/ size 10.0)) result)))))
          (when (htmlize-fstruct-boldp fstruct)
            (push "font-weight: bold;" result))
          (when (htmlize-fstruct-italicp fstruct)
            (push "font-style: italic;" result))
          (when (htmlize-fstruct-underlinep fstruct)
            (push "text-decoration: underline;" result))
          (when (htmlize-fstruct-overlinep fstruct)
            (push "text-decoration: overline;" result))
          (when (htmlize-fstruct-strikep fstruct)
            (push "text-decoration: line-through;" result))
          (nreverse result)))
      
      (defun htmlize-css-insert-head (buffer-faces face-map)
        (insert "    <style type=\"text/css\">\n    <!--\n")
        (insert "      body {\n        "
                (mapconcat #'identity
                           (htmlize-css-specs (gethash 'default face-map))
                           "\n        ")
                "\n      }\n")
        (dolist (face (sort* (copy-list buffer-faces) #'string-lessp
                             :key (lambda (f)
                                    (htmlize-fstruct-css-name (gethash f face-map)))))
          (let* ((fstruct (gethash face face-map))
                 (cleaned-up-face-name
                  (let ((s
                         ;; Use `prin1-to-string' rather than `symbol-name'
                         ;; to get the face name because the "face" can also
                         ;; be an attrlist, which is not a symbol.
                         (prin1-to-string face)))
                    ;; If the name contains `--' or `*/', remove them.
                    (while (string-match "--" s)
                      (setq s (replace-match "-" t t s)))
                    (while (string-match "\\*/" s)
                      (setq s (replace-match "XX" t t s)))
                    s))
                 (specs (htmlize-css-specs fstruct)))
            (insert "      ." (htmlize-fstruct-css-name fstruct))
            (if (null specs)
                (insert " {")
              (insert " {\n        /* " cleaned-up-face-name " */\n        "
                      (mapconcat #'identity specs "\n        ")))
            (insert "\n      }\n")))
        (insert htmlize-hyperlink-style
                "    -->\n    </style>\n"))
      
      (defun htmlize-css-insert-text (text fstruct-list buffer)
        ;; Insert TEXT colored with FACES into BUFFER.  In CSS mode, this is
        ;; easy: just nest the text in one <span class=...> tag for each
        ;; face in FSTRUCT-LIST.
        (dolist (fstruct fstruct-list)
          (princ "<span class=\"" buffer)
          (princ (htmlize-fstruct-css-name fstruct) buffer)
          (princ "\">" buffer))
        (princ text buffer)
        (dolist (fstruct fstruct-list)
          (ignore fstruct)                    ; shut up the byte-compiler
          (princ "</span>" buffer)))
      
      ;; `inline-css' output support.
      
      (defun htmlize-inline-css-body-tag (face-map)
        (format "<body style=\"%s\">"
                (mapconcat #'identity (htmlize-css-specs (gethash 'default face-map))
                           " ")))
      
      (defun htmlize-inline-css-insert-text (text fstruct-list buffer)
        (let* ((merged (htmlize-merge-faces fstruct-list))
               (style (htmlize-memoize
                       merged
                       (let ((specs (htmlize-css-specs merged)))
                         (and specs
                              (mapconcat #'identity (htmlize-css-specs merged) " "))))))
          (when style
            (princ "<span style=\"" buffer)
            (princ style buffer)
            (princ "\">" buffer))
          (princ text buffer)
          (when style
            (princ "</span>" buffer))))
      
      ;;; `font' tag based output support.
      
      (defun htmlize-font-body-tag (face-map)
        (let ((fstruct (gethash 'default face-map)))
          (format "<body text=\"%s\" bgcolor=\"%s\">"
                  (htmlize-fstruct-foreground fstruct)
                  (htmlize-fstruct-background fstruct))))
             
      (defun htmlize-font-insert-text (text fstruct-list buffer)
        ;; In `font' mode, we use the traditional HTML means of altering
        ;; presentation: <font> tag for colors, <b> for bold, <u> for
        ;; underline, and <strike> for strike-through.
        (let* ((merged (htmlize-merge-faces fstruct-list))
               (markup (htmlize-memoize
                        merged
                        (cons (concat
                               (and (htmlize-fstruct-foreground merged)
                                    (format "<font color=\"%s\">" (htmlize-fstruct-foreground merged)))
                               (and (htmlize-fstruct-boldp merged)      "<b>")
                               (and (htmlize-fstruct-italicp merged)    "<i>")
                               (and (htmlize-fstruct-underlinep merged) "<u>")
                               (and (htmlize-fstruct-strikep merged)    "<strike>"))
                              (concat
                               (and (htmlize-fstruct-strikep merged)    "</strike>")
                               (and (htmlize-fstruct-underlinep merged) "</u>")
                               (and (htmlize-fstruct-italicp merged)    "</i>")
                               (and (htmlize-fstruct-boldp merged)      "</b>")
                               (and (htmlize-fstruct-foreground merged) "</font>"))))))
          (princ (car markup) buffer)
          (princ text buffer)
          (princ (cdr markup) buffer)))
      
      (defun htmlize-buffer-1 ()
        ;; Internal function; don't call it from outside this file.  Htmlize
        ;; current buffer, writing the resulting HTML to a new buffer, and
        ;; return it.  Unlike htmlize-buffer, this doesn't change current
        ;; buffer or use switch-to-buffer.
        (save-excursion
          ;; Protect against the hook changing the current buffer.
          (save-excursion
            (run-hooks 'htmlize-before-hook))
          ;; Convince font-lock support modes to fontify the entire buffer
          ;; in advance.
          (htmlize-ensure-fontified)
          (clrhash htmlize-extended-character-cache)
          (clrhash htmlize-memoization-table)
          (let* ((buffer-faces (htmlize-faces-in-buffer))
                 (face-map (htmlize-make-face-map (adjoin 'default buffer-faces)))
                 ;; Generate the new buffer.  It's important that it inherits
                 ;; default-directory from the current buffer.
                 (htmlbuf (generate-new-buffer (if (buffer-file-name)
                                                   (htmlize-make-file-name
                                                    (file-name-nondirectory
                                                     (buffer-file-name)))
                                                 "*html*")))
                 ;; Having a dummy value in the plist allows writing simply
                 ;; (plist-put places foo bar).
                 (places '(nil nil))
                 (title (if (buffer-file-name)
                            (file-name-nondirectory (buffer-file-name))
                          (buffer-name))))
            ;; Initialize HTMLBUF and insert the HTML prolog.
            (with-current-buffer htmlbuf
              (buffer-disable-undo)
              (insert (htmlize-method doctype) ?\n
                      (format "<!-- Created by htmlize-%s in %s mode. -->\n"
                              htmlize-version htmlize-output-type)
                      "<html>\n  ")
              (plist-put places 'head-start (point-marker))
              (insert "<head>\n"
                      "    <title>" (htmlize-protect-string title) "</title>\n"
                      (if htmlize-html-charset
                          (format (concat "    <meta http-equiv=\"Content-Type\" "
                                          "content=\"text/html; charset=%s\">\n")
                                  htmlize-html-charset)
                        "")
                      htmlize-head-tags)
              (htmlize-method insert-head buffer-faces face-map)
              (insert "  </head>")
              (plist-put places 'head-end (point-marker))
              (insert "\n  ")
              (plist-put places 'body-start (point-marker))
              (insert (htmlize-method body-tag face-map)
                      "\n    ")
              (plist-put places 'content-start (point-marker))
              (insert "<pre>\n"))
            (let ((insert-text-method
                   ;; Get the inserter method, so we can funcall it inside
                   ;; the loop.  Not calling `htmlize-method' in the loop
                   ;; body yields a measurable speed increase.
                   (htmlize-method-function 'insert-text))
                  ;; Declare variables used in loop body outside the loop
                  ;; because it's faster to establish `let' bindings only
                  ;; once.
                  next-change text face-list fstruct-list trailing-ellipsis)
              ;; This loop traverses and reads the source buffer, appending
              ;; the resulting HTML to HTMLBUF with `princ'.  This method is
              ;; fast because: 1) it doesn't require examining the text
              ;; properties char by char (htmlize-next-change is used to
              ;; move between runs with the same face), and 2) it doesn't
              ;; require buffer switches, which are slow in Emacs.
              (goto-char (point-min))
              (while (not (eobp))
                (setq next-change (htmlize-next-change (point) 'face))
                ;; Get faces in use between (point) and NEXT-CHANGE, and
                ;; convert them to fstructs.
                (setq face-list (htmlize-faces-at-point)
                      fstruct-list (delq nil (mapcar (lambda (f)
                                                       (gethash f face-map))
                                                     face-list)))
                ;; Extract buffer text, sans the invisible parts.  Then
                ;; untabify it and escape the HTML metacharacters.
                (setq text (htmlize-buffer-substring-no-invisible
                            (point) next-change))
                (when trailing-ellipsis
                  (setq text (htmlize-trim-ellipsis text)))
                ;; If TEXT ends up empty, don't change trailing-ellipsis.
                (when (> (length text) 0)
                  (setq trailing-ellipsis
                        (get-text-property (1- (length text))
                                           'htmlize-ellipsis text)))
                (setq text (htmlize-untabify text (current-column)))
                (setq text (htmlize-protect-string text))
                ;; Don't bother writing anything if there's no text (this
                ;; happens in invisible regions).
                (when (> (length text) 0)
                  ;; Insert the text, along with the necessary markup to
                  ;; represent faces in FSTRUCT-LIST.
                  (funcall insert-text-method text fstruct-list htmlbuf))
                (goto-char next-change)))
      
            ;; Insert the epilog and post-process the buffer.
            (with-current-buffer htmlbuf
              (insert "</pre>")
              (plist-put places 'content-end (point-marker))
              (insert "\n  </body>")
              (plist-put places 'body-end (point-marker))
              (insert "\n</html>\n")
              (when htmlize-generate-hyperlinks
                (htmlize-make-hyperlinks))
              (htmlize-defang-local-variables)
              (when htmlize-replace-form-feeds
                ;; Change each "\n^L" to "<hr />".
                (goto-char (point-min))
                (let ((source
                       ;; ^L has already been escaped, so search for that.
                       (htmlize-protect-string "\n\^L"))
                      (replacement
                       (if (stringp htmlize-replace-form-feeds)
                           htmlize-replace-form-feeds
                         "</pre><hr /><pre>")))
                  (while (search-forward source nil t)
                    (replace-match replacement t t))))
              (goto-char (point-min))
              (when htmlize-html-major-mode
                ;; What sucks about this is that the minor modes, most notably
                ;; font-lock-mode, won't be initialized.  Oh well.
                (funcall htmlize-html-major-mode))
              (set (make-local-variable 'htmlize-buffer-places) places)
              (run-hooks 'htmlize-after-hook)
              (buffer-enable-undo))
            htmlbuf)))
      
      ;; Utility functions.
      
      (defmacro htmlize-with-fontify-message (&rest body)
        ;; When forcing fontification of large buffers in
        ;; htmlize-ensure-fontified, inform the user that he is waiting for
        ;; font-lock, not for htmlize to finish.
        `(progn
           (if (> (buffer-size) 65536)
               (message "Forcing fontification of %s..."
                        (buffer-name (current-buffer))))
           ,@body
           (if (> (buffer-size) 65536)
               (message "Forcing fontification of %s...done"
                        (buffer-name (current-buffer))))))
      
      (defun htmlize-ensure-fontified ()
        ;; If font-lock is being used, ensure that the "support" modes
        ;; actually fontify the buffer.  If font-lock is not in use, we
        ;; don't care because, except in htmlize-file, we don't force
        ;; font-lock on the user.
        (when (and (boundp 'font-lock-mode)
                   font-lock-mode)
          ;; In part taken from ps-print-ensure-fontified in GNU Emacs 21.
          (cond
           ((and (boundp 'jit-lock-mode)
                 (symbol-value 'jit-lock-mode))
            (htmlize-with-fontify-message
             (jit-lock-fontify-now (point-min) (point-max))))
           ((and (boundp 'lazy-lock-mode)
                 (symbol-value 'lazy-lock-mode))
            (htmlize-with-fontify-message
             (lazy-lock-fontify-region (point-min) (point-max))))
           ((and (boundp 'lazy-shot-mode)
                 (symbol-value 'lazy-shot-mode))
            (htmlize-with-fontify-message
             ;; lazy-shot is amazing in that it must *refontify* the region,
             ;; even if the whole buffer has already been fontified.  <sigh>
             (lazy-shot-fontify-region (point-min) (point-max))))
           ;; There's also fast-lock, but we don't need to handle specially,
           ;; I think.  fast-lock doesn't really defer fontification, it
           ;; just saves it to an external cache so it's not done twice.
           )))
      
      
      ;;;###autoload
      (defun htmlize-buffer (&optional buffer)
        "Convert BUFFER to HTML, preserving colors and decorations.
      
      The generated HTML is available in a new buffer, which is returned.
      When invoked interactively, the new buffer is selected in the current
      window.  The title of the generated document will be set to the buffer's
      file name or, if that's not available, to the buffer's name.
      
      Note that htmlize doesn't fontify your buffers, it only uses the
      decorations that are already present.  If you don't set up font-lock or
      something else to fontify your buffers, the resulting HTML will be
      plain.  Likewise, if you don't like the choice of colors, fix the mode
      that created them, or simply alter the faces it uses."
        (interactive)
        (let ((htmlbuf (with-current-buffer (or buffer (current-buffer))
                         (htmlize-buffer-1))))
          (when (interactive-p)
            (switch-to-buffer htmlbuf))
          htmlbuf))
      
      ;;;###autoload
      (defun htmlize-region (beg end)
        "Convert the region to HTML, preserving colors and decorations.
      See `htmlize-buffer' for details."
        (interactive "r")
        ;; Don't let zmacs region highlighting end up in HTML.
        (when (fboundp 'zmacs-deactivate-region)
          (zmacs-deactivate-region))
        (let ((htmlbuf (save-restriction
                         (narrow-to-region beg end)
                         (htmlize-buffer-1))))
          (when (interactive-p)
            (switch-to-buffer htmlbuf))
          htmlbuf))
      
      (defun htmlize-region-for-paste (beg end)
        "Htmlize the region and return just the HTML as a string.
      This forces the `inline-css' style and only returns the HTML body,
      but without the BODY tag.  This should make it useful for inserting
      the text to another HTML buffer."
        (let* ((htmlize-output-type 'inline-css)
               (htmlbuf (htmlize-region beg end)))
          (unwind-protect
              (with-current-buffer htmlbuf
                (buffer-substring (plist-get htmlize-buffer-places 'content-start)
                                  (plist-get htmlize-buffer-places 'content-end)))
            (kill-buffer htmlbuf))))
      
      (defun htmlize-make-file-name (file)
        "Make an HTML file name from FILE.
      
      In its default implementation, this simply appends `.html' to FILE.
      This function is called by htmlize to create the buffer file name, and
      by `htmlize-file' to create the target file name.
      
      More elaborate transformations are conceivable, such as changing FILE's
      extension to `.html' (\"file.c\" -> \"file.html\").  If you want them,
      overload this function to do it and htmlize will comply."
        (concat file ".html"))
      
      ;; Older implementation of htmlize-make-file-name that changes FILE's
      ;; extension to ".html".
      ;(defun htmlize-make-file-name (file)
      ;  (let ((extension (file-name-extension file))
      ;       (sans-extension (file-name-sans-extension file)))
      ;    (if (or (equal extension "html")
      ;           (equal extension "htm")
      ;           (equal sans-extension ""))
      ;       (concat file ".html")
      ;      (concat sans-extension ".html"))))
      
      ;;;###autoload
      (defun htmlize-file (file &optional target)
        "Load FILE, fontify it, convert it to HTML, and save the result.
      
      Contents of FILE are inserted into a temporary buffer, whose major mode
      is set with `normal-mode' as appropriate for the file type.  The buffer
      is subsequently fontified with `font-lock' and converted to HTML.  Note
      that, unlike `htmlize-buffer', this function explicitly turns on
      font-lock.  If a form of highlighting other than font-lock is desired,
      please use `htmlize-buffer' directly on buffers so highlighted.
      
      Buffers currently visiting FILE are unaffected by this function.  The
      function does not change current buffer or move the point.
      
      If TARGET is specified and names a directory, the resulting file will be
      saved there instead of to FILE's directory.  If TARGET is specified and
      does not name a directory, it will be used as output file name."
        (interactive (list (read-file-name
                            "HTML-ize file: "
                            nil nil nil (and (buffer-file-name)
                                             (file-name-nondirectory
                                              (buffer-file-name))))))
        (let ((output-file (if (and target (not (file-directory-p target)))
                               target
                             (expand-file-name
                              (htmlize-make-file-name (file-name-nondirectory file))
                              (or target (file-name-directory file)))))
              ;; Try to prevent `find-file-noselect' from triggering
              ;; font-lock because we'll fontify explicitly below.
              (font-lock-mode nil)
              (font-lock-auto-fontify nil)
              (global-font-lock-mode nil)
              ;; Ignore the size limit for the purposes of htmlization.
              (font-lock-maximum-size nil)
              ;; Disable font-lock support modes.  This will only work in
              ;; more recent Emacs versions, so htmlize-buffer-1 still needs
              ;; to call htmlize-ensure-fontified.
              (font-lock-support-mode nil))
          (with-temp-buffer
            ;; Insert FILE into the temporary buffer.
            (insert-file-contents file)
            ;; Set the file name so normal-mode and htmlize-buffer-1 pick it
            ;; up.  Restore it afterwards so with-temp-buffer's kill-buffer
            ;; doesn't complain about killing a modified buffer.
            (let ((buffer-file-name file))
              ;; Set the major mode for the sake of font-lock.
              (normal-mode)
              (font-lock-mode 1)
              (unless font-lock-mode
                ;; In GNU Emacs (font-lock-mode 1) doesn't force font-lock,
                ;; contrary to the documentation.  This seems to work.
                (font-lock-fontify-buffer))
              ;; htmlize the buffer and save the HTML.
              (with-current-buffer (htmlize-buffer-1)
                (unwind-protect
                    (progn
                      (run-hooks 'htmlize-file-hook)
                      (write-region (point-min) (point-max) output-file))
                  (kill-buffer (current-buffer)))))))
        ;; I haven't decided on a useful return value yet, so just return
        ;; nil.
        nil)
      
      ;;;###autoload
      (defun htmlize-many-files (files &optional target-directory)
        "Convert FILES to HTML and save the corresponding HTML versions.
      
      FILES should be a list of file names to convert.  This function calls
      `htmlize-file' on each file; see that function for details.  When
      invoked interactively, you are prompted for a list of files to convert,
      terminated with RET.
      
      If TARGET-DIRECTORY is specified, the HTML files will be saved to that
      directory.  Normally, each HTML file is saved to the directory of the
      corresponding source file."
        (interactive
         (list
          (let (list file)
            ;; Use empty string as DEFAULT because setting DEFAULT to nil
            ;; defaults to the directory name, which is not what we want.
            (while (not (equal (setq file (read-file-name
                                           "HTML-ize file (RET to finish): "
                                           (and list (file-name-directory
                                                      (car list)))
                                           "" t))
                               ""))
              (push file list))
            (nreverse list))))
        ;; Verify that TARGET-DIRECTORY is indeed a directory.  If it's a
        ;; file, htmlize-file will use it as target, and that doesn't make
        ;; sense.
        (and target-directory
             (not (file-directory-p target-directory))
             (error "target-directory must name a directory: %s" target-directory))
        (dolist (file files)
          (htmlize-file file target-directory)))
      
      ;;;###autoload
      (defun htmlize-many-files-dired (arg &optional target-directory)
        "HTMLize dired-marked files."
        (interactive "P")
        (htmlize-many-files (dired-get-marked-files nil arg) target-directory))
      
      (provide 'htmlize)
      
      ;;; htmlize.el ends here
    #+end_src

* Skeletons
** Setup

   #+begin_src emacs-lisp 
     (setq skeleton-pair t)
     (global-set-key (kbd "(") 'skeleton-pair-insert-maybe)
     (global-set-key (kbd "[") 'skeleton-pair-insert-maybe)
     (global-set-key (kbd "{") 'skeleton-pair-insert-maybe)
     (global-set-key (kbd "\"") 'skeleton-pair-insert-maybe)
     (setq abbrev-mode t)
     
     (add-hook 'clojure-mode-hook 
               (lambda ()
                 (setq local-abbrev-table clojure-mode-abbrev-table)))
     
     (define-abbrev-table 'java-mode-abbrev-table '())
     (define-abbrev-table 'emacs-lisp-mode-abbrev-table '())
     (define-abbrev-table 'clojure-mode-abbrev-table '())
     (define-abbrev-table 'scheme-mode-abbrev-table '())
     (define-abbrev-table 'c++-mode-abbrev-table '())
     
   #+end_src

** Clojure

   #+begin_src emacs-lisp 
     (define-skeleton skel-clojure-println
       ""
       nil
       "(println "_")")
     (define-abbrev clojure-mode-abbrev-table "prt" "" 'skel-clojure-println)
     
     (define-skeleton skel-clojure-defn
       ""
       nil
       "(defn "_" [])")
     (define-abbrev clojure-mode-abbrev-table "defn" "" 'skel-clojure-defn)
     
     (define-skeleton skel-clojure-defn-
       ""
       nil
       "(defn- "_" [])")
     (define-abbrev clojure-mode-abbrev-table "def-" "" 'skel-clojure-defn- )
     
     (define-skeleton skel-clojure-if
       ""
       nil
       "(if ("_"))")
     (define-abbrev clojure-mode-abbrev-table "if" "" 'skel-clojure-if )
     
     (define-skeleton skel-clojure-let
       ""
       nil
       "(let ["_"] )")
     (define-abbrev clojure-mode-abbrev-table "let" "" 'skel-clojure-let)
     
     (define-skeleton skel-clojure-ref-set
       ""
       nil
       "(dosync (ref-set "_" ))")
     (define-abbrev clojure-mode-abbrev-table "refs" "" 'skel-clojure-ref-set)
     
     (define-skeleton skel-clojure-proxy
       ""
       nil
       "(proxy ["_"] [] "
       \n > ")")
     (define-abbrev clojure-mode-abbrev-table "proxy" "" 'skel-clojure-proxy)
     
     (define-skeleton skel-clojure-doseq
       ""
       nil
       "(doseq ["_"] "
       \n > ")")
     (define-abbrev clojure-mode-abbrev-table "doseq" "" 'skel-clojure-doseq)
     
     (define-skeleton skel-clojure-do
       ""
       nil
       "(do "_" "
       \n > ")")
     (define-abbrev clojure-mode-abbrev-table "do" "" 'skel-clojure-do)
     
     (define-skeleton skel-clojure-reduce
       ""
       nil
       "(reduce (fn[h v] ) "_" ) ")
     
     (define-abbrev clojure-mode-abbrev-table "reduce" "" 'skel-clojure-reduce)
     
     (define-skeleton skel-clojure-try
       ""
       nil
       "(try "_" (catch Exception e (println e)))")
     
     (define-abbrev clojure-mode-abbrev-table "try" "" 'skel-clojure-try)
     
     (define-skeleton skel-clojure-map
       ""
       nil
       "(map #() "_")")
     
     (define-abbrev clojure-mode-abbrev-table "map" "" 'skel-clojure-map)
     
   #+end_src

** Scheme

   #+begin_src emacs-lisp 
     (define-skeleton skel-scheme-display
       ""
       nil
       "(display "_")")
     (define-abbrev scheme-mode-abbrev-table "prt" "" 'skel-scheme-display)
     
     (define-skeleton skel-scheme-defn
       ""
       nil
       "(define ("_"))")
     (define-abbrev scheme-mode-abbrev-table "defn" "" 'skel-scheme-defn)
     
     (define-skeleton skel-scheme-if
       ""
       nil
       "(if ("_"))")
     (define-abbrev scheme-mode-abbrev-table "if" "" 'skel-scheme-if )
     
     (define-skeleton skel-scheme-let
       ""
       nil
       "(let ("_"))")
     (define-abbrev scheme-mode-abbrev-table "let" "" 'skel-scheme-let)
     
     (define-skeleton skel-scheme-for-each
       ""
       nil
       "(for-each (lambda ("_") ()))")
     (define-abbrev scheme-mode-abbrev-table "fore" "" 'skel-scheme-for-each)
     
     (define-skeleton skel-scheme-begin
       ""
       nil
       "(begin "_" "
       \n > ")")
     (define-abbrev scheme-mode-abbrev-table "begin" "" 'skel-scheme-do)
     
     (define-skeleton skel-scheme-reduce
       ""
       nil
       "(fold-right (lambda ("_") ()))")
     (define-abbrev scheme-mode-abbrev-table "reduce" "" 'skel-scheme-reduce)
     
     (define-skeleton skel-scheme-map
       ""
       nil
       "(map (lambda ("_") ()))")
     (define-abbrev scheme-mode-abbrev-table "map" "" 'skel-scheme-map)
     
   #+end_src

** Cpp

   #+begin_src emacs-lisp 
     (define-skeleton skel-cpp-prt
       ""
       nil
       \n >
       "cout<< " _ " <<endl;"
       \n >)
     (define-abbrev c++-mode-abbrev-table "cout"  "" 'skel-cpp-prt )
     
   #+end_src

** ELisp

   #+begin_src emacs-lisp 
     (define-skeleton skel-list-insert
       ""
       nil
       "(insert "_" )")
     (define-abbrev lisp-mode-abbrev-table "ins" "" 'skel-list-insert )
     
     (define-skeleton skel-list-setq
       ""
       nil
       "(setq "_" )")
     (define-abbrev lisp-mode-abbrev-table "set" "" 'skel-list-setq )
     
     (define-skeleton skel-list-deffun
       ""
       nil
       "(defun "_" () "
       \n >
       ")")
     (define-abbrev lisp-mode-abbrev-table "deff" "" 'skel-list-deffun )
     
     (define-skeleton skel-list-defvar
       ""
       nil
       "(defvar "_" )")
     (define-abbrev lisp-mode-abbrev-table "defv" "" 'skel-list-defvar )
     
     (define-skeleton skel-list-if
       ""
       nil
       "(if "
       _
       \n >
       " )")
     (define-abbrev lisp-mode-abbrev-table "if" "" 'skel-list-if )
     
     (define-skeleton skel-list-progn
       ""
       nil
       "(progn "
       _
       \n >
       " )")
     (define-abbrev lisp-mode-abbrev-table "progn" "" 'skel-list-progn )
     
   #+end_src

** Java

   #+begin_src emacs-lisp 
     (define-skeleton skel-java-println
       "Insert a Java println Statement"
       nil
       "System.out.println(" _ " );")
     (define-abbrev java-mode-abbrev-table "prt" "" 'skel-java-println )
     
     (define-skeleton skel-java-ife
       "Insert a Common If else Statement"
       nil
       \n >
       "if (" _ " ){"
       \n >
       "} else {"
       \n >
       "}")
     (define-abbrev java-mode-abbrev-table "ife" "" 'skel-java-ife )
     
     (define-skeleton skel-java-try
       "Insert a try catch block"
       nil
       \n >
       "try{"
       \n >
       _ \n
       "}catch( Exception e ) {" >
       " "
       \n > \n
       "}" >)
     (define-abbrev java-mode-abbrev-table "try" "" 'skel-java-try )
     
     (define-skeleton skel-java-if
       "Insert a Common If Statement"
       nil
       \n >
       "if (" _ " ){"
       \n >
       "}")
     
     (define-abbrev java-mode-abbrev-table "if" "" 'skel-java-if )
     (define-abbrev c++-mode-abbrev-table "if"  "" 'skel-java-if )
     
     (define-skeleton skel-java-for1
       "Insert a Common If Statement"
       nil
       \n >
       "for( int i=0 ; i<" _ " ;i++){"
       \n >
       "}")
     (define-abbrev java-mode-abbrev-table "for1" "" 'skel-java-for1 )
     
     
     (define-skeleton skel-java-timer
       "creates timing statements"
       nil
       \n >
       "final long start = System.currentTimeMillis();"
       \n >
       "System.out.println( Long.toString( System.currentTimeMillis() - start ) ) ;")
     (define-abbrev java-mode-abbrev-table "jtimer" "" 'skel-java-timer )
     
     (define-skeleton skel-java-comment
       "creates javadoc comment"
       nil
       \n >
       "/*"
       \n >
       "*"
       \n >
       "*"
       \n >
       "*"
       \n >
       "* @param"
       \n >
       "* @return"
       \n >
       "* @exception"
       \n >
       "*"
       \n >
       "*/"
       \n >)
     (define-abbrev java-mode-abbrev-table "jdcomment" "" 'skel-java-comment )
     
   #+end_src

** Org

   #+begin_src emacs-lisp
     (define-skeleton skel-org-src
       "Insert org src block."
       nil
       >
       "#+begin_src "
        _ 
       \n > 
        "#""+end_src"
        >)
     (define-abbrev text-mode-abbrev-table "osrc" "" 'skel-org-src)
     
     (define-skeleton skel-org-src
       "Insert org src block clojure."
       nil
       >
       "#+begin_src clojure"
       \n >
        _ 
       \n > 
        "#""+end_src"
        >)
     (define-abbrev text-mode-abbrev-table "ocsrc" "" 'skel-org-src)
   #+end_src
